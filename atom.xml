<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K`onnor</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-03T03:45:48.411Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KangKang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统的常见面试题</title>
    <link href="http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-04-02T07:34:16.000Z</published>
    <updated>2022-04-03T03:45:48.411Z</updated>
    
    <content type="html"><![CDATA[<p>这篇整理一下面试中经常出现的操作系统面试题</p><hr><h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><ul><li><strong>根本区别</strong>：<strong>进程是操作系统分配资源的基本单位，线程是任务调度和执行的基本单位。</strong></li><li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间(上线文切换)，程序之间的切换会有较大的开销。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器(pc)，线程之间的切换开销比较小。</li><li><strong>所处环境</strong>：在操<strong>作系统中能同时运行多个进程</strong>，而在<strong>同一个进程中有多个线程同时执行</strong>(通过CPU调度，在每个时间片中只有一个线程)</li><li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间。而对于线程而言，除CPU外，系统不会为线程分配内存(线程所使用的资源来自其所属进程的资源)，线程组之间只能共享资源.</li></ul><h4 id="进程的状态及转换？"><a href="#进程的状态及转换？" class="headerlink" title="进程的状态及转换？"></a>进程的状态及转换？</h4><ul><li><strong>创建</strong>状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li><li><strong>就绪</strong>状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</li><li><strong>执行</strong>状态：进程处于就绪状态<strong>被调度</strong>后，进程进入执行状态</li><li><strong>阻塞</strong>状态：正在执行的进程由于<strong>某些事件（I/O请求，申请缓存区失败）</strong>而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li><li><strong>终止</strong>状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li></ul><p><img src= "/img/loading.gif" data-src="/photo/MST3-1.jpg" alt=""> </p><h4 id="进程-作业的调度算法？"><a href="#进程-作业的调度算法？" class="headerlink" title="进程/作业的调度算法？"></a>进程/作业的调度算法？</h4><p><strong>1、先来先服务(FCFS)调度算法</strong></p><p><strong>概念</strong>：按照进程进入系统的<strong>先后次序进行调度</strong>，先进入系统者先调度；即启动等待时间最长的作业/进程。是一种最简单的调度算法，即可用于作业调度，也可用于进程调度</p><p><strong>优缺点：</strong></p><ul><li>比较有利于长作业（进程），而不利于短作业（进程）</li><li>有利于CPU繁忙型作业（进程），而不利于I/O繁忙型作业（进程）</li><li>用于批处理系统，不适于分时系统</li></ul><p><strong>2、短作业优先调度算法（SJF）</strong></p><p><strong>概念</strong>：从队列中选出一个<strong>估计运行时间最短</strong>的进程优先调度，即可用于作业调度，也可用于进程调度</p><p><strong>优缺点：</strong></p><ul><li>对长作业不利。严重的是，若一长作业(进程)进入系统的后备队列(就绪队列)，由于调度程序总是优先调度那些(即使是后进来的)短作业(进程)，将导致长作业(进程)长期不被调度，<strong>可能出现饥饿的情况</strong></li><li>完全未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li><li>比较有利于短作业（进程），而不利于长作业（进程）</li></ul><p><strong>3、高优先权调度算法</strong></p><p><strong>非抢占式优先权调度算法</strong>：系统一旦把处理机<strong>分配给就绪队列中优先权最高的进程</strong>后，该进程便一直执行下去，直至完成，或因发生某事件使该进程放弃处理机时，系统才将处理机重新分配给另一优先权最高的进程主要用于批处理系统中，也可用于某些对实时性要求不严的实时系统中</p><p><strong>抢占式优先权调度算法</strong>：把处理机分配给优先权最高的进程，但在执行期间，<strong>只要出现另一个优先权更高的进程，则进程调度程序就立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程</strong></p><p><strong>4、高响应比优先调度算法</strong></p><p><strong>概念</strong>：高响应比优先调度算法<strong>既考虑作业的执行时间也考虑作业的等待时间</strong>，综合了先来先服务和最短作业优先两种算法的特点。<br>该算法中的响应比是指作业等待时间与运行比值，响应比公式：响应比 =（等待时间+要求服务时间）/要求服务时间</p><p><strong>优缺点：</strong></p><ul><li>优点：等待时间相同的作业，则要求服务的时间愈短，其优先权愈高，——对短作业有利。对于长作业，优先权随等待时间的增加而提高，其等待时间足够长时，其优先权便可升到很高，从而也可获得处理机——对长作业有利。既照顾了短作业，又考虑了作业到达的先后次序，又不会使长作业长期得不到服务</li><li>缺点：要进行响应比计算，增加了系统开销</li></ul><p><strong>5、时间片轮转法</strong></p><p><strong>概念</strong>：将所有的就绪进程<strong>按先来先服务的原则排成一个队列</strong>，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便停止该进程的执行，并将其放就绪队列尾；然后，再把处理机分配给就绪队列中新的队首</p><h4 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h4><ul><li><strong>协程属于线程</strong>。协程程序是在线程里面跑的，因此协程又称微线程</li><li><strong>协程没有线程的上下文切换消耗</strong>。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li><li>原子操作性。由于<strong>协程是用户调度的</strong>，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li></ul><h4 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h4><ul><li>新建状态(New)：新创建了一个线程对象。</li><li>就绪状态(Runnable)：线程对象创建后，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</li><li>运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞状态(Blocked)：阻塞状态是线程放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</li></ul><h4 id="说一下进程间的通信方式？"><a href="#说一下进程间的通信方式？" class="headerlink" title="说一下进程间的通信方式？"></a>说一下进程间的通信方式？</h4><ul><li><strong>管道</strong>：分为匿名管道和命名管道，A进程将数据写入管道，B进程需要等待A进程将信息写完之后才能读出来。种方案不适合频繁的通信，优点就是简单。</li><li><strong>消息队列</strong>：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表，用户进程可以向消息队列中添加消息，也可以向消息队列中读取消息。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。缺点是如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，这需要花费很多时间。</li><li><strong>共享内存</strong>：该通信方式就可以很好的解决拷贝所消耗的时间，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</li><li><strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。信号量定义了两种操作，P操作和V操作，P操作为申请资源，V操作是归还资源。</li><li><strong>套接字Socket</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ul><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><ul><li><strong>概念</strong>：所谓死锁，是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</li><li><strong>原因</strong>：两个进程竞争不可剥夺资源或者进程推进的顺序非法都可能产生死锁</li></ul><h4 id="死锁产生的四个必要条件？"><a href="#死锁产生的四个必要条件？" class="headerlink" title="死锁产生的四个必要条件？"></a>死锁产生的四个必要条件？</h4><ul><li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即<strong>在一段时间内某资源仅为一进程所占用</strong>。</li><li><strong>请求保持条件</strong>：当进程因请求资源而阻塞时，<strong>对已获得的资源保持不放</strong>。</li><li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，<strong>不能剥夺</strong>，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程—资源的环形链。</li></ul><h4 id="解决死锁的基本方法？"><a href="#解决死锁的基本方法？" class="headerlink" title="解决死锁的基本方法？"></a>解决死锁的基本方法？</h4><ul><li><strong>资源一次性分配</strong>：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li><li><strong>可剥夺资源</strong>：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li><strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h4 id="避免死锁的方法？"><a href="#避免死锁的方法？" class="headerlink" title="避免死锁的方法？"></a>避免死锁的方法？</h4><p>死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。避免死锁的具体实现通常利用银行家算法。两种避免办法如下：</p><ul><li>如果一个进程的请求会导致死锁，则不启动该进程</li><li>如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。</li></ul><h4 id="信号和信号量区别"><a href="#信号和信号量区别" class="headerlink" title="信号和信号量区别"></a>信号和信号量区别</h4><p><strong>信号</strong>：（signal）是一种处理异步事件的方式。信号是比较复杂的通信方式，用于<strong>通知进程有某种事件发生</strong>，除了用于进程外，还可以发送信号给进程本身。是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。</p><p><strong>信号量</strong>：（Semaphore）<strong>进程间通信处理同步互斥的机制</strong>。信号量是一个特殊的变量，它的本质是计数器，信号量里面记录了临界资源的数目，有多少数目，信号量的值就为多少，进程对其访问都是原子操作。它的作用就是，调协进程对共享资源的访问，让一个临界区同一时间只有一个进程在访问它。</p><p>这样就可以看出信号和信号量的区别了：信号是通知进程产生了某个事件，信号量是用来同步进程的。</p><h4 id="同步与异步？"><a href="#同步与异步？" class="headerlink" title="同步与异步？"></a>同步与异步？</h4><ul><li><strong>I/O模型的同步和异步</strong>：select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</li><li><strong>线程进程的同步异步</strong>：多线程配合完成一件事时出现了强烈的依赖关系就是同步，没有依赖就是异步</li><li><strong>阻塞和非阻塞</strong>：阻塞就是调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。非阻塞等待就是每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</li></ul><h4 id="简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"><a href="#简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？" class="headerlink" title="简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"></a>简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</h4><ol><li><p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p><p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器(memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p></li><li><p><strong>虚拟内存</strong>：每个进程拥有独立的地址空间，这个<strong>空间被分为大小相等的多个块，称为页</strong>，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上<strong>其中一部分对应物理内存上的一块(称为帧）</strong>，还有一些没加载在内存中的对应在硬盘上。</p></li><li><p><strong>为什么要用虚拟内存</strong>：因为早期的内存分配方法存在以下问题：</p><p>（1）进程地址空间不隔离。会导致数据被随意修改。</p><p>（2）内存使用效率低。</p><p>（3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。</p></li><li><p><strong>使用虚拟内存的好处</strong>：</p><p>（1）扩大地址空间。</p><p>（2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。</p><p>（3）可以实现内存共享，方便进程通信。</p><p>（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。</p></li><li><p><strong>使用虚拟内存的缺点</strong>：</p><p>（1）虚拟内存需要额外构建数据结构，占用空间。</p><p>（2）虚拟地址到物理地址的转换，增加了执行时间。</p><p>（3）页面换入换出耗时。</p></li></ol><h4 id="虚拟地址到物理地址怎么映射的？"><a href="#虚拟地址到物理地址怎么映射的？" class="headerlink" title="虚拟地址到物理地址怎么映射的？"></a>虚拟地址到物理地址怎么映射的？</h4><p>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表中的每一项都记录了这个页的基地址。</p><h4 id="简述操作系统中malloc的实现原理"><a href="#简述操作系统中malloc的实现原理" class="headerlink" title="简述操作系统中malloc的实现原理"></a>简述操作系统中malloc的实现原理</h4><p>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p><h4 id="说说多路IO复用技术有哪些"><a href="#说说多路IO复用技术有哪些" class="headerlink" title="说说多路IO复用技术有哪些"></a>说说多路IO复用技术有哪些</h4><p><strong>select，poll，epoll</strong>都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作</p><h4 id="select-poll-epoll的区别"><a href="#select-poll-epoll的区别" class="headerlink" title="select/poll/epoll的区别"></a>select/poll/epoll的区别</h4><p><strong>select</strong>：它仅仅知道了有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><p><strong>poll</strong>：时间复杂度O(n)，poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><p><strong>epoll</strong>：时间复杂度O(1)，epoll不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇整理一下面试中经常出现的操作系统面试题&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;进程和线程的区别？&quot;&gt;&lt;a href=&quot;#进程和线程的区别？&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别？&quot;&gt;&lt;/a&gt;进程和线程的区别？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;s
      
    
    </summary>
    
    
      <category term="笔试面试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与计算机网络的常见面试题</title>
    <link href="http://yoursite.com/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-03-31T02:48:50.936Z</published>
    <updated>2022-04-03T09:13:53.312Z</updated>
    
    <content type="html"><![CDATA[<p>这篇整理一下面试中经常出现的数据结构已经计算机网络的问题</p><hr><h3 id="数据结构与算法面试题"><a href="#数据结构与算法面试题" class="headerlink" title="数据结构与算法面试题"></a>数据结构与算法面试题</h3><h4 id="解释一下顺序存储与链式存储"><a href="#解释一下顺序存储与链式存储" class="headerlink" title="解释一下顺序存储与链式存储"></a>解释一下顺序存储与链式存储</h4><ul><li>顺序存储结构是用一段连续的存储空间来存储数据元素，可以进行随机访问，访问效率较高。</li><li>链式存储结构是用任意的存储空间来存储数据元素，不可以进行随机访问，访问效率较低。</li></ul><h4 id="最小生成树的方法及思想"><a href="#最小生成树的方法及思想" class="headerlink" title="最小生成树的方法及思想"></a>最小生成树的方法及思想</h4><p>最小生成树是要找到最小的边可以把所有的节点都连接起来，且不形成环</p><ul><li><strong>普里姆(prim)算法</strong>：顶点集到其他点权值最小边加入新的顶点集，再找下一个与该顶点集相连的最小边，直到遍历所有点</li><li><strong>克鲁斯卡尔(kruskal)算法</strong>：依次选择最小边加入，使得无环且所有点遍历结束</li></ul><h4 id="贪心算法、动态规划、分治法的区别"><a href="#贪心算法、动态规划、分治法的区别" class="headerlink" title="贪心算法、动态规划、分治法的区别"></a>贪心算法、动态规划、分治法的区别</h4><ul><li><strong>贪心算法</strong>：局部最优，划分的每个子问题都最优，得到全局最优，但是不能保证是全局最优解，所以对于贪心算法来说，解是从上到下的，一步一步最优，直到最后。</li><li><strong>动态规划</strong>：将问题分解成重复的子问题，每次都寻找左右子问题解中最优的解，一步步得到全局的最优解。重复的子问题可以通过记录的方式，避免多次计算。所以对于动态规划来说，解是从小到上，从底层所有可能性中找到最优解，再一步步向上。</li><li><strong>分治法</strong>：和动态规划类似，将大问题分解成小问题，但是这些小问题是独立的，没有重复的问题。独立问题取得解，再合并成大问题的解。</li></ul><h4 id="判断一个链表是否有环，如何找到这个环的起点"><a href="#判断一个链表是否有环，如何找到这个环的起点" class="headerlink" title="判断一个链表是否有环，如何找到这个环的起点"></a>判断一个链表是否有环，如何找到这个环的起点</h4><ul><li><strong>如何判断是否存在环</strong>：设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出</li><li><strong>如何知道环的长度</strong>：记录下碰撞点p，slow、fast从该点开始，再次碰撞所走过的操作数就是环的长度s</li><li><strong>如何找出环的连接点在哪里</strong>：分别从碰撞点、头指针开始走，相遇的那个点就是连接点</li></ul><h4 id="口述一下各类排序算法的思想"><a href="#口述一下各类排序算法的思想" class="headerlink" title="口述一下各类排序算法的思想"></a>口述一下各类排序算法的思想</h4><ul><li><strong>直接插入排序(稳定)</strong>：将序列分为有序部分和无序部分，从无序部分依次选择元素与有序部分比较找到合适的位置，将原来的元素往后移，将元素插入到相应位置上，并加入有序的部分。<strong>时间复杂度为：O(n^2)，空间复杂度为O(1)</strong></li><li><strong>折半插入排序(稳定)</strong>：基本思想和直接插入排序相同，不过在比较适时需设置三个变量low high mid，令mid=(low+high)/2,若a[mid]&gt;key,则令high=mid-1,否则令low=mid+1,直到low&gt;high时停止循环，对序列中的每个元素做以上处理，找到合适位置将其他元素后移进行插入，<strong>比较次数为O(nlog2n)</strong>。</li><li><strong>希尔排序(不稳定)</strong>：：先将序列分为若干个子序列，对各子序列进行直接插入排序，等到序列基本有序时再对整个序列进行一次直接插入排序。优点是：让关键字值小的元素能够很快移动到前面，且序列基本有序时进行直接插入排序时间效率会提升很多，<strong>空间复杂度为O(1)。</strong></li><li><strong>冒泡排序(稳定)</strong>：每一趟都将元素进行两两比较，并且按照“前小后大”的规则进行交换。优点是：每一趟不仅能找到一个最大的元素放到序列后面，而且还把其他元素理顺，如果下一趟排序没有发生交换则可以提前结束排序。<strong>时间复杂度为O(n^2)，空间复杂度为O(1)。</strong></li><li><strong>快速排序(不稳定)</strong>：在序列中任意选择一个元素作为中心，比它大的元素一律向后移动，比它小的元素一律向前移动，形成左右两个子序列，再把子序列按上述操作进行调整，直到所有的子序列中都只有一个元素时序列即为有序。优点是：每一趟不仅能确定一个元素，时间效率较高。<strong>时间复杂度为O(nlog2n)，空间复杂度为O(log2n).</strong></li><li><strong>简单选择排序(不稳定)</strong>：将序列分为2部分，每经过一趟就在无序部分找到一个最小值然后与无序部分的第一个元素交换位置。优点是：实现简单，缺点是：每一趟只能确定一个元素的位置，时间效率低。<strong>时间复杂度为O(n^2)，空间复杂度为O(1)。</strong></li><li><strong>堆排序(不稳定)</strong>：设有一个任意序列，当满足下面特点时称之为堆：让此序列排列成完全二叉树，该树具有以下特点，该树中任意节点均大于或小于其左右孩子，此树的根节点为最大值或者最小值。优点是：对大文件效率明显提高，但对小文件效率不明显。<strong>时间复杂度为O(nlog2n)，空间复杂度为O(1)。</strong></li><li><strong>归并排序(稳定)</strong>：采用了分而治之的思想：第一, 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.第二, 对每个子序列分别调用归并排序MergeSort，进行递归操作。第三, 合并两个排好序的子序列,生成排序结果。<strong>时间复杂度为O(nlogn),空间复杂度为O(n)</strong></li></ul><h4 id="详细说一下堆排序"><a href="#详细说一下堆排序" class="headerlink" title="详细说一下堆排序"></a>详细说一下堆排序</h4><ol><li>将待排序的序列构造成一个大根堆(或小根堆)</li><li>大根堆要求：①根节点的关键字既<strong>大于或等于左子树的关键字值，又大于或等于右子树的关键字值</strong>。②为完全二叉树。（将大于全改成小于即为小根堆的要求）</li><li>此时，整个序列的最大值就是堆顶的根结点。将其与堆数组的末尾元素交换，此时末尾元素就是最大值</li><li>将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的此大值</li><li>如此反复执行，便能得到一个有序序列了</li></ol><h4 id="详细说一下快速排序"><a href="#详细说一下快速排序" class="headerlink" title="详细说一下快速排序"></a>详细说一下快速排序</h4><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol><h4 id="说一下平衡二叉树"><a href="#说一下平衡二叉树" class="headerlink" title="说一下平衡二叉树"></a>说一下平衡二叉树</h4><p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。</p><h4 id="说一下哈夫曼编码"><a href="#说一下哈夫曼编码" class="headerlink" title="说一下哈夫曼编码"></a>说一下哈夫曼编码</h4><p>哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1表示个字符的最优表示方式</p><h4 id="栈溢出的概念和原因"><a href="#栈溢出的概念和原因" class="headerlink" title="栈溢出的概念和原因"></a>栈溢出的概念和原因</h4><p>栈溢出概念：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p><p>栈溢出的原因：</p><ul><li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</li><li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li><li>指针或数组越界。</li></ul><h3 id="计算机网络面试题"><a href="#计算机网络面试题" class="headerlink" title="计算机网络面试题"></a>计算机网络面试题</h3><h4 id="说一下OSI七层模型"><a href="#说一下OSI七层模型" class="headerlink" title="说一下OSI七层模型"></a>说一下OSI七层模型</h4><ul><li><strong>应用层</strong>：应用层是开放系统的最高层,是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时,完成一系列业务处理所需的服务。<strong>主要的协议有http、ftp</strong></li><li><strong>表示层</strong>：表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li><strong>会话层</strong>：主要在你的系统之间发起会话或者接受会话请求。</li><li><strong>传输层</strong>：向它上面的应用层提供端到端通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。传输层对收到的报文进行差错检测。<strong>主要的协议有tcp和udp</strong>，tcp将数据封装成用户数据报或者说是报文，然后分段传输，udp将数据封装成用户数据报直接传输。</li><li><strong>网络层</strong>：主要的协议有ip，主要是将报文封装成ip数据报。</li><li><strong>数据链路层</strong>：ip数据报封装成帧，传给物理层。</li><li><strong>物理层</strong>：主要是将比特或者说是0和1转化为强弱电流，然后到接受方在将强弱电流转化为01.主要定义光纤的接口，网线的接口。</li></ul><p><em>Ps：物数网传会表应</em></p><p><img src= "/img/loading.gif" data-src="/photo/MST2-1.jpg" alt=""> </p><h4 id="UDP与TCP的区别"><a href="#UDP与TCP的区别" class="headerlink" title="UDP与TCP的区别"></a>UDP与TCP的区别</h4><p>UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信。<br><strong>UDP无连接，数据报，无可靠性保证，传输效率高</strong><br>TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条TCP连接只能是一对一的。<br><strong>TCP面向连接，流模式，有可靠性保证，传输效率低</strong></p><h4 id="为什么TCP需要三次握手"><a href="#为什么TCP需要三次握手" class="headerlink" title="为什么TCP需要三次握手"></a>为什么TCP需要三次握手</h4><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 </p><p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><h4 id="说一下TCP三次握手"><a href="#说一下TCP三次握手" class="headerlink" title="说一下TCP三次握手"></a>说一下TCP三次握手</h4><ul><li>第一次握手：建立连接时，客户端向服务器<strong>发送SYN包</strong>（seq=x），请求建立连接，等待确认</li><li>第二次握手：服务端收到客户端的SYN包，<strong>回一个ACK包</strong>（ACK=x+1）确认收到，<strong>同时发送一个SYN包</strong>（seq=y）给客户端</li><li>第三次握手：客户端收到SYN+ACK包，<strong>再回一个ACK包</strong>（ACK=y+1）告诉服务端已经收到</li></ul><p>三次握手（SASA）完成，成功建立连接，开始传输数据</p><h4 id="为什么TCP需要四次挥手"><a href="#为什么TCP需要四次挥手" class="headerlink" title="为什么TCP需要四次挥手"></a>为什么TCP需要四次挥手</h4><p>因为TCP为全双工通信，前两次挥手只是关闭了客户端对服务器方向的连接，此时服务器可能还有数据没有传完，后两次挥手才是关闭服务器对客户端方向的连接。</p><h4 id="说一下TCP四次挥手"><a href="#说一下TCP四次挥手" class="headerlink" title="说一下TCP四次挥手"></a>说一下TCP四次挥手</h4><ul><li>客户端发送<strong>FIN包</strong>（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时<strong>客户端不发送数据，但还能接收数据</strong></li><li>服务端收到FIN包，<strong>回一个ACK包</strong>给客户端告诉它已经收到包了，此时还没有断开连接，而是等待剩下的数据传输完毕</li><li>服务端等待数据传输完毕后，向客户端<strong>发送FIN包</strong>，<strong>表明可以断开连接</strong></li><li>客户端收到后，<strong>回一个ACK包</strong>表明确认收到，等待一段时间，确保服务端不再有数据发过来</li></ul><p>四次挥手（FAFA）完成，正式断开连接</p><h4 id="什么是TCP粘包问题？"><a href="#什么是TCP粘包问题？" class="headerlink" title="什么是TCP粘包问题？"></a>什么是TCP粘包问题？</h4><p>TCP粘包就是指发送方发送的诺干包数据到达接收方时粘成了一包，从接受缓冲区来看，后一包数据的头紧接着前一数据的尾，出现粘包的原因是多方面的，可能是来着发送方，也可能来自接收方</p><h4 id="HTTP协议完整过程"><a href="#HTTP协议完整过程" class="headerlink" title="HTTP协议完整过程"></a>HTTP协议完整过程</h4><ol><li>DNS解析</li><li>TCP三次握手</li><li>发起HTTP请求</li><li>服务器响应HTTP请求</li><li>浏览器解析</li><li>浏览器进行页面渲染</li><li>服务器关闭TCP连接</li></ol><h4 id="Get和Post的区别？"><a href="#Get和Post的区别？" class="headerlink" title="Get和Post的区别？"></a>Get和Post的区别？</h4><p>GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>对于POST，浏览器先发送header，服务器响应100，浏览器再发送data，服务器响应200（返回数据）。</p><h4 id="Cookie和seesion的区别？"><a href="#Cookie和seesion的区别？" class="headerlink" title="Cookie和seesion的区别？"></a>Cookie和seesion的区别？</h4><p>Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p>Session代表着服务器和客户端一次会话的过程，Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。</p><h4 id="ip和mac地址的区别"><a href="#ip和mac地址的区别" class="headerlink" title="ip和mac地址的区别"></a>ip和mac地址的区别</h4><ul><li>MAC地址是物理地址，IP地址是逻辑地址。；</li><li>MAC地址具有唯一性，每个硬件出厂时候的MAC地址是固定的；IP地址不具备唯一性。</li><li>工作层次不同物理接口层基于MAC地址转发数据帧，网络层基于IP地址转发报文。二层交换机基于MAC地址表转发数据，路由器基于路由表（IP地址）转发数据。</li><li>长度定义MAC地址是Ethernet网卡上带的地址，长度为48位；IP地址目前主流是32位长。IP地址和MAC地址通过ARP协议联系到一起。(ARP协议)</li></ul><h4 id="说一下ARP协议"><a href="#说一下ARP协议" class="headerlink" title="说一下ARP协议"></a>说一下ARP协议</h4><p>ARP协议是地址解析协议是通过解析IP地址得到MAC地址的，ARP划分在网络层，如在以太网中使用MAC地址进行寻址，以标识不同的主机，那么就需要有一个协议将IP地址转换为MAC地址，由此就出现了ARP协议，该协议是IP地址转换成MAC地址从而能找到主机地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇整理一下面试中经常出现的数据结构已经计算机网络的问题&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;数据结构与算法面试题&quot;&gt;&lt;a href=&quot;#数据结构与算法面试题&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法面试题&quot;&gt;&lt;/a&gt;数据结构与算法面试题&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="笔试面试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++常见的面试题与答案</title>
    <link href="http://yoursite.com/2022/03/29/C-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E7%AD%94%E6%A1%88/"/>
    <id>http://yoursite.com/2022/03/29/C-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E7%AD%94%E6%A1%88/</id>
    <published>2022-03-29T02:47:06.000Z</published>
    <updated>2022-04-03T03:30:19.734Z</updated>
    
    <content type="html"><![CDATA[<p>后悔没早点积累一些面试的经验，导致一下子挂了两个公司的技术面</p><p>亡羊补牢，为时不晚，赶紧整理一波面试中常见的问题</p><hr><h4 id="static和const的区别"><a href="#static和const的区别" class="headerlink" title="static和const的区别"></a>static和const的区别</h4><p>static用于<strong>改变生命周期或作用域</strong>，有以下几种特性：</p><ul><li>static+局部变量 将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完成之后不会被释放，而是继续保存在内存中</li><li>static+全局变量 表示一个变量在<strong>当前文件</strong>的全局可访问</li><li>static+函数 表示一个函数只能在<strong>当前文件</strong>中被访问</li><li>static+类成员变量 表示这个成员为<strong>全类所共有</strong></li><li>static+类成员函数 表示这个<strong>函数为全类所共有</strong>，而且<strong>只能访问静态成员变量</strong></li></ul><p>const用于定义常量，使其在<strong>整个作用域中保持不变</strong></p><ul><li>阻止一个变量被改变</li><li>声明常量指针和指针常量</li><li>const修饰形参，表明它是一个输入参数，在函数内部不能改变其值</li><li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”</li></ul><h4 id="函数指针、指针函数、常量指针、指针常量、常量引用的概念"><a href="#函数指针、指针函数、常量指针、指针常量、常量引用的概念" class="headerlink" title="函数指针、指针函数、常量指针、指针常量、常量引用的概念"></a>函数指针、指针函数、常量指针、指针常量、常量引用的概念</h4><p><strong>函数指针</strong>：指向函数的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x， <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x &lt; y) </span><br><span class="line">       <span class="keyword">return</span> y;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> (*p)(<span class="keyword">int</span>， <span class="keyword">int</span>); <span class="comment">//函数指针的声明</span></span><br><span class="line">   p = cmp;            <span class="comment">//指定该函数指针指向哪个函数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; p(<span class="number">3</span>， <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针函数</strong>：返回指针的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x， <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">if</span>(x &lt; y) </span><br><span class="line">        res = y;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        res = x;</span><br><span class="line"><span class="keyword">return</span> &amp;res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量指针</strong>：指向常量的指针，表示的是<strong>指向的对象是一个常量</strong>，即不允许通过指针修改它的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>， j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//不允许，因为指针指向的对象为一个常量</span></span><br><span class="line">p = &amp;j;  <span class="comment">//允许，此时指针指向了变量j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针常量</strong>：指针本身是一个常量，表示指针<strong>本身的地址是一个常量</strong>，不能将此指针指向其它的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>， j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;i;</span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//允许，修改了指针指向对象的值</span></span><br><span class="line">p = &amp;j;  <span class="comment">//不允许，指针本身是一个常量，不再允许指向其它的变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Ps：<strong>左值右址</strong>，const在星号左边表示值为常量，const在星号右边表示地址为常量</em></p><p><strong>常量引用</strong>：指向常量的引用，引用指向的对象是一个常量，不允许通过引用修改它的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;q = i;</span><br><span class="line">q = <span class="number">10</span>; <span class="comment">//不允许，因为引用指向的对象是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ul><li>指针占内存，引用只是别名，本身不占内存</li><li>引用必须初始化，指针不需要</li><li>引用不能为空，指针可以</li><li>引用一旦初始化不能重新引用，而指针可以改变指向</li><li>sizeof引用得到的所指向对象的大小，而sizeof指针得到的指针本身大小</li><li>指针和引用的自增，自减运算意义不同，引用自加改变变量的内容，指针自加改变了指针指向</li><li>可以有多级指针， 但是没有多级引用</li><li>指针和引用的地址不同，引用的地址即所引用对象的地址，指针的地址就是它自己的地址，是内存中的一块实实在在的另一块内存；</li><li>引用比指针更安全。不会出现像野指针这样的现象。</li></ul><h4 id="什么是野指针，指针越界，悬挂指针？"><a href="#什么是野指针，指针越界，悬挂指针？" class="headerlink" title="什么是野指针，指针越界，悬挂指针？"></a>什么是野指针，指针越界，悬挂指针？</h4><p>野指针指向一个<strong>已经删除的对象</strong>，或者<strong>未申请访问受限内存区域的指针</strong>。悬挂指针又叫野指针。野指针来源如下：</p><ul><li>指针变量未初始化(指向受限内存) </li><li>指针释放之后未置空 </li><li>指针操作超越变量作用域</li></ul><h4 id="宏（-define）和内联函数（inline）的理解以及区别"><a href="#宏（-define）和内联函数（inline）的理解以及区别" class="headerlink" title="宏（#define）和内联函数（inline）的理解以及区别"></a>宏（#define）和内联函数（inline）的理解以及区别</h4><p><strong>宏的缺点：</strong></p><ul><li><strong>宏没有类型检测</strong>，不安全</li><li>宏是在预处理时进行简单文本替换，并不是简单的参数传递</li><li>使代码变长</li><li>宏不能进行调试</li></ul><p><strong>宏的优点：</strong></p><ul><li>加快了代码的运行效率</li><li>让代码变得更加的通用</li></ul><p><strong>内联函数缺点</strong>：</p><ul><li>代码变长，占用更多内存</li></ul><p><strong>内联函数优点</strong>：</p><ul><li>有类型检测，更加的安全</li><li>内联函数是<strong>在程序运行时展开</strong>，而且是<strong>进行的是参数传递</strong></li><li>编译器可以检测定义的内联函数是否满足要求，如果不满足就会当作普通函数调用</li></ul><p><strong>两者不同点：</strong></p><ul><li>内联函数的调用是传参，宏定义只是简单的文本替换</li><li>内联函数可以在程序运行时调用，宏定义是在程序编译进行</li><li>内联函数有类型检测更加的安全，宏定义没有类型检测</li><li>内联函数在运行时可调式，宏定义不可以</li><li>内联函数可以访问类的成员变量，宏不可以</li><li>类中的成员函数是默认的内联函数  </li></ul><h4 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++的智能指针"></a>C++的智能指针</h4><p>详见我专门的一篇智能指针博客：<a href="https://nomore-name.github.io/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" target="_blank" rel="noopener">https://nomore-name.github.io/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</a></p><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ul><li>堆是由程序员自己申请并指明大小，而栈由系统自动分配</li><li>栈区空间连续，效率高，堆区不连续，申请堆区相当于遍历空闲地址空间地址的链表，耗时大</li><li>栈区分配地址从大到小，堆区分配从小到大</li><li>栈区不会产生内存碎片，堆区会产生内碎片</li></ul><h4 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h4><p>多态：同一个对象在不同场景下的多个形态，多态分为静态多态和动态多态</p><p><strong>静态多态</strong>的实现依靠<strong>函数重载</strong>，编译器<strong>在编译期间完成</strong>的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。</p><p><strong>动态多态</strong>的实现依靠<strong>虚函数</strong>和动态绑定机制来实现，意思是在<strong>程序运行时</strong>根据<strong>父类指针指向对象</strong>来决定应该调用哪个子类的虚函数，它的好处在于提高了代码的扩展性。</p><h4 id="为什么构造函数不能为虚函数？"><a href="#为什么构造函数不能为虚函数？" class="headerlink" title="为什么构造函数不能为虚函数？"></a>为什么构造函数不能为虚函数？</h4><p>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。</p><h4 id="解释什么是动态编译，什么是静态编译？"><a href="#解释什么是动态编译，什么是静态编译？" class="headerlink" title="解释什么是动态编译，什么是静态编译？"></a>解释什么是动态编译，什么是静态编译？</h4><p>静态编译就是在编译时，把所有模块都编译进可执行文件里，当启动这个可执行文件时，所有模块都被加载进来。</p><p>动态编译是将应用程序需要的模块都编译成动态链接库，启动程序（初始化）时，这些模块不会被加载，运行时用到哪个模块就调用哪个。</p><h4 id="什么是虚函数与虚表？"><a href="#什么是虚函数与虚表？" class="headerlink" title="什么是虚函数与虚表？"></a>什么是虚函数与虚表？</h4><p>virtual关键字修饰的成员函数，就是虚函数，继承父类的子类可以重写虚函数，动态多态的实现，依靠虚函数表和动态绑定。<br>虚函数表（vtable），由编译器编译生成并存放在某处，程序运行时在<strong>构造对象时会将该地址存放在对象</strong>中。在真正调用的时候会先通过存储在对象中的虚函数表的地址，寻找得到真正需要调用的成员函数的地址，也就是说<strong>虚函数表在编译期就已经确定</strong>，而<strong>虚函数表的地址在运行期时才确定</strong>。虚表会被这个类的所有对象所共享。</p><h4 id="什么是虚指针？"><a href="#什么是虚指针？" class="headerlink" title="什么是虚指针？"></a>什么是虚指针？</h4><p>当一个类中有虚函数时，每一个类的对象都有一个指向虚表开始的虚指针，它发生在对象运行期，当对象创建的时候，虚函数表表指针位于该对象所在内存的最前面，虚表是和类对应的，虚表指针是和对象对应的。</p><h4 id="基类指针指向派生类的对象，会出现什么情况？"><a href="#基类指针指向派生类的对象，会出现什么情况？" class="headerlink" title="基类指针指向派生类的对象，会出现什么情况？"></a>基类指针指向派生类的对象，会出现什么情况？</h4><p>派生类的对象可以被当做基类对象对待，因为<strong>派生类包含基类的所有成员，反之则不成立</strong>。</p><p>因此，将<strong>基类指针指向派生类对象是安全的</strong>。此时这个<strong>基类指针只能调用基类的成员函数</strong>。</p><p>如果试图用基类指针调用派生类才具有的成员函数，编译器会报错。虚函数的出现可以解决这个问题。通过基类指针在派生类对象上调用这个虚函数，实际调用的是这个虚函数的派生类版本。</p><p>如果基类指针指向一个派生类对象，<strong>析构函数不是虚函数的话，基类指针只能调用基类的析构函数</strong>，派生类中的一些内存可能无法释放，造成内存泄露。而把析构函数定义成虚函数，那么基类指针调用的将是派生类的析构函数，然后再调用基类的析构函数。这样就解决了内存泄露的问题。</p><h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别?"></a>new和malloc的区别?</h4><ul><li>new是c++关键字，需要编译器支持，<strong>malloc是库函数</strong>，需要头文件支持</li><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式的指出所需要内存的尺寸</li><li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回的是void*，需要通过强制类型转换将指针转换成我们需要的类型</li><li>new内存分配失败时，会抛出异常，malloc内存分配失败时返回NULL</li></ul><h4 id="delete和delete-的用法，使用不当为什么会造成那些现象？原理是什么？"><a href="#delete和delete-的用法，使用不当为什么会造成那些现象？原理是什么？" class="headerlink" title="delete和delete[]的用法，使用不当为什么会造成那些现象？原理是什么？"></a>delete和delete[]的用法，使用不当为什么会造成那些现象？原理是什么？</h4><p>delete释放new分配的单个对象指针指向的内存，delete[]释放new分配的对象数组指针指向的内存</p><p>如果该对象是某个类的数组话，那么delete只会调用第一个位置对象的析构函数，导致内存泄漏的发生</p><h4 id="什么是内存池？"><a href="#什么是内存池？" class="headerlink" title="什么是内存池？"></a>什么是内存池？</h4><p>代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，其优势在于：比malloc/free进行内存申请/释放的方式快；不会产生或很少产生堆碎片；可避免内存泄漏</p><h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别?"></a>struct和class的区别?</h4><p>struct其实是从C语言中过渡而来，在C语言中只是作为一个存储结构而存在在c++中扩充了很多的功能</p><ul><li>默认的继承访问权。class默认的是private,strcut默认的是public。</li><li>默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li></ul><h4 id="STL是什么？"><a href="#STL是什么？" class="headerlink" title="STL是什么？"></a>STL是什么？</h4><p>是C++的标准库之一，一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。STL包含6大部件：<strong>容器、迭代器、算法、仿函数、适配器和空间配置器。</strong></p><ul><li><p>容器：容纳一组元素的对象。</p></li><li><p>迭代器：提供一种访问容器中每个元素的方法。</p></li><li><p>函数对象：一个行为类似函数的对象，调用它就像调用函数一样。</p></li><li><p>算法：包括查找算法、排序算法等等。</p></li><li><p>适配器：用来修饰容器等，比如queue和stack，底层借助了deque。</p></li><li><p>空间配置器：负责空间配置和管理。</p></li></ul><h4 id="STL容器的简单介绍"><a href="#STL容器的简单介绍" class="headerlink" title="STL容器的简单介绍"></a>STL容器的简单介绍</h4><p>具体见我C++中的STL系列博客</p><h4 id="STL中的迭代器有哪些？"><a href="#STL中的迭代器有哪些？" class="headerlink" title="STL中的迭代器有哪些？"></a>STL中的迭代器有哪些？</h4><p>迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。迭代器按照定义方式分成以下四种：</p><ul><li>正向迭代器，定义方法如下：<code>容器类名::iterator  迭代器名;</code></li><li>常量正向迭代器，定义方法如下：<code>容器类名::const_iterator  迭代器名;</code></li><li>反向迭代器，定义方法如下：<code>容器类名::reverse_iterator  迭代器名;</code></li><li>常量反向迭代器，定义方法如下：<code>容器类名::const_reverse_iterator  迭代器名;</code></li></ul><p>通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素，通过非常量迭代器还能修改其指向的元素。</p><h4 id="STL中的sort使用了什么排序"><a href="#STL中的sort使用了什么排序" class="headerlink" title="STL中的sort使用了什么排序"></a>STL中的sort使用了什么排序</h4><p>快排+插入排序+堆排序，STL的sort算法，数据量大时采用快速排序，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免快排的递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，改用堆排序，因为堆排序是时间复杂度恒定为O(nlogn)，又因为插入排序在面对“几近排序”的序列时，表现更好。</p><h4 id="vector的底层原理"><a href="#vector的底层原理" class="headerlink" title="vector的底层原理"></a>vector的底层原理</h4><p>vector底层是一个<strong>动态数组</strong>，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。当空间不够装下数据时，<strong>会自动申请另一片更大的空间（1.5倍或者2倍</strong>），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间。当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。</p><p><img src= "/img/loading.gif" data-src="/photo/MST1-1.jpg" alt=""></p><h4 id="vector的元素类型可以是引用吗？"><a href="#vector的元素类型可以是引用吗？" class="headerlink" title="vector的元素类型可以是引用吗？"></a>vector的元素类型可以是引用吗？</h4><p>vector的底层实现要求连续的<strong>对象排列</strong>，<strong>引用并非对象，没有实际地址，因此vector的元素类型不能是引用</strong>。</p><h4 id="list的底层原理"><a href="#list的底层原理" class="headerlink" title="list的底层原理"></a>list的底层原理</h4><p>list的底层是一个<strong>双向链表</strong>，以结点为单位存放数据，结点的<strong>地址在内存中不一定连续</strong>，每次插入或删除一个元素，就配置或释放一个元素空间。list不支持随机存取，如果需要大量的插入和删除，而不关心随即存取。</p><h4 id="deque的底层原理"><a href="#deque的底层原理" class="headerlink" title="deque的底层原理"></a>deque的底层原理</h4><p>deque是一个双向开口的连续线性空间（<strong>双端队列</strong>），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段<strong>空间之间并不一定是连续的，可以位于在内存的不同区域</strong>。为了管理这些连续空间，<strong>deque 容器用数组存储着各个连续空间的首地址</strong>。</p><h4 id="priority-queue的底层原理"><a href="#priority-queue的底层原理" class="headerlink" title="priority_queue的底层原理"></a>priority_queue的底层原理</h4><p>priority_queue其底层是<strong>用堆来实现</strong>的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。</p><h4 id="map-、set、multiset、multimap的底层原理（红黑树的特点）"><a href="#map-、set、multiset、multimap的底层原理（红黑树的特点）" class="headerlink" title="map 、set、multiset、multimap的底层原理（红黑树的特点）"></a>map 、set、multiset、multimap的底层原理（红黑树的特点）</h4><p>map 、set、multiset、multimap的底层实现都是<strong>红黑树</strong></p><p>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。除了二叉查找树的基本性质外，红黑树还有以下性质</p><ul><li>每个结点或是红色或是黑色；</li><li>根结点是黑色；</li><li>每个叶结点是黑的；</li><li>如果一个结点是红的，则它的两个儿子均是黑色；</li><li>每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。</li></ul><p>这些约束强制了红黑树的关键性质：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>，因此红黑树增删改查的时间复杂度为<strong>O(logn)</strong></p><h4 id="unordered-map、unordered-set的底层原理"><a href="#unordered-map、unordered-set的底层原理" class="headerlink" title="unordered_map、unordered_set的底层原理"></a>unordered_map、unordered_set的底层原理</h4><p>unordered_map的底层是一个防冗余的<strong>哈希表</strong>（采用除留余数法）。哈希表最大的优点，就是把<strong>数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)</strong>，而代价仅仅是消耗比较多的内存。</p><h4 id="unordered-map-与map的区别？使用场景？"><a href="#unordered-map-与map的区别？使用场景？" class="headerlink" title="unordered_map 与map的区别？使用场景？"></a>unordered_map 与map的区别？使用场景？</h4><p>unordered_map 采用hash表存储，map采用红黑树(RB Tree) 实现。总体来说，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别，而map的查找速度是O(logn)级别，如果考虑效率，特别是在元素达到一定数量级时，考虑考虑unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么采用map更好，特别是当unordered_map 对象特别多时，就更无法控制了，而且unordered_map 的构造速度较慢。</p><h4 id="哈希函数有哪几种常见的方法？"><a href="#哈希函数有哪几种常见的方法？" class="headerlink" title="哈希函数有哪几种常见的方法？"></a>哈希函数有哪几种常见的方法？</h4><ul><li><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。</li><li><strong>数字分析法</strong>：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。</li><li><strong>平方取中法</strong>：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。</li><li><strong>取随机数法</strong>：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。</li></ul><h4 id="哈希冲突有哪几种解决方法？"><a href="#哈希冲突有哪几种解决方法？" class="headerlink" title="哈希冲突有哪几种解决方法？"></a>哈希冲突有哪几种解决方法？</h4><ul><li><strong>开放寻址法</strong>：对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。</li><li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li><li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。（也是STL无序容器所使用的方法）</li></ul><h4 id="右值引用及移动语义"><a href="#右值引用及移动语义" class="headerlink" title="右值引用及移动语义"></a>右值引用及移动语义</h4><p>详见我的另一篇博文：<a href="https://nomore-name.github.io/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" target="_blank" rel="noopener">https://nomore-name.github.io/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</a></p><h4 id="什么是深拷贝？什么是浅拷贝？"><a href="#什么是深拷贝？什么是浅拷贝？" class="headerlink" title="什么是深拷贝？什么是浅拷贝？"></a>什么是深拷贝？什么是浅拷贝？</h4><ul><li>深拷贝是拷贝时先开辟与源对象大小一样的空间，然后将源对象的内容拷贝到目标对象去，这样两个指针就指向了不同的位置，调用析构也不会释放同一块内存。</li><li>浅拷贝又称值拷贝，本质上源对象和目标对象共同同一份实体，地址是相同的。</li></ul><h4 id="C-中父类指针指向子类对象是如何实现的？"><a href="#C-中父类指针指向子类对象是如何实现的？" class="headerlink" title="C++中父类指针指向子类对象是如何实现的？"></a>C++中父类指针指向子类对象是如何实现的？</h4><p>当定义一个指向子类实例的父类指针的时候，<strong>内存中实例化了子类</strong>，由于子类继承了父类，因此内存中的<strong>子类里包含父类的所有成员</strong>。但由于声明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员。</p><p>在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数。</p><h4 id="C-11引入了哪些新特性？"><a href="#C-11引入了哪些新特性？" class="headerlink" title="C++11引入了哪些新特性？"></a>C++11引入了哪些新特性？</h4><ul><li>统一的列表初始化</li><li>类成员变量的默认初始化</li><li>auto关键字</li><li>decltype求表达式的类型</li><li>智能指针</li><li>空指针nullptr</li><li>右值引用与转移语义</li><li>STL的无序容器</li><li>Lambda表达式</li></ul><h4 id="简述一下Lambda表达式"><a href="#简述一下Lambda表达式" class="headerlink" title="简述一下Lambda表达式"></a>简述一下Lambda表达式</h4><p>lambda 表达式是一个匿名函数，用于定义并创建匿名的函数对象，以简化编程工作。其定义格式如下：</p><p><code>[外部变量访问方式说明符] (参数表) -&gt; 返回值类型</code><br><code>{</code><br>       <code>语句块</code><br><code>}</code></p><p>外部变量访问方式说明符如下：</p><ul><li><strong>空</strong> 没有使用任何函数对象参数。</li><li><strong>=</strong> 函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是<strong>值传递方式</strong>（相当于编译器自动为我们按值传递了所有局部变量）。</li><li><strong>&amp;</strong> 函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是<strong>引用传递方式</strong>（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li><p><strong>this</strong> 函数体内可以使用lambda所在类中的成员变量。</p></li><li><p><strong>a</strong>   将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</p></li><li><strong>&amp;a</strong>   将a按引用进行传递。</li><li><strong>a, &amp;b</strong>    将a按值进行传递，b按引用进行传递。</li><li><strong>=，&amp;a, &amp;b</strong>    除a和b按引用进行传递外，其他参数都按值进行传递。</li><li><strong>&amp;, a, b</strong>    除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul><p>下面是一句合法的lambda表达式：</p><p><code>[=] (int x, int y) -&gt; bool {return x &lt; y ;}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;后悔没早点积累一些面试的经验，导致一下子挂了两个公司的技术面&lt;/p&gt;
&lt;p&gt;亡羊补牢，为时不晚，赶紧整理一波面试中常见的问题&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;static和const的区别&quot;&gt;&lt;a href=&quot;#static和const的区别&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="笔试面试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C++中的移动语义</title>
    <link href="http://yoursite.com/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <id>http://yoursite.com/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</id>
    <published>2022-03-26T03:09:02.000Z</published>
    <updated>2022-03-28T08:18:14.714Z</updated>
    
    <content type="html"><![CDATA[<p>右值引用和移动语义作为C++11新引入的特性，也是很多面试必问的一个问题，那就跟随这篇博客一起来看一下吧</p><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>左值（lvalue）、右值（rvalue）这样的概念想必大家都有听过。一个最为典型的判别方法就是，在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。但是这种分辨方法其实是很笼统的，因为左值也可以出现在等号的右边。所以C++中还有一个被广泛认同的说法，那就是<strong>可以取地址的就是左值</strong>，反之，不能取地址的就是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a = a + b;</span><br></pre></td></tr></table></figure><p>比如在这个加法赋值表达式中，a就是一个左值，而b + c则是一个右值，&amp;a是允许的操作，但&amp;(b + c)这样的操作则不会通过编译。因此a是一个左值，(b + c)是一个右值。</p><p>相对于左值，<strong>右值表示字面常量、表达式、函数的非引用返回值等</strong>。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>在C++11之前，我们只能对左值建立引用，或者通过常量引用来绑定右值，C++11引入了右值引用，使我们可以绑定右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 左值引用绑定到右值，编译失败, err</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// 非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// 常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = d; <span class="comment">// 常量左值引用绑定到常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">2</span>; <span class="comment">// 常量左值引用绑定到右值，编程通过, ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*右值引用*/</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</span><br></pre></td></tr></table></figure><p><code>const typename &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>那么C++11引入右值引用是要做什么呢，其目的是为了实现移动语义。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。</p><p>在没有移动语义之前，C++中的类有<strong>拷贝构造函数</strong>和<strong>赋值构造函数</strong>，程序会经常生成临时对象，大量的临时对象的创建于析构会严重影响程序性能，有了移动语义，我们可以定义<strong>移动构造函数</strong>和<strong>移动赋值构造函数</strong>，将原有的对象移动原对象到新对象上，达到节约资源的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyString(<span class="keyword">const</span> <span class="keyword">char</span> *tmp = <span class="string">"abc"</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"普通构造函数 str = "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString(<span class="keyword">const</span> MyString &amp;tmp)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">len = tmp.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数 tmp.str = "</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> MyString &amp;tmp)<span class="comment">//赋值构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[]str;<span class="comment">//先释放原来的内存</span></span><br><span class="line"></span><br><span class="line">len = tmp.len;<span class="comment">//重新申请内容</span></span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"赋值构造函数 tmp.str = "</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~MyString()<span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数: "</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"已操作delete, str =  "</span> &lt;&lt; str;</span><br><span class="line"><span class="keyword">delete</span>[]str;</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未进行真正析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">"mike"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms = func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如在上面的程序里，C++要原本做各做三次的构造与析构函数（在vs2017里编译器会优化到各两次），十分影响性能</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-1.jpg" alt=""> </p><p>有了移动语义后，我们可以这么定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(MyString &amp;&amp; t)<span class="comment">//移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">    len = t.len;</span><br><span class="line"></span><br><span class="line">    t.str = <span class="literal">NULL</span>;<span class="comment">//原来指针置空，防止真析构</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/photo/CMV1-2.jpg" alt=""> </p><p>定义移动构造函数后，编译器就会自动帮我们调用移动构造函数，要注意移动构造函数中一定要<strong>把原对象的地址设为空</strong>。因为我们将新对象指向了原对象的地址，如果不置为空的话，就会导致析构函数将原对象地址析构掉，导致程序出错。</p><p>移动赋值构造函数也是同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyString &amp;<span class="keyword">operator</span>= (MyString &amp;&amp;tmp)<span class="comment">//移动赋值构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">delete</span>[]str;<span class="comment">//先释放原来的内存</span></span><br><span class="line"></span><br><span class="line">    len = tmp.len;</span><br><span class="line">    str = tmp.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line"></span><br><span class="line">    tmp.str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移动赋值构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms1("Kang"),ms2;</span><br><span class="line">ms2 = ms1;</span><br><span class="line">ms2 = func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/photo/CMV1-3.jpg" alt=""> </p><h3 id="move的使用"><a href="#move的使用" class="headerlink" title="move的使用"></a>move的使用</h3><p>move是C++标准库中的一个函数，它的作用就是将一个左值转换为右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms1("Kang"),ms2;</span><br><span class="line">ms2 = <span class="built_in">move</span>(ms1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-4.jpg" alt=""> </p><h3 id="forward的使用"><a href="#forward的使用" class="headerlink" title="forward的使用"></a>forward的使用</h3><p>forward被称为完美转发，它的作用是保持原来的参数属性不变。啥意思呢？如果我们调用一个函数传入一个右值，并在该函数里调用其它函数并同样传入该值，此时该值可能就会变成左值。通俗的讲就是，如果原来的值是左值，经forward处理后该值还是左值；如果原来的值是右值，经forward处理后它还是右值。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"左值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"右值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printType(t);</span><br><span class="line">printType(forward&lt;T&gt;(t));</span><br><span class="line">printType(<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">1</span>;</span><br><span class="line">useForward(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">useForward(lv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-5.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，感谢您的观看~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;右值引用和移动语义作为C++11新引入的特性，也是很多面试必问的一个问题，那就跟随这篇博客一起来看一下吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;左值与右值&quot;&gt;&lt;a href=&quot;#左值与右值&quot; class=&quot;headerlink&quot; title=&quot;左值与右值&quot;&gt;&lt;/a&gt;左值与右值&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="移动语义" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    
      <category term="左值右值" scheme="http://yoursite.com/tags/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"/>
    
      <category term="完美转发" scheme="http://yoursite.com/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++中的智能指针</title>
    <link href="http://yoursite.com/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-03-25T07:48:31.000Z</published>
    <updated>2022-03-29T07:10:05.742Z</updated>
    
    <content type="html"><![CDATA[<p>智能指针可以说是面试中逃不掉的一个必问问题，但一直对这一块了解的不够彻底，就做个笔记记录一下吧</p><hr><h3 id="C-为什么要有智能指针"><a href="#C-为什么要有智能指针" class="headerlink" title="C++为什么要有智能指针"></a>C++为什么要有智能指针</h3><p> C++支持动态内存分配，也就是我们平常用的new和malloc，但是在使用过程中，我们往往会忘记在结束时调用delete和free进行内存释放，这就导致了内存泄漏这样的事情发生。因此C++引入了智能指针，它可以负责自动释放所指向的对象，可以很好地避免忘记释放内存而导致内存泄漏问题出现。</p><p>C++ 智能指针底层是采用<strong>引用计数</strong>的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值-1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><p>当然，智能指针是C++中的一个难点，这里推荐一篇博客，讲述了C++智能指针的演化历史，有兴趣可以前去看看：<a href="http://avdancedu.com/9683d88/" target="_blank" rel="noopener">http://avdancedu.com/9683d88/</a></p><p>下面简单介绍C++11中引入的三种智能指针的使用</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr持有对对象的独有权，同一时刻只能有一个unique_ptr指向给定对像，unique_ptr中没有赋值构造函数和拷贝构造函数，只有移动构造函数，目的就是为了有一个对象拥有unique_ptr</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p1 = <span class="number">666</span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u1</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; u2 = u1;//无法直接赋值</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; u2(u1);//无法直接拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u2</span><span class="params">(<span class="built_in">move</span>(u1))</span></span>;<span class="comment">//可进行移动构造，原u1指向的地址会被置空</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *u1 &lt;&lt; endl;//无法读取</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *u2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-1.jpg" alt=""> </p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr允许多个该智能指针共享“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* p1 = <span class="keyword">new</span> Entity;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u1</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Entity&gt; u2 = u1;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u3</span><span class="params">(u1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u4</span><span class="params">(<span class="built_in">move</span>(u1))</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u3.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u4.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-2.jpg" alt=""> </p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作（因为shared_ptr在实现互指的时候会出现内存泄漏的情况），它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。weak_ptr没有重载 * 和 -&gt; ，但可以使用lock获得一个可用的shared_ptr对象</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(weak_ptr&lt;<span class="keyword">int</span>&gt; &amp;wp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = wp.lock(); <span class="comment">// 转换为shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Num is "</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">666</span>))</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp1; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">check(wp);  </span><br><span class="line"></span><br><span class="line">sp1.reset();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">check(wp); </span><br><span class="line"></span><br><span class="line">sp2.reset();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">check(wp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-3.jpg" alt=""> </p><h3 id="手撸shared-ptr"><a href="#手撸shared-ptr" class="headerlink" title="手撸shared_ptr"></a>手撸shared_ptr</h3><p>根据shared_ptr的特性编写的一个简单智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareCount</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ShareCount() :count(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">reduceCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> --count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">long</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smart_ptr</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* ptr;</span><br><span class="line">ShareCount *scount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T* ptr=<span class="literal">nullptr</span>)</span><span class="comment">//explicit用于禁式隐形类型转换和拷贝初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ptr = ptr;</span><br><span class="line">scount = <span class="keyword">new</span> ShareCount();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"普通构造函数"</span> &lt;&lt; <span class="keyword">this</span>-&gt;ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~smart_ptr() </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr &amp;&amp; !scount-&gt;reduceCount())<span class="comment">//ptr不为空且count-1后引用数量为0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"><span class="keyword">delete</span> scount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smart_ptr(<span class="keyword">const</span> smart_ptr&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">ptr = other.ptr;</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line">other.scount-&gt;addCount();</span><br><span class="line">scount = other.scount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smart_ptr(smart_ptr&amp;&amp; other)<span class="comment">//移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">ptr = other.ptr;</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line">scount = other.scount;</span><br><span class="line">other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"移动构造函数"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(smart_ptr&amp; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">swap(ptr, sp.ptr);</span><br><span class="line">swap(scount, sp.scount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr sp) </span><br><span class="line">&#123;</span><br><span class="line">sp.change(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">useCount</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line"><span class="keyword">return</span> scount-&gt;getCount();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~Entity() </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Entity Delete"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">smart_ptr&lt;Entity&gt; <span class="title">spe</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line"><span class="function">smart_ptr&lt;Entity&gt; <span class="title">spe2</span><span class="params">(spe)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; spe.useCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; spe2.useCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-4.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，智能指针其实是一个蛮不好理解的知识点，我这里也只是非常简单的讲了一些，具体大家还是去网上查阅大牛的资料才能有更深刻的理解~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;智能指针可以说是面试中逃不掉的一个必问问题，但一直对这一块了解的不够彻底，就做个笔记记录一下吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;C-为什么要有智能指针&quot;&gt;&lt;a href=&quot;#C-为什么要有智能指针&quot; class=&quot;headerlink&quot; title=&quot;C++为什么要有智能
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="智能指针" scheme="http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换运算符</title>
    <link href="http://yoursite.com/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-03-21T04:28:56.000Z</published>
    <updated>2022-03-21T08:04:22.428Z</updated>
    
    <content type="html"><![CDATA[<p>本章记录一下C++中四种类型转换</p><hr><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>使用C风格的类型转换可以把想要的任何东西转换成我们需要的类型，但是这种类型转换太过松散，对于这种松散的情况，C++提供了更严格的类型转换，可以提供更好的控制转换过程，并添加4个类型转换运算符，使转换过程更规范:</p><ul><li>static_cast</li><li>dynamic_cast</li><li>const_cast</li><li>reinterpret_cast</li></ul><p>以下进行具体的介绍</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>可用于类层次结构中<strong>基类和派生类之间指针或引用的转换</strong>和<strong>基本数据类型之间的转换</strong></p><p>其中进行上行转换 （把派生类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类指针或引用转换成派生类表示)时，由于没有动态类型检查，所以是不安全的</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span><span class="keyword">public</span> Person&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Person *p1=<span class="literal">nullptr</span>,*p2 = <span class="literal">nullptr</span>;</span><br><span class="line">Man *m1 = <span class="literal">nullptr</span>,*m2 = <span class="literal">nullptr</span>;</span><br><span class="line">p1 = <span class="keyword">static_cast</span>&lt;Person*&gt;(m1);<span class="comment">//子转父，安全，引用同理</span></span><br><span class="line">m2 = <span class="keyword">static_cast</span>&lt;Man*&gt;(p2);<span class="comment">//父转子，不安全 ，引用同理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CCT1-1.jpg" alt=""> </p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>dynamic_cast主要用于类层次间的上行转换和下行转换，其不支持数据类型转换，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span><span class="keyword">public</span> Person&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Wow~"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//int a = dynamic_cast&lt;int&gt;(pi);//报错，动态多态不支持类型转换</span></span><br><span class="line">    </span><br><span class="line">    Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">Man *m = <span class="keyword">new</span> Man;</span><br><span class="line">Animal *a = <span class="keyword">new</span> Animal;</span><br><span class="line">Tiger *t = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">dynamic_cast</span>&lt;Person*&gt;(m);<span class="comment">//子转父，编译正常</span></span><br><span class="line"><span class="comment">//m = dynamic_cast&lt;Man*&gt;(p);//报错，动态转换不支持没有多态的父转子</span></span><br><span class="line">t = <span class="keyword">dynamic_cast</span>&lt;Tiger*&gt;(a);<span class="comment">//包含多态的父转子，编译正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast主要是用来去掉<strong>引用和指针</strong>的const属性，当然也可以加上const属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *np = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(p);<span class="comment">//常量指针转非常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pp = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(np);<span class="comment">//非常量指针转常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cnum = num;</span><br><span class="line"><span class="keyword">int</span> &amp;inum = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(cnum);<span class="comment">//引用同理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast是四种强制转换中功能最为强大的，它可以暴力完成<strong>两个完全无关类型的指针之间或指针和数</strong>之间的互转，比如用char类型指针指向double值。它对原始对象的位模式提供较低层次上的重新解释（即reinterpret），完全复制二进制比特位到目标对象，转换后的值与原始对象无关但比特位一致，前后无精度损失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> *b = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(a);<span class="comment">//double*转int*，不会报错</span></span><br><span class="line"></span><br><span class="line">Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">Man *m = <span class="keyword">new</span> Man;</span><br><span class="line">Tiger *t = <span class="literal">nullptr</span>;</span><br><span class="line">m = <span class="keyword">reinterpret_cast</span>&lt;Man*&gt;(p);</span><br><span class="line">t = <span class="keyword">reinterpret_cast</span>&lt;Tiger*&gt;(m);<span class="comment">//两种不同类指针的转换，也不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是C++的四种类型转换简单介绍，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章记录一下C++中四种类型转换&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;类型转换运算符&quot;&gt;&lt;a href=&quot;#类型转换运算符&quot; class=&quot;headerlink&quot; title=&quot;类型转换运算符&quot;&gt;&lt;/a&gt;类型转换运算符&lt;/h3&gt;&lt;p&gt;使用C风格的类型转换可以把想要的任何东西转
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="类型转换" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL:set、map、stack、queue的基本使用</title>
    <link href="http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-10T08:07:30.000Z</published>
    <updated>2022-03-22T08:32:37.532Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器</p><hr><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>关联式容器在存储元素值时会<strong>为各元素额外再配备一个值，又称为“键”</strong>，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><p>关联式容器<strong>可以快速查找、读取或者删除所存储的元素</strong>，同时该类型容器<strong>插入元素的效率也比序列式容器高</strong>。</p><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，<strong>而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</strong>。</p><ul><li><strong>map</strong>    定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根<strong>据各元素键的大小，默认进行升序排序</strong>（调用 std::less<T>）</li><li><strong>multimap</strong>    定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复</li><li><strong>set</strong>    定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个<strong>元素的键的大小进行升序排序</strong>（调用 std::less<T>）</li><li><strong>multiset</strong>    定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）</li></ul><h3 id="pair对组"><a href="#pair对组" class="headerlink" title="pair对组"></a>pair对组</h3><p>在正式介绍关联式容器之前，先介绍一下对组pair，对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问</p><p>类模板：template <class T1, class T2> struct pair. </p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; pair1(string("year"), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.first&lt;&lt; <span class="built_in">endl</span>;                 <span class="comment">//访问pair第一个值 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//访问pair第二个值 </span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = make_pair(<span class="string">"name"</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3 = pair2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-5.jpg" alt=""> </p><h3 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a><strong>set/multiset容器</strong></h3><p>set的特性是：所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值，所以我们无法通过set的迭代器改变set元素的值吗，set不允许两个元素有相同的键值。</p><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。<strong>set和multiset的底层实现是红黑树</strong>，红黑树为平衡二叉树的一种。  </p><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><ul><li>set<T> st;                <strong>//set默认构造函数</strong></li><li>mulitset<T> mst;                 <strong>//multiset默认构造函数</strong></li><li>set(const set &amp;st);                <strong>//拷贝构造函数</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line">s.insert(<span class="number">1</span>);</span><br><span class="line">ms.insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-1.jpg" alt=""> </p><h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><ul><li>set&amp; operator=(const set &amp;st);                <strong>//重载等号操作符</strong> </li><li>swap(st);                <strong>//交换两个集合容器</strong></li></ul><h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><ul><li>size();                <strong>//返回容器中元素的数目</strong> </li><li>empty();                <strong>//判断容器是否为空</strong></li></ul><h4 id="set数据操作"><a href="#set数据操作" class="headerlink" title="set数据操作"></a>set数据操作</h4><ul><li>insert(elem);                <strong>//在容器中插入元素</strong></li><li>clear();                <strong>//清除所有元素</strong>  </li><li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong></li><li>erase(beg, end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li><li>erase(elem);                <strong>//删除容器中值为elem的元素</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line">s.insert(<span class="number">1</span>);</span><br><span class="line">ms.insert(<span class="number">1</span>);</span><br><span class="line">s.erase(++s.<span class="built_in">begin</span>(), --s.<span class="built_in">end</span>());</span><br><span class="line">ms.erase(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-2.jpg" alt=""> </p><h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><ul><li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()</strong></li><li>count(key);                <strong>//查找键key的元素个数</strong>  </li><li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li><li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li><li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> st1 = s.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">auto</span> st2 = s.lower_bound(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span> st3 = s.upper_bound(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">auto</span> st4 = s.equal_range(<span class="number">6</span>);<span class="comment">//pair类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st3 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st4.first &lt;&lt; *st4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-3.jpg" alt=""> </p><h4 id="set排序方式的修改"><a href="#set排序方式的修改" class="headerlink" title="set排序方式的修改"></a>set排序方式的修改</h4><p>我们可以通过结构体重载（）来修改set原有的排序方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mycmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;<span class="comment">//从大到小进行排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, Mycmp&gt; s2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">s2.insert(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> st = s2.<span class="built_in">begin</span>(); st != s2.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-4.jpg" alt=""> </p><h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。  </p><p>Multimap和map的操作类似，唯一区别multimap键值可重复。 </p><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><ul><li>map<T1, T2> mapTT;                <strong>//map默认构造函数</strong></li><li>map(const map &amp;mp);                <strong>//拷贝构造函数</strong></li></ul><h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><ul><li>map&amp; operator=(const map &amp;mp);                <strong>//重载等号操作符</strong> </li><li>swap(mp);                <strong>//交换两个集合容器</strong></li></ul><h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><ul><li>size();        <strong>//返回容器中元素的数目</strong> </li><li>empty();        <strong>//判断容器是否为空</strong></li></ul><h4 id="map数据操作"><a href="#map数据操作" class="headerlink" title="map数据操作"></a>map数据操作</h4><ul><li>insert();                 <strong>//往容器插入元素，返回pair<iterator,bool></strong> </li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str[<span class="number">4</span>] = &#123; <span class="string">"kk"</span>,<span class="string">"pp"</span>,<span class="string">"zz"</span>,<span class="string">"oo"</span> &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; pr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pr[i] = make_pair(i, str[i]);</span><br><span class="line">mp.insert(pr[i]);</span><br><span class="line">&#125;</span><br><span class="line">mp.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"dd"</span>));</span><br><span class="line">mp.insert(make_pair(<span class="number">5</span>, <span class="string">"vv"</span>));</span><br><span class="line">mp[<span class="number">6</span>] = <span class="string">"nn"</span>;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="string">"mm"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> mt = mp.<span class="built_in">begin</span>(); mt != mp.<span class="built_in">end</span>(); ++mt)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mt-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mt-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-6.jpg" alt=""> </p><h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><ul><li>clear();                <strong>//删除所有元素</strong>  </li><li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong> </li><li>erase(beg,end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li><li>erase(keyElem);                <strong>//删除容器中key为keyElem的对组</strong></li></ul><h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><ul><li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end()</strong></li><li>count(keyElem);                <strong>//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1</strong></li><li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li><li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li><li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li></ul><p>由于这些操作和set大同小异，故在此不提供例子</p><h4 id="常见的map问题"><a href="#常见的map问题" class="headerlink" title="常见的map问题"></a>常见的map问题</h4><p><strong>1.set map的区别与联系</strong></p><p> 联系：1.Map,Set属于标准关联容器，底层数据结构使用红黑树</p><p>2.时间复杂度均为红黑树的时间复杂度，插入删除查找近似为O(logN)</p><p>区别：</p><p><strong>1.适用对象</strong><br>map适合存储一个数据字典，并要求方便地根据key找value<br>set适合查找一个元素是否在某集合内存中</p><p><strong>2.存储方式</strong><br>Set节点只含有Key，Key不重复.<br>Map节点有一个Key和Value两个元素,Key不重复,Value可以不重复。</p><p> <strong>3.元素改变</strong><br>set不能直接改变元素值。因为这样会打乱原有的顺序。改变元素值的方法是：先删除旧元素，再插入新元素。存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。<br>map可以通过key改变value的值</p><p><strong>2.map list 的使用场景与优势对比</strong></p><p>Map适用：是为了更快的从关键字查找到相关的对象。 </p><p>与使用list这样的线性表容器相比：一可以简化查找的算法，二可以使任意的关键字做索引，并与目标对象配对，优化查找算法。</p><p>在C++的STL中map是使用树来做查找算法，这种算法差不多相当与list线性容器的折半查找的效率一样，都是O (log2N)，而list就没有map这样易定制和操作了。</p><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。</p><ul><li>stack<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入后出</strong>（Last-In-First-Out，LIFO）的压入栈</li><li>queue<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入先出</strong>（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器</li><li>priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而<strong>保证最大元素总在队列最前面</strong>的队列</li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack就是数据结构中的栈，关于栈的详细介绍可看我《数据结构与算法:栈I/II/III/IV》四篇博客，这里不多加赘述，以下是常见操作</p><ul><li>stack<T> stkT;                <strong>//stack采用模板类实现， stack对象的默认构造形式</strong> </li><li>stack(const stack &amp;stk);                <strong>//拷贝构造函数</strong></li><li>stack&amp; operator=(const stack &amp;stk);                <strong>//重载等号操作符</strong></li><li>push(elem);                <strong>//向栈顶添加元素</strong> </li><li>pop();                <strong>//从栈顶移除第一个元素</strong> </li><li>top();                <strong>//返回栈顶元素</strong></li><li>empty();                <strong>//判断堆栈是否为空</strong> </li><li>size();                <strong>//返回堆栈的大小</strong></li></ul><p>都很简单，也不提供例子了，注意的是，stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素才有<br>机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue就是数据结构中的队列，关于队列的详细介绍可看我《数据结构与算法:队列I/II》两篇博客，这里不多加赘述，以下是常见操作</p><ul><li>queue<T> queT;                <strong>//queue采用模板类实现，queue对象的默认构造形式</strong></li><li>queue(const queue &amp;que);                <strong>//拷贝构造函数</strong></li><li>push(elem);                <strong>//往队尾添加元素</strong> </li><li>pop();                <strong>//从队头移除第一个元素</strong> </li><li>back();                <strong>//返回最后一个元素</strong> </li><li>front();                <strong>//返回第一个元素</strong></li><li>queue&amp; operator=(const queue &amp;que);                <strong>//重载等号操作符</strong></li><li>empty();                <strong>//判断队列是否为空</strong> </li><li>size();                <strong>//返回队列的大小</strong></li></ul><p>都很简单，也不提供例子了，同样的，队列也是不提供迭代器的</p><p>而priority_queue的基础用法和queue一样，在《记录备战CSP中刷到一些有意思的题目I》中的第一题就用到了priority_queue，并对其排序方法进行了重写，想了解的可以去看看</p><hr><p>以上就是我们的C++中STL的基本常用容器介绍啦，在C++11后还引入了无序容器（哈希容器），后续有机会再更新关于这系列的博客~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;关联式容器&quot;&gt;&lt;a href=&quot;#关联式容器&quot; class=&quot;headerlink&quot; title=&quot;关联式容器&quot;&gt;&lt;/a&gt;关联式容器&lt;/h2&gt;&lt;p&gt;关联式容器在存储
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="queue" scheme="http://yoursite.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL:vector、list、deque的基本使用</title>
    <link href="http://yoursite.com/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-09T08:26:30.000Z</published>
    <updated>2022-03-22T07:57:12.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近在准备春招的，正好复习到STL的使用，才想起还有这么一个博客的坑没填，就趁这次把它补充完吧~</p><hr><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>所谓序列容器，即以线性排列(类似普通数组的存储方式）来存储某一指定类型(例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p><p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p><ul><li><strong>array<T,N>(数组容器）：</strong>表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li><strong>vector<T>(向量容器）：</strong>用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高(时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差(时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li><strong>deque<T>(双端队列容器）：</strong>和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li><strong>list<T>(链表容器）：</strong>是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素(时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li><strong>forward_list<T>(正向链表容器）：</strong>和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><p><em>其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到下一篇博客中。</em></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector其实在《From C to C++ III:动态内存分配及向量》一篇博客中就有提及，这次就进行一个完整的整理</p><h4 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h4><p>vector有四种构造函数，分别是</p><ul><li>vector<T> v;         <strong>//采用模板实现类实现，默认构造函数</strong>  </li><li>vector(v.begin(), v.end());        <strong>//将v[begin(), end()]区间中的元素拷贝给本身。</strong> </li><li>vector(n, elem);        <strong>//构造函数将n个elem拷贝给本身。</strong> </li><li>vector(const vector &amp;vec);        <strong>//拷贝构造函数。</strong> </li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v2.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v4.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-1.jpg" alt=""> </p><h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><ul><li>assign(beg, end];        <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong></li><li>assign(n, elem);        <strong>//将n个elem拷贝赋值给本身。 </strong></li><li>vector&amp;operator<strong>=(</strong>const vector &amp;vec);        <strong>//重载等号操作符</strong> </li><li>swap(vec);        <strong>// 将vec与本身的元素互换。</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ib = v2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ie = v2.<span class="built_in">end</span>();</span><br><span class="line">v2.assign(ib, ie);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v2.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.assign(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v4.swap(v3);<span class="comment">//可用于vector收缩内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v4.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-2.jpg" alt=""> </p><h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><ul><li>size();    <strong>//返回容器中元素的个数</strong> </li><li>empty();    <strong>//判断容器是否为空</strong> </li><li>resize(int num);    <strong>//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</strong></li><li>resize(int num, elem);    <strong>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除</strong></li><li>capacity();    <strong>//容器的容量</strong></li><li>reserve(int len);    <strong>//容器预留len个元素长度，预留位置不初始化，元素不可访问</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.resize(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v3.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">v3.resize(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v3.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.reserve(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-3.jpg" alt=""> </p><h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><ul><li>at(idx);         <strong>//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常</strong></li><li>operator[];        <strong>//返回索引idx所指的数据，越界时，运行直接报错</strong> </li><li>front();        <strong>//返回容器中第一个数据元素</strong> </li><li>back();        <strong>//返回容器中最后一个数据元素</strong></li></ul><p>这个比较简单和常用，就不给例子了</p><h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><ul><li>insert(const_iterator pos, int count,ele);        <strong>//迭代器指向位置pos插入count个元素ele</strong></li><li>push_back(ele);         <strong>//尾部插入元素ele</strong> </li><li>pop_back();        <strong>//删除最后一个元素</strong>  </li><li>erase(const_iterator start, const_iterator end];        <strong>//删除迭代器从start到end之间的元素</strong> </li><li>erase(const_iterator pos);        <strong>//删除迭代器指向的元素</strong> </li><li>clear();        <strong>//删除容器中所有元素</strong></li></ul><p>这个也比较简单和常用，就不给例子了</p><h4 id="vector的常见问题"><a href="#vector的常见问题" class="headerlink" title="vector的常见问题"></a>vector的常见问题</h4><p><strong>1.vector的resize和reserve操作的区别</strong></p><p>resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。  </p><p>reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。</p><p><strong>2.当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？</strong></p><p>vector内存用完了，会以当前size大小重新申请1.5倍或2倍的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。<br>一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap。</p><p><strong>3.vector中的size和capacity的区别</strong></p><p>size表示当前vector中有多少个元素，而capacity函数则表示它已经分配的内存中可以容纳多少元素。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间</p><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p>list<T> list;        <strong>//list采用采用模板类实现,对象的默认构造形式</strong></p><p>list(beg,end];        <strong>//构造函数将[beg, end]区间中的元素拷贝给本身</strong></p><p>list(n,elem);        <strong>//构造函数将n个elem拷贝给本身</strong></p><p>list(const list &amp;lst);        <strong>//拷贝构造函数</strong></p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l2.<span class="built_in">begin</span>(); it != l2.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-4.jpg" alt=""> </p><h4 id="list插入删除"><a href="#list插入删除" class="headerlink" title="list插入删除"></a>list插入删除</h4><ul><li>push_back(elem);                <strong>//在容器尾部加入一个元素</strong></li><li>pop_back();                <strong>//删除容器中最后一个元素</strong> </li><li>push_front(elem);                <strong>//在容器开头插入一个元素</strong> </li><li>pop_front();                <strong>//从容器开头移除第一个元素</strong> </li><li>insert(pos,elem);                <strong>//在pos位置插elem元素的拷贝，返回新数据的位置</strong></li><li>insert(pos,n,elem);                <strong>//在pos位置插入n个elem数据，无返回值</strong></li><li>insert(pos,beg,end];                <strong>//在pos位置插入[beg,end]区间的数据，无返回值</strong></li><li>clear();                <strong>//移除容器的所有数据</strong> </li><li>erase(beg,end];                <strong>//删除[beg,end]区间的数据，返回下一个数据的位置</strong></li><li>erase(pos);                <strong>//删除pos位置的数据，返回下一个数据的位置</strong></li><li>remove(elem);                <strong>//删除容器中所有与elem值匹配的元素</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line">l2.push_back(<span class="number">5</span>);</span><br><span class="line">l2.push_back(<span class="number">6</span>);</span><br><span class="line">l2.pop_back();</span><br><span class="line">l2.push_front(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l2.<span class="built_in">begin</span>(); it != l2.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator ie=l3.insert(l3.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ie &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l3.insert(++ie, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">l4.<span class="built_in">remove</span>(<span class="number">4</span>);</span><br><span class="line">l4.erase(l4.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-5.jpg" alt=""> </p><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><ul><li><p>size();                <strong>//返回容器中元素的个数</strong> </p></li><li><p>empty();                <strong>//判断容器是否为空</strong> </p></li><li><p>resize(num);                <strong>//重新指定容器的长度为num， 若容器变长，则以默认值填充新位置。  如果容器变短，则末尾超出容器长度的元素被删除</strong></p></li><li><p>resize(num, elem);                <strong>//重新指定容器的长度为num， 若容器变长，则以elem值填充新位置。  如果容器变短，则末尾超出容器长度的元素被删除</strong></p></li></ul><p>这个比较简单和常用，就不给例子了</p><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><ul><li><p>assign(beg, end];                <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong></p></li><li><p>assign(n, elem);                <strong>//将n个elem拷贝赋值给本身</strong> </p></li><li><p>list&amp; operator=(const list &amp;lst);                <strong>//重载等号操作符</strong> </p></li><li><p>swap(lst);                <strong>//将lst与本身的元素互换</strong></p></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line">l3.assign(arr, arr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l4.assign(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l1.swap(l2);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l1.<span class="built_in">begin</span>(); it != l1.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-6.jpg" alt=""> </p><h4 id="list数据操作"><a href="#list数据操作" class="headerlink" title="list数据操作"></a>list数据操作</h4><ul><li><p>front();                <strong>//返回第一个元素</strong></p></li><li><p>back();                <strong>//返回最后一个元素</strong></p></li><li><p>reverse();                <strong>//反转链表</strong></p></li><li><p>sort();                 <strong>//list排序</strong>  </p></li></ul><p>这个也比较简单和常用，就不给例子了</p><h4 id="vector-list的区别与联系"><a href="#vector-list的区别与联系" class="headerlink" title="vector list的区别与联系"></a>vector list的区别与联系</h4><p>答：联系：均为<strong>序列式容器</strong>，其中的元素不一定有序，但都可以被排序。</p><p>区别：</p><p>1.适用对象</p><ul><li>vector适用：对象数量变化少，简单对象，随机访问元素频繁</li><li>list适用：对象数量变化大，对象复杂，插入和删除频繁</li></ul><p>2.存储方式</p><ul><li>vector：连续的内存空间进行存储</li><li>list：非连续的内存空间进行存储</li></ul><p>3.时间复杂度</p><ul><li>vector： 随机读取O(1);中间位置插入和删除操作时间复杂度为O(N);尾部push_back, pop_back操作时间复杂度为O(1)</li><li>list： 随机读取O(n) ;插入O(1); 删除O(1)</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，时间复杂度为O(1)，而不擅长在序列中间添加或删除元素。</p><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><ul><li>deque<T> deq;                <strong>//默认构造形式</strong> </li><li>deque(beg, end];                <strong>//构造函数将[beg, end]区间中的元素拷贝给本身</strong></li><li>deque(n, elem);                <strong>//构造函数将n个elem拷贝给本身</strong></li><li>deque(const deque &amp;deq);                <strong>//拷贝构造函数</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d4[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-7.jpg" alt=""> </p><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><ul><li>assign(beg, end];                <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong> </li><li>assign(n, elem);                <strong>//将n个elem拷贝赋值给本身</strong>  </li><li>deque&amp; operator=(const deque &amp;deq);                 <strong>//重载等号操作符</strong>  </li><li>swap(deq);                <strong>// 将deq与本身的元素互换</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line">d2.assign(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d3.assign(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d4.swap(d3);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d4[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-8.jpg" alt=""> </p><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><ul><li>deque.size();                <strong>//返回容器中元素的个数</strong> </li><li>deque.empty();                <strong>//判断容器是否为空</strong>  </li><li>deque.resize(num);                <strong>//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</strong> </li><li>deque.resize(num, elem);                 <strong>//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除</strong></li></ul><p>例子略</p><h4 id="deque数据操作"><a href="#deque数据操作" class="headerlink" title="deque数据操作"></a>deque数据操作</h4><ul><li>push_back(elem);        <strong>//在容器尾部添加一个数据</strong> </li><li>push_front(elem);        <strong>//在容器头部插入一个数据</strong> </li><li>pop_back();        <strong>//删除容器最后一个数据</strong> </li><li>pop_front();        <strong>//删除容器第一个数据</strong></li><li>at(idx);                <strong>//返回索引idx所指的数据，如果idx越界，抛出out_of_range</strong></li><li>operator[];                <strong>//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错</strong></li><li>front();                <strong>//返回第一个数据</strong></li><li>back();                <strong>//返回最后一个数据</strong></li></ul><p>例子略</p><h4 id="deque插入删除"><a href="#deque插入删除" class="headerlink" title="deque插入删除"></a>deque插入删除</h4><ul><li>insert(pos,elem);                <strong>//在pos位置插入一个elem元素的拷贝，返回新数据的位置</strong></li><li>insert(pos,n,elem);                <strong>//在pos位置插入n个elem数据，无返回值</strong> </li><li>insert(pos,beg,end];                <strong>//在pos位置插入[beg,end]区间的数据，无返回值</strong></li><li>clear();                <strong>//移除容器的所有数据</strong>  </li><li>erase(beg,end];                <strong>//删除[beg,end]区间的数据，返回下一个数据的位置</strong></li><li>erase(pos);                <strong>//删除pos位置的数据，返回下一个数据的位置</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dt= d2.insert(d2.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *dt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">d2.insert(dt, arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d2.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d3.swap(d4);</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator ds = d3.erase(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ds &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ds=d3.erase(ds);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ds &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-9.jpg" alt=""> </p><h4 id="deque容器的存储结构"><a href="#deque容器的存储结构" class="headerlink" title="deque容器的存储结构"></a>deque容器的存储结构</h4><p>和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由<strong>一段一段等长的连续空间构成</strong>，各段<strong>空间之间并不一定是连续的，可以位于在内存的不同区域</strong>。</p><p>为了管理这些连续空间，<strong>deque 容器用数组(数组名假设为 map）存储着各个连续空间的首地址</strong>。也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-10.jpg" alt=""> </p><p>通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。</p><p>如果 map 数组满了就再申请一块更大的连续空间供 map 数组使用，将原有数据拷贝到新的 map 数组中，然后释放旧的空间。</p><h3 id="vector、list、deque的优缺点"><a href="#vector、list、deque的优缺点" class="headerlink" title="vector、list、deque的优缺点"></a>vector、list、deque的优缺点</h3><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li>如果你需要<strong>高效的随即存取</strong>，而不在乎插入和删除的效率，使用vector</li><li>如果你需要<strong>大量的插入和删除</strong>，而不关心随即存取，则应使用list</li><li>如果你需要<strong>随即存取，而且关心两端数据的插入和删除</strong>，则应使用deque</li></ul><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h4><p>优点：</p><ul><li>不用指定内存大小，即可以像数组一样的连续存储，对此数组进行动态操作。通常体现在push_back() pop_back()</li><li>随机访问方便，即支持[ ]操作符和vector.at()</li><li>节省空间</li></ul><p>缺点：</p><ul><li>在内部进行插入删除操作效率低。</li><li>只能在vector的最后进行push和pop，不能在vector的头进行push和pop。</li><li>当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放</li></ul><h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><p>优点：</p><ul><li>不使用连续内存完成动态操作</li><li>在内部方便的进行插入和删除操作</li><li>可在两端进行push、pop</li></ul><p>缺点：</p><ul><li>不能进行内部的随机访问，即不支持[ ]操作符和vector.at()</li><li>相对于verctor占用内存多</li></ul><h4 id="deque："><a href="#deque：" class="headerlink" title="deque："></a>deque：</h4><p>优点：</p><ul><li>随机访问方便，即支持[ ]操作符和vector.at()</li><li>在内部方便的进行插入和删除操作</li><li>可在两端进行push、pop</li></ul><p>缺点：占用内存多</p><hr><p>以上就是本篇STL容器的全部内容，下一篇我们将讲述关联式容器set、map和容器适配器stack、queue的基本使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在准备春招的，正好复习到STL的使用，才想起还有这么一个博客的坑没填，就趁这次把它补充完吧~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;序列式容器&quot;&gt;&lt;a href=&quot;#序列式容器&quot; class=&quot;headerlink&quot; title=&quot;序列式容器&quot;&gt;&lt;/a&gt;序列式容器&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
      <category term="list" scheme="http://yoursite.com/tags/list/"/>
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结VI</title>
    <link href="http://yoursite.com/2022/02/15/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93VI/"/>
    <id>http://yoursite.com/2022/02/15/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93VI/</id>
    <published>2022-02-15T01:47:43.000Z</published>
    <updated>2022-02-16T08:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第六篇，本篇将总结<strong>行为树</strong>的实现</p><hr><h3 id="什么是行为树"><a href="#什么是行为树" class="headerlink" title="什么是行为树"></a>什么是行为树</h3><p>在虚幻引擎4（UE4）中，可以用多种不同的方式为角色创建AI。可以使用蓝图脚本来指示角色”执行某种操作”，例如播放动画、移动到特定位置、被物体击中时做出的反应等等。希望AI角色自行思考并自行做出决定时，<strong>行为树</strong> 便能派上用场。</p><p>行为树与蓝图相似，皆是以一种可视化方式创建，将一系列具备功能的节点添加并连接至行为树图表。执行逻辑时，行为树会使用一种名为 <strong>黑板</strong> 的独立资源来存储它需要知道的信息（名为 <strong>黑板键</strong>），从而做出有根据的决策。</p><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><p>行为树由一个个结点组成一个完整的逻辑，分为<strong>合成结点和任务结点</strong>两种，其中合成结点又有三种基本的结点类型：</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-1.jpg" alt=""> </p><ul><li>选择器合成节点（<strong>Selector</strong>）：选择器节点<strong>从左到右执行其子项</strong>，其中一个<strong>子项成功时将停止执行该子项的子项</strong>。如果子项成功，则选择器成功。如果选择器的所有子项失败，选择器也将失败。</li><li>序列合成节点（<strong>Sequence</strong>）：序列节点从左到右执行其子项，其中一个<strong>子项失败时将停止执行该子项的子项</strong>。如果子项失败，则序列失败。如果所有序列的子项成功，则序列成功。</li><li>简单平行结点（<strong>Simple Parallel</strong>）：此节点是装饰器的局部作用域。当执行流程离开该分支时，所有观察中的装饰器（低优先级或两者）将被移除。</li></ul><p>而任务结点就多种多样了，其一般用于实现你期望AI做出的动作，除了系统自带的任务结点外我们还可以选择编写自己的任务结点</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-2.jpg" alt=""> </p><h4 id="装饰器与服务"><a href="#装饰器与服务" class="headerlink" title="装饰器与服务"></a>装饰器与服务</h4><p>我们可以在结点上扩展装饰器与服务，选中结点，单机右键就能看到如下两个选择</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-3.jpg" alt=""> </p><p><strong>装饰器</strong> 节点（也被称为条件语句）会连接至 <strong>行为树</strong> 内部的节点，可以用它来决定树中的一个分支（甚至单个节点）是否可以被执行。</p><p><strong>服务</strong> 节点通常连接至<strong>合成节点</strong>，只要它们的分支正在执行，它们就会以所定义的频率执行。它们通常被用于检查和更新<strong>黑板</strong>，代替其它行为树系统中的传统平行节点。</p><h3 id="判断是否被攻击"><a href="#判断是否被攻击" class="headerlink" title="判断是否被攻击"></a>判断是否被攻击</h3><p>铺垫完了背景知识，那么我们开始动手实现第一个AI逻辑——判断敌人是否被攻击</p><p>首先我们要创建一个行为树和一个黑板，并将两者绑定。</p><p>除此外我们还要新建一个基于<strong>AIControl</strong>的蓝图类，用来作为敌人的AI逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-4.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE6-5.jpg" alt=""> </p><p>然后我们在选中放在世界场景中的敌人，为其绑定我们新建的AI蓝图类</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-6.jpg" alt=""></p><p>我们在黑板中添加如下三个变量，用于后续操作</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-7.jpg" alt=""></p><p>做完这些基础工作后，我们开始设置第一个结点，添加服务<strong>用来读取敌人是否被攻击</strong></p><p>新建一个Sequence结点，添加一个服务</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-8.jpg" alt=""></p><p>返回<strong>AIControl</strong>蓝图类里，添加一个<strong>IsLaunching</strong>的自定义事件，用来读取敌人类中是否被攻击的布尔值，并赋值给黑板上</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-9.jpg" alt=""></p><p>这样一来，我们就能在服务结点里调用该事件</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-10.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第六篇，本篇将总结&lt;strong&gt;行为树&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是行为树&quot;&gt;&lt;a href=&quot;#什么是行为树&quot; class=&quot;headerlink&quot; title=&quot;什么是行为树&quot;&gt;&lt;/a&gt;什么是行为树&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结V</title>
    <link href="http://yoursite.com/2022/02/14/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93V/"/>
    <id>http://yoursite.com/2022/02/14/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93V/</id>
    <published>2022-02-14T01:47:23.000Z</published>
    <updated>2022-02-14T14:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第五篇，本篇将总结<strong>敌人攻击、敌人血条计算、敌人受伤、位移及死亡动画</strong>的实现</p><hr><h3 id="敌人攻击"><a href="#敌人攻击" class="headerlink" title="敌人攻击"></a>敌人攻击</h3><p>我们为敌人分别设置了近战攻击和远程攻击两种方式，首先我们需要定义两个事件来播放动画蒙太奇，用于我们后面在AI行为树中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-1.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-2.jpg" alt=""> </p><h4 id="近战攻击"><a href="#近战攻击" class="headerlink" title="近战攻击"></a>近战攻击</h4><p>首先我们到相应的动画蒙太奇中添加两个相应的通知事件，并在敌人的动画蓝图类中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-3.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-4.jpg" alt=""> </p><p>然后我们在敌人类的相应攻击位置添加碰撞盒（<strong>Hand</strong>）并设置碰撞逻辑和伤害，这里逻辑和角色类基本相似，故不加以赘述</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-5.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-6.jpg" alt=""> </p><h4 id="远程攻击"><a href="#远程攻击" class="headerlink" title="远程攻击"></a>远程攻击</h4><p>远程攻击的实现相较于近战攻击会稍微复杂一点，不过首先还是要在动画蒙太奇中添加动画通知并进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-7.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-8.jpg" alt=""> </p><p>然后我们还需要新建一个Actor蓝图类，命名为<strong>Spell</strong>，作为从敌人手中发射出的抛射物，并在该蓝图类中添加如下组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-9.jpg" alt=""> </p><p>然后我们选择ProjectileMovement，在此为抛射物设置初速度和最大速度</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-10.jpg" alt=""></p><p>然后我们返回敌人类中编写蓝图脚本，首先在相应攻击位置添加碰撞盒（<strong>Dagger</strong>）然后在事件<strong>SpawnSpell</strong> 中调用在位置处生成发射器（<strong>Spawn Emitter at Location</strong>）用于生成粒子特效</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-11.jpg" alt=""></p><p>然后在事件<strong>DraggerSpell</strong>中计算敌人与角色的旋转角度差，生成我们刚才所创建的<strong>Spell</strong></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-12.jpg" alt=""></p><p>随即我们返回<strong>Spell</strong>中，在碰撞盒中调用组件开始重叠时事件（<strong>On Component Begin Overlap</strong>）编写伤害应用逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-13.jpg" alt=""></p><h3 id="敌人血条计算、敌人受伤、位移及死亡动画"><a href="#敌人血条计算、敌人受伤、位移及死亡动画" class="headerlink" title="敌人血条计算、敌人受伤、位移及死亡动画"></a>敌人血条计算、敌人受伤、位移及死亡动画</h3><p>从敌人血条计算我们可以延伸出敌人受伤动画、受伤位移及死亡动画三种逻辑，让我们逐一分解</p><h4 id="敌人血条计算"><a href="#敌人血条计算" class="headerlink" title="敌人血条计算"></a>敌人血条计算</h4><p>敌人血条计算与角色类中的逻辑基本相同，不过在此处我们还需要先保存一下角色类和更新敌人血条UI（蓝图小结第三篇）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-14.jpg" alt=""></p><h4 id="敌人位移"><a href="#敌人位移" class="headerlink" title="敌人位移"></a>敌人位移</h4><p>敌人在收到攻击的时候，会产生一定的位移，要实现这样位移的效果，我们需要设置四个变量来计算敌人受到的力</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-16.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-15.jpg" alt=""></p><p>由于数值为负时则指向另外一轴，所以我们只需设置四个变量而非十六个变量</p><p>我们在蓝图脚本中自定义一个<strong>Launch</strong>事件，用来计算角色受到的力并弹射角色（<strong>Launch Character</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-17.jpg" alt=""></p><p>我们需要在受伤和死亡的动画蒙太奇中添加相应的动画通知，并在敌人的动画蓝图类触发</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-18.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-19.jpg" alt=""></p><h4 id="敌人受伤"><a href="#敌人受伤" class="headerlink" title="敌人受伤"></a>敌人受伤</h4><p>敌人血条计算结果若大于0，则首先调用立即停止移动（<strong>Stop Movement lmmediately</strong>）和停止播放动画蒙太奇（<strong>Stop Anim Montage</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-20.jpg" alt=""></p><p>然后我们要根据角色是否从角色正面进攻及角色武器攻击方向设置不同的力（正反面两组数值相反）和不同的蒙太奇动画</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-21.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-22.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-23.jpg" alt=""></p><p>最后将蒙太奇动画进行播放</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-24.jpg" alt=""></p><h4 id="敌人死亡"><a href="#敌人死亡" class="headerlink" title="敌人死亡"></a>敌人死亡</h4><p>敌人血条小于等于0时，就进入敌人死亡逻辑的处理，同样也是要判断角色的方向并设置不同的力和动画蒙太奇</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-25.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-26.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-27.jpg" alt=""></p><p>动画蒙太奇播放完后，要对角色设置模拟物理（<strong>Set Simulate Physics</strong>）、修改碰撞并销毁胶囊体和UI组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-28.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第五篇，自此我们已经将敌人类的基本蓝图逻辑梳理完成，下一篇我们将梳理敌人的AI行为</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第五篇，本篇将总结&lt;strong&gt;敌人攻击、敌人血条计算、敌人受伤、位移及死亡动画&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;敌人攻击&quot;&gt;&lt;a href=&quot;#敌人攻击&quot; class=&quot;headerlink&quot; title=&quot;敌人攻击&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结IV</title>
    <link href="http://yoursite.com/2022/02/13/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93IV/"/>
    <id>http://yoursite.com/2022/02/13/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93IV/</id>
    <published>2022-02-13T11:47:23.000Z</published>
    <updated>2022-02-14T14:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第四篇，本篇将总结<strong>角色方向、角色血条UI及计算</strong>的实现</p><hr><h3 id="角色血条UI"><a href="#角色血条UI" class="headerlink" title="角色血条UI"></a>角色血条UI</h3><p>由于游戏可操控主角只有一个，所以我们可以直接将UI展示在游戏界面中，而不用像设计敌人UI那样麻烦</p><p>首先我们还是需要先创建一个控件蓝图，用来设计UI的样式（<strong>Player UI</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-1.jpg" alt=""> </p><p>选择进度条，在百分比一栏旁选择创建绑定，就会跳到一个蓝图脚本界面</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-2.jpg" alt=""> </p><p>我们就可以在这蓝图脚本里编写相应的逻辑，<strong>Blood</strong>变量代表当前角色血量，<strong>Max Blood</strong>代表角色总血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-3.jpg" alt=""> </p><p>我们需要将该UI放在角色类里<strong>初始化</strong>中进行，同时还有一些其它逻辑需要进行初始化</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-4.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE4-5.jpg" alt=""> </p><h3 id="角色血条计算"><a href="#角色血条计算" class="headerlink" title="角色血条计算"></a>角色血条计算</h3><p>在处理角色血条计算时，我们需要先准备两个动画蒙太奇，一个是受攻击动画，另一个是死亡动画</p><p>然后我们调用事件任意伤害（<strong>Event AnyDamage</strong>），首先计算收到攻击后剩余的血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-6.jpg" alt=""> </p><p>然后我们根据当前血量进行角色当前状态的判断，并进行不同的逻辑处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-7.jpg" alt=""> </p><p>在设置角色死亡时，要调用销毁组件（<strong>DestroyComponent</strong>）传入角色胶囊体进行销毁</p><h3 id="角色攻击方向"><a href="#角色攻击方向" class="headerlink" title="角色攻击方向"></a>角色攻击方向</h3><p>由于我们的角色可能对敌人进行正反两个方向的攻击，所以我们需要判断敌人是面对角色还是背靠角色的，以方便我们后期对角色受攻击动画进行处理</p><p>我们需要在敌人类中定义一个新事件，调用寻找查看旋转函数（<strong>Find Look at Rotation</strong>），该函数用于计算起始位置转向目标位置的旋转角度，将此角度与角色选择角度作差，并保存</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-9.jpg" alt=""> </p><p>随即判断该值是否小于-60°到60°之间，若是的话，则代表角色在敌人面前，设置<strong>Front</strong>变量为True，用于后续敌人动画处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-8.jpg" alt=""> </p><hr><p>以上就是UE4蓝图小结第四篇，至此我们已经将角色类的蓝图脚本全部梳理完毕，并梳理了部分敌人类的蓝图脚本，下一篇将把敌人类的蓝图脚本梳理完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第四篇，本篇将总结&lt;strong&gt;角色方向、角色血条UI及计算&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;角色血条UI&quot;&gt;&lt;a href=&quot;#角色血条UI&quot; class=&quot;headerlink&quot; title=&quot;角色血条UI&quot;&gt;&lt;/a&gt;角
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结III</title>
    <link href="http://yoursite.com/2022/02/11/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93III/"/>
    <id>http://yoursite.com/2022/02/11/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93III/</id>
    <published>2022-02-11T06:33:22.000Z</published>
    <updated>2022-02-14T14:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第三篇，本次我们将总结<strong>武器碰撞、应用伤害及敌人血条UI</strong>的实现</p><hr><h3 id="武器碰撞"><a href="#武器碰撞" class="headerlink" title="武器碰撞"></a>武器碰撞</h3><p>碰撞，是UE4中检测两个物体是否发生接触的判断途径。也是我们检测角色武器是否与敌人发生接触的方法。</p><p>首先我们需要在角色类中网格体下为武器所在的位置添加碰撞盒（<strong>weapon</strong>），让其基本程度上覆盖武器</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-1.jpg" alt=""> </p><p>同时，我们要在攻击的动画蒙太奇中分别添加<strong>Eco Weapon</strong>和<strong>Deco Weapon</strong>两个通知，用于修改我们的碰撞状态</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-2.jpg" alt=""> </p><p>然后在动画蓝图类中添加通知</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-3.jpg" alt=""> </p><p>最后我们回到角色类中的蓝图脚本编写相应的逻辑</p><p>当触发Eco Weapon时，将weapon的碰撞类型（<strong>Set Collision Enabled</strong>）改成已启用碰撞（查询和物理），触发DecoWeapon时将碰撞类型设为无碰撞</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-4.jpg" alt=""> </p><p>这里我们就要简述一下<strong>UE4中的碰撞逻辑</strong>：</p><p>在UE4中两个物体发生接触会有三种情况：忽略、重叠、和阻挡</p><p>其中忽略和重叠在表现上是相同的，但是，我们若启用了生成重叠事件（<strong>Generate Overlap Events</strong>），就会可以调用重叠事件，我们的攻击碰撞到敌人的检测就是通过重叠来判断的</p><p>所以我们需要在碰撞盒weapon中进行预设</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-5.jpg" alt=""> </p><p>那么怎么样才能判断两个物体是发生了忽略重叠还是阻挡呢，下面一张图进行了简单的概况：</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-6.jpg" alt=""> </p><p>值得注意的是，若想要在两个物体产生碰撞后用蓝图脚本调用事件，我们需要勾选模拟生成命中事件（<strong>Simulation Generates Hit Events</strong>）</p><h3 id="应用伤害"><a href="#应用伤害" class="headerlink" title="应用伤害"></a>应用伤害</h3><p>要应用伤害，我们首先要有一个对象，所以我们要创建另一个角色类<strong>Enemy</strong>，用来编写敌人的逻辑（以下简称敌人类）</p><p>我们调用weapon的组件开始重叠函数，并将重叠对象作为进行一个类型转换为敌人类存储起来，方便后面伤害的应用</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-7.jpg" alt=""> </p><p>然后我们调用UE4中自带的应用伤害（<strong>Apply Damage</strong>）函数，传入相应参数</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-8.jpg" alt=""> </p><p>这样，攻击伤害就实现了</p><h3 id="敌人血条UI"><a href="#敌人血条UI" class="headerlink" title="敌人血条UI"></a>敌人血条UI</h3><p>由于我们一个场景中可能存在多个敌人，所以我们需要将敌人血条的UI挂在角色类上，首先我们要在网格体下添加一个控件组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-9.jpg" alt=""> </p><p>除此之外，我们还需要创建一个控件蓝图，用来设计UI的样式（<strong>Enemy UI</strong>），选择进度条组件，命名为<strong>EnemyBlood</strong>，并勾选Is Variable</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-10.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE3-11.jpg" alt=""> </p><p>然后我们返回敌人类中的控件组件做相应的配置，在控件类选择Enemy UI，并将其在游戏中隐藏一选项勾选</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-12.jpg" alt=""> </p><p>之后我们在敌人类的蓝图脚本中新建一个更新UI的函数，进行一系列逻辑处理，其中<strong>Blood</strong>变量代表当前敌人血量，<strong>Max Blood</strong>代表敌人总血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-13.jpg" alt=""> </p><p>由于血条的计算还和敌人类后面一系列逻辑有关，故不在本篇进行介绍，等后面章节再做补充</p><hr><p>以上就是UE4蓝图小结第三篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第三篇，本次我们将总结&lt;strong&gt;武器碰撞、应用伤害及敌人血条UI&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;武器碰撞&quot;&gt;&lt;a href=&quot;#武器碰撞&quot; class=&quot;headerlink&quot; title=&quot;武器碰撞&quot;&gt;&lt;/a&gt;武器碰
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结II</title>
    <link href="http://yoursite.com/2022/02/09/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93II/"/>
    <id>http://yoursite.com/2022/02/09/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93II/</id>
    <published>2022-02-09T04:04:37.000Z</published>
    <updated>2022-02-14T14:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第二篇，这一次我们来讲<strong>人物攻击的实现</strong></p><hr><h3 id="设置动画插槽"><a href="#设置动画插槽" class="headerlink" title="设置动画插槽"></a>设置动画插槽</h3><p>在UE4中实现攻击动画，我们需要用到播放动画蒙太奇这一功能，而为了使角色能够正常的播放蒙太奇动画，我们需要在动画蓝图中为角色添加动画插槽</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-1.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE2-2.jpg" alt=""> </p><h3 id="设置结构体与表格"><a href="#设置结构体与表格" class="headerlink" title="设置结构体与表格"></a>设置结构体与表格</h3><p>由于我们要实现动画的连招效果，而为了不使蓝图脚本看起来过于繁琐，我们要用到蓝图中的表格来存储数据（可以理解为数组）</p><p>首先我们要定义一个结构体，包含动画蒙太奇、最高伤害、最低伤害攻击方向四个变量</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-3.jpg" alt=""></p><p>然后我们创建数据表格，采用我们定义的结构体作为行结构，然后就可以在表中进行赋值</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-4.jpg" alt=""></p><p>由于我们要在游戏中实现两种攻击形式，所以我们还需要创建一个枚举值分别存放两个不同攻击的的名称，对应表格中的行名，方便我们在蓝图脚本中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-5.jpg" alt=""></p><h3 id="攻击实现"><a href="#攻击实现" class="headerlink" title="攻击实现"></a>攻击实现</h3><p>首先要讲一下我设计的攻击逻辑，角色分有普通攻击和特殊攻击两种，每种攻击各有四种连击动画，按鼠标左键触发普通攻击，按下左键后再按下右键触发特殊攻击。</p><p>要实现这样的攻击效果，我们需要完成以下几件事：</p><ul><li>读取表格攻击数据</li><li>对准角色攻击方向</li><li>连招的逻辑实现</li></ul><p>让我们来一一分解：</p><h4 id="读取表格攻击数据"><a href="#读取表格攻击数据" class="headerlink" title="读取表格攻击数据"></a>读取表格攻击数据</h4><p>我们在角色类蓝图脚本中添加一个自定义事件，用于读取表格数据并播放动画蒙太奇，下图是完成了逻辑流程</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-6.jpg" alt=""></p><p>首先先将判断上一轮攻击是否完成的变量（<strong>Done</strong>）设为false，然后根据枚举数据设置要读取的表头名（<strong>Change Skill</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-7.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-8.jpg" alt=""></p><p>然后通过调用<strong>Get Data Table Row</strong>来获得表格中的对应表行的数据，并进行相应的赋值处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-9.jpg" alt=""></p><p>最后进行延时处理（等待动画播放完），并将Done变量设为true</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-10.jpg" alt=""></p><h4 id="对准角色攻击方向"><a href="#对准角色攻击方向" class="headerlink" title="对准角色攻击方向"></a>对准角色攻击方向</h4><p>对准角色攻击方向要先判断角色是否正在进行攻击，若是的话，通过<strong>Set bUseControllerRotationYaw</strong>来使角色面向自己镜头所在的方向</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-20.jpg" alt=""></p><h4 id="连招逻辑的实现与动画通知"><a href="#连招逻辑的实现与动画通知" class="headerlink" title="连招逻辑的实现与动画通知"></a>连招逻辑的实现与动画通知</h4><p>点击鼠标左键调用攻击，关键的是处理Index的自增逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-11.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-12.jpg" alt=""></p><p>而实现特殊攻击的逻辑就比较复杂一点了，因为特殊攻击要求我们在按下普通攻击后再按下右键才能进行调用，所以我们要先判断是否处于普通攻击中</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-13.jpg" alt=""></p><p>并且我们要保证该攻击只执行一次，需要用到<strong>Do Once</strong>这一功能</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-14.jpg" alt=""></p><p>而只有在自定义事件<strong>Reset Skill</strong>触发时，才能再发生该特殊攻击的执行</p><p>那么要在哪里触发该事件呢，这里我们就需要用到UE4中的<strong>动画通知</strong>：</p><p><strong>动画通知</strong>（<strong>AnimNotifies</strong> 或 <strong>通知</strong>）为动画程序员提供了一种方式，以便设置事件在 <strong>动画序列</strong> 中的特定点上发生。通知常用于在行走或跑步动画中添加脚步声之类的效果，或在动画中生成粒子系统。它们用途广泛，系统可随自定义通知类型进行延展，以满足各种游戏的需求。（源自UE4官方文档）</p><p>要实现动画通知我们首先要在相应的动画蒙太奇上添加通知（其中<strong>Reset Combo</strong>用来将各种变量重置）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-15.jpg" alt=""></p><p>除此外，我们还需要再动画蓝图类中添加事件触发通知</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-16.jpg" alt=""></p><p>这样一来就能保证角色类中的事件正常触发啦</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-17.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-18.jpg" alt=""></p><p>之后就是处理Index的逻辑，要特别注意的是最后一次特殊攻击要将Index的值重新赋值为3（因为普通攻击这时已经将Index重置为0）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-19.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第二篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第二篇，这一次我们来讲&lt;strong&gt;人物攻击的实现&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;设置动画插槽&quot;&gt;&lt;a href=&quot;#设置动画插槽&quot; class=&quot;headerlink&quot; title=&quot;设置动画插槽&quot;&gt;&lt;/a&gt;设置动画插槽&lt;/h
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结I</title>
    <link href="http://yoursite.com/2022/01/25/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93I/"/>
    <id>http://yoursite.com/2022/01/25/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93I/</id>
    <published>2022-01-25T02:35:00.000Z</published>
    <updated>2022-02-14T14:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>于是乎终于开始了我的游戏设计之路</p><p>之前是一直在前端和游戏两个方向飘忽不定，但在做了一些前端项目后，决心还是重点专研游戏这一方向，也把我的毕业设计题目定成了基于UE4的动作游戏开发，那么就要好好专研了。</p><p>首先第一步就是制作一个动作游戏的Demo，我决定采用纯蓝图完成，以帮助我快速入门虚幻4</p><hr><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>蓝图是虚幻4所提供给开发者的一套强大工具，它具体可分为<strong>蓝图类和蓝图脚本</strong></p><p><strong>蓝图类</strong>, 一般缩写为 <strong>Blueprint(蓝图)</strong>,是一种允许内容创建者轻松地基于现有游戏性类添加功能的资源。 蓝图*是在虚幻编辑器中可视化地创建的，不需要书写代码，会被作为类保存在内容包中。</p><p>而<strong>蓝图脚本</strong>则可以理解为是一种脚本语言，它是虚幻4将底层C++封装好后提供给开发者的一种可视化编程工具，这样即便是非程序员也能通过简单的连线来处理游戏的逻辑关系，以达到实现简单的游戏效果。</p><h3 id="人物移动、转向与跳跃"><a href="#人物移动、转向与跳跃" class="headerlink" title="人物移动、转向与跳跃"></a>人物移动、转向与跳跃</h3><h4 id="创建角色类"><a href="#创建角色类" class="headerlink" title="创建角色类"></a>创建角色类</h4><p>首先我们要创建一个蓝图类来存放我们的主角，我们在UE4中的内容浏览器里右键选择新建蓝图类，在父类一项我们选择角色</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-18.jpg" alt=""> </p><p>之后我们命名并保存，进入该角色类里点击网格体为角色选择一个骨骼并调整相应大小，我这里用的是虚幻商城免费提供的</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-19.jpg" alt=""> </p><p>然后保存即可，这样我们就有了一个简单的角色类</p><h4 id="操作映射与轴映射"><a href="#操作映射与轴映射" class="headerlink" title="操作映射与轴映射"></a>操作映射与轴映射</h4><p>虚幻4的项目设置里包含操作映射与轴映射两项属性，用于将我们的输入映射到游戏中，可供我们在蓝图中进行调用，也可以由我们自己进行改写。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-1.jpg" alt=""> </p><p>一般这些配置符合正常的游戏逻辑属性，通常不进行改写，我们的人物移动就需要用到其中的MoveForward和MoveRight映射。</p><h4 id="人物移动"><a href="#人物移动" class="headerlink" title="人物移动"></a>人物移动</h4><p>我们需要在<strong>角色类</strong>里编写蓝图脚本来控制角色的移动，在第三人称游戏中我们通过WASD来进行人物的移动，而这些在MoveForward和MoveRight中便有相应的映射</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-2.jpg" alt=""> </p><p>而添加移动输入（<strong>Add Movement Inpu</strong>t）则是虚幻4封装好的函数，它会根据轴映射的返回值让对象进行相应的移动。</p><p>同时我们还要获得人物的旋转方向（<strong>Get Control Rotation</strong>）并且将其分解为z轴上的值，这样能防止从其它视角上移动人物受到影响。然后将值一并赋予移动输入里，这样就能实现简单的人物移动效果</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-3.jpg" alt=""> </p><h4 id="人物转向"><a href="#人物转向" class="headerlink" title="人物转向"></a>人物转向</h4><p>人物转向也是同理，通过Turn和LookUp两个映射，并调用虚幻4中封装好的<strong>Add Controller Yaw Input</strong>和<strong>Add Controller Pitch Input</strong>两个函数，实现通过鼠标进行人物转向的功能</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-4.jpg" alt=""> </p><h4 id="跑步与跳跃"><a href="#跑步与跳跃" class="headerlink" title="跑步与跳跃"></a>跑步与跳跃</h4><p>两个步骤实现的人物移动，只是静止的，要实现人物的真正移动，我们还需要<strong>动画蓝图类</strong>的配合</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-5.jpg" alt=""> </p><p>我们需要通过一个状态机来实现人物不同动画之间状态的切换，而在那之前我们还需要建立一个混合空间1D来存放人物从移动到跑步的动画，并在资产详情里将水平轴的最大坐标设置为600。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-6.jpg" alt=""> </p><p>然后在状态机里，我们就可以将如上动画序列拖入，并通过连线实现其之间的逻辑转换</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-7.jpg" alt=""> </p><p>而为了实现行走、跑步、跳跃，我们需要在动画蓝图里分别设置两个变量：Speed和Is AIr</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-8.jpg" alt=""> </p><p>而人物的状态是要通过角色类获得的，为了获得相应的参数，我们需要在动画蓝图类的事件图表里通过调用<strong>Try Get Pawun Owner</strong>以获得角色类，然后调用相应函数便可对Speed和Is AIr两个变量的赋值。</p><p>其中事件蓝图更新动画（<strong>Event Blueprint Update Animation</strong>）每帧执行一次，允许动画蓝图执行计算并更新到它需要的任何值。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-9.jpg" alt=""> </p><p>然后就可以会到状态机里设置四个状态变换的条件</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-10.jpg" alt=""> </p><p>然后我们要回到角色类中的蓝图脚本添加相应的奔跑与跳跃映射</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-11.jpg" alt=""> </p><p>同时，要在角色移动组件里设置相应行走的速度</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-12.jpg" alt=""> </p><p>这样，我们就实现了最基本的人物移动、转向与跳跃</p><h3 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h3><p>动画重定向就是让不同的两个人物骨骼模型共用同一套动画，由于我们开发游戏过程中的很多资源都是EPIC商城提供的，所以动画重定向还是很经常使用。</p><p>要实现最基本的人型动画的重定向，我们需要到相应的角色骨骼里，按图下步骤进行重定向绑定</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-13.jpg" alt=""> </p><p>同时在需要重定向动画中的骨骼也进行同样的操作，然后再需要重定向的动画序列上右键选择重定向动画资产就可以完成重定向操作</p><p>（要注意两个重定向的骨骼姿势要基本保持一致）</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-14.jpg" alt=""></p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-15.jpg" alt=""></p><p>重定向后的动画有时会出现一些奇怪的姿势，这是我们就要在骨骼树里的选项里选择显示重定向选择，然后在root点击右键选择递归平移设置重定向骨骼，就能让姿势回归正常</p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-16.jpg" alt=""></p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-17.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第一篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;于是乎终于开始了我的游戏设计之路&lt;/p&gt;
&lt;p&gt;之前是一直在前端和游戏两个方向飘忽不定，但在做了一些前端项目后，决心还是重点专研游戏这一方向，也把我的毕业设计题目定成了基于UE4的动作游戏开发，那么就要好好专研了。&lt;/p&gt;
&lt;p&gt;首先第一步就是制作一个动作游戏的Demo，我
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer 第五版》阅读笔记I:引用、指针与const</title>
    <link href="http://yoursite.com/2022/01/25/%E3%80%8AC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/01/25/%E3%80%8AC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-25T02:34:02.000Z</published>
    <updated>2022-02-08T13:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>大学里除了在课堂上接触专业的书外，就很少在课堂下阅读与专业有关的书了。有很多经典计算机书籍都没有去看，其实想来是蛮错误的一件事，所以就趁这这个寒假读了读《C++ Primer 第五版》，正好也为我C++的开发巩固些基础。</p><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>引用为对象齐了另外一个名字，通常将声明符写成&amp;n的形式来定义引用类型，n是声明的变量名。<strong>定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。</strong></p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r=i;<span class="comment">//r是一个应用，与i绑定在一起</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r;<span class="comment">//结果为1024</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>引用类型的初始值必须是一个对象</li><li>引用必须要初始化</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>指针是指向另外一种类型的符合类型，与引用相似，指针也实现了对其他对象的间接访问。定义指针类型的方法将声明符写成<em>d的形式，其中d为变量名。<strong>指针用于存放某个对象的地址</strong>，获取该地址时，我们要用<strong>取地址符&amp;</strong>（注意不要和引用声明混淆）如果指针指向了一个对象，则允许使用<strong>解引用符 </strong></em>（注意不要和指针声明混淆） 来访问对象。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;i;<span class="comment">//r存放变量i的地址，r为指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *r &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指向的对象</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;i &lt;&lt; <span class="string">"  "</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指向对象的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;r &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指针本身的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CP1-1.jpg" alt=""></p><h4 id="与引用的区别"><a href="#与引用的区别" class="headerlink" title="与引用的区别"></a>与引用的区别</h4><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝</li><li>引用本身非对象，一旦定义了引用，就无法绑定到另外的对象</li><li>指针无需在定义时赋初值，没有初始化时系统将自动分配一个不确定的值</li></ul><h4 id="指针的指针与指针的引用"><a href="#指针的指针与指针的引用" class="headerlink" title="指针的指针与指针的引用"></a>指针的指针与指针的引用</h4><p>一般来说，用到这两个的会比较少，也属于比较绕的两个概念，这里直接附上原文，供大家理解</p><p><img src= "/img/loading.gif" data-src="/photo/CP1-2.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/CP1-3.jpg" alt=""></p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>const对变量的类型进行限定，使其值不能改变，成为常量，故其必须进行初始化</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line">i=<span class="number">2048</span>;<span class="comment">//编译错误，const不能进行写值</span></span><br></pre></td></tr></table></figure><h4 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h4><p>我们同样可以<strong>令指针指向常量</strong>，称其为<strong>指向常量的指针</strong>，但不能用于改变其所指对象的值。</p><p>另一种写法是<strong>把指针本身定为常量，称为常量指针</strong>，其必须初始化，且无法进行改变。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//指向常量的指针，可以改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptnum = &amp;num;<span class="comment">//常量指针，将一直指向num，无法改变</span></span><br></pre></td></tr></table></figure><h4 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h4><p>顶层const表示<strong>指针本身是个常量</strong></p><p>底层const表示<strong>指针所指向的对象是一个常量</strong>。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名就是定义某种类型的同义词，好让我们方便编程时理解和使用。</p><p>通常我们用<strong>关键字typedef</strong>进行类型别名的定义，除此之外，我们还能用<strong>别名声明</strong>来定义类型的别名，这种方法<strong>用using作为别名声明的开始</strong>，后紧跟别名和等号，如下所示：</p><p><code>using fl = float;</code></p><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>C+11新标准引入了auto类型说明符，它能让编译器替我们分析表达式所属的类型，如下所示</p><p><code>auto i=0,j=3.14;            //编译器会自动根据数据判断类型</code></p><h4 id="constexpr与常量表达式"><a href="#constexpr与常量表达式" class="headerlink" title="constexpr与常量表达式"></a>constexpr与常量表达式</h4><p><strong>常量表达式</strong>是指值不会改变并且能在编译过程就能得到计算结果的表达式，在C++中我们可以通过用constexpr来声明一个变量或者式子为常量表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[N];</span><br><span class="line">    <span class="keyword">int</span> arrs[M];<span class="comment">//在某些编译器中会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>decltype能返回操作数的数据类型，操作数可以是变量，也可以是函数，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(fun()) sum = <span class="number">0</span>;<span class="comment">//sum的类型就是int</span></span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">6</span>;<span class="comment">//j的类型是const int</span></span><br><span class="line">    <span class="keyword">decltype</span>(pi) k = <span class="number">6.66</span>;<span class="comment">//pi的类型是double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是本人《C++ Primer 第五版》的第一篇阅读笔记，感谢您的观看~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学里除了在课堂上接触专业的书外，就很少在课堂下阅读与专业有关的书了。有很多经典计算机书籍都没有去看，其实想来是蛮错误的一件事，所以就趁这这个寒假读了读《C++ Primer 第五版》，正好也为我C++的开发巩固些基础。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="指针" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>算法II:排序与查找的应用</title>
    <link href="http://yoursite.com/2022/01/17/%E7%AE%97%E6%B3%95II-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2022/01/17/%E7%AE%97%E6%B3%95II-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-01-17T03:39:54.000Z</published>
    <updated>2022-02-07T13:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客将讲述在数据结构中学过的一些排序与查找的具体应用，以及STL中sort的用法讲解，具体内容往下看吧</p><hr><h3 id="sort的用法"><a href="#sort的用法" class="headerlink" title="sort的用法"></a>sort的用法</h3><p>一般在解决实际问题的时候，我们很少再去自己写一个排序算法进行调用，因为像很多语言都已经封装好了排序函数让我们直接进行调用，就比如C++中<algorithm>里的sort函数</p><p>sort(first,last,comp)函数有三个参数: first和 last为待排序序列的起始地址和结束地址;cmp为排序方式，可以不填写,<strong>不填写时默认为升序方式</strong>。</p><p>sort函数的基本应用我们自不多讲，这里主要讲一下如何应用sort函数里的cmp来进行自定义的排序</p><h4 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h4><p><strong>题目:</strong></p><p>用一维数组存储学号和成绩,然后按成绩排序输出。</p><p><strong>输入:</strong></p><p>输入的第一行中包括一个整数N（1≤N≤100)，它代表学生的个数。</p><p>接下来的N行中,每行包括两个整数p和q，分别代表每个学生的学号和成绩。</p><p><strong>输出:</strong></p><p>按照学生的成绩从小到大进行排序,并将排序后的学生信息打印出来。如果学生的成绩相同，那么按照学号的大小从小到大排序。</p><p><strong>样例输入:</strong><br>3</p><p>1 90</p><p>2 87</p><p>3 92</p><p><strong>样例输出:</strong></p><p>2 87</p><p>1 90</p><p>3 92</p><p><strong>思想：</strong></p><p>本题需要定义一个结构体，可通过cmp来改写sort使之能用于结构体的排序，除此之外，我们还可以定义结构体的小于号重载来达到该目的</p><p><strong>代码（cmp方法）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(struct student &amp;s1, struct student &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.score != s2.score)</span><br><span class="line"><span class="keyword">return</span> s1.score &lt; s2.score;<span class="comment">//若成绩不相等，按成绩从小到大排序</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> s1.num &lt; s2.num;<span class="comment">//若成绩相等，按学号从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">student</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i].num &gt;&gt; s[i].score;</span><br><span class="line">&#125;</span><br><span class="line">sort(s, s + n, cmp1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i].num &lt;&lt;<span class="string">" "</span>&lt;&lt; s[i].score &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码（重载小于号方法）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(student stu) <span class="keyword">const</span> &#123;<span class="comment">//采用该方法，运行速度将会更快</span></span><br><span class="line"><span class="keyword">if</span> (score == stu.score)</span><br><span class="line"><span class="keyword">return</span> num &lt; stu.num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> score &lt; stu.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">student</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i].num &gt;&gt; s[i].score;</span><br><span class="line">&#125;</span><br><span class="line">sort(s, s + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i].num &lt;&lt; <span class="string">" "</span> &lt;&lt; s[i].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-1.jpg" alt=""> </p><h4 id="整数奇偶排序"><a href="#整数奇偶排序" class="headerlink" title="整数奇偶排序"></a>整数奇偶排序</h4><p><strong>题目：</strong><br>输入10个整数，彼此以空格分隔。重新排序以后输出(也按空格分隔)，要求:1.先输出其中的奇数,并按从大到小排列;2.然后输出其中的偶数,并按从小到大排列。</p><p><strong>输入:</strong></p><p>任意排序的10个整数(0～100)，彼此以空格分隔。</p><p><strong>输出</strong>:</p><p>可能有多组测试数据，对于每组数据，按照要求排序后输出，由空格分隔。</p><p>1.测试数据可能有很多组，请使用while(cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;…&gt;&gt;a[9])类似的做法来实现;</p><p>2.输入数据随机，有可能相等。</p><p><strong>样例输入:</strong></p><p>4 7 3 13 11 12 0 47 34 98</p><p><strong>样例输出:</strong></p><p>4 7 13 11 7 3 0 4 12 34 98</p><p><strong>思想：</strong></p><p>本题最直观的方法就是先将数据分为奇偶两组，然后再进行排序。但这样明显速度上是比较慢的，此时我们就可以从sort方法下的cmp入手进行改造</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x &lt; y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;arr[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">sort(arr, arr + MAX, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-2.jpg" alt=""> </p><h3 id="排序算法的应用"><a href="#排序算法的应用" class="headerlink" title="排序算法的应用"></a>排序算法的应用</h3><h4 id="O-n-的排序"><a href="#O-n-的排序" class="headerlink" title="O(n)的排序"></a>O(n)的排序</h4><p><strong>题目:</strong></p><p>给你n个整数，请按从大到小的顺序输出其中前m大的数，时间复杂度要求为O(n)。</p><p><strong>输入:</strong></p><p>输入有多组数据。每组测试数据有两行，第一行有两个数n,m(O&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</p><p><strong>输出:</strong><br>对每组测试数据按从大到小的顺序输出前m大的数。</p><p><strong>样例输入∶</strong></p><p>5 3</p><p>3 -35 92 213 -644</p><p><strong>样例输出∶</strong></p><p>213 92 3</p><p><strong>思想：</strong></p><p>由于题目要求要在O(n)的时间复杂度内完成排序，哪怕应用效率最高的快排堆排的时间复杂度也难以达到O(n)，但由于数据量并不是很大，故这时我们可以考虑用计数排序，通过空间换时间，达到O(n)的时间量级</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RANGE = <span class="number">5e5</span>;  <span class="comment">//由于数据区间是从-500000到+500000，故需要进行范围调整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[MAX];<span class="comment">//用于计数排序</span></span><br><span class="line"><span class="keyword">int</span> arr[MAX];<span class="comment">//用于存放排序好的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">num[arr[i] + RANGE]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (num[i]--)</span><br><span class="line">&#123;</span><br><span class="line">arr[index++] = i - RANGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= n - m; i--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-3.jpg" alt=""> </p><h4 id="逆序数求解"><a href="#逆序数求解" class="headerlink" title="逆序数求解"></a><strong>逆序数求解</strong></h4><p><strong>题目:</strong></p><p>给你n个整数组成的序列，请求出序列的逆序数。</p><p><strong>输入∶</strong></p><p>输入有多组数据。第一行先给出数据的组数，每组测试数据有第一行，每组数据先给出序列的长度N(O&lt;N&lt;100)，之后输入n个处于区间</p><p>[-1000000,1000000]的整数。</p><p><strong>输出:</strong></p><p>对每组测试数据先输出”Scenario #:”，在输出该组数据的逆序数，每组输出之间用空行分割开来。</p><p><strong>样例输入∶</strong></p><p>4<br>4 2 8 0 3<br>10 0 1 2 3 4 5 6 7 8 9<br>6 -42 23 6 28 -100 65537<br>5 0 0 0 0 0</p><p><strong>样例输出∶</strong></p><p>Scenario #1:<br>3</p><p>Scenario #2:<br>0</p><p>Scenario #3:<br>5</p><p>Scenario #4:<br>0</p><p><strong>思想：</strong></p><p>解决本题，我们要用到的是归并排序的思想，因为对于归并排序来说，当右边归并的数小于左边归并的数时，说明右边该数小于左边归并数之后的任一数字，我们只需要在这一个时候进行累加，就可计算出数据中所有的逆序数</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp[MAX];</span><br><span class="line"><span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = left;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">num += mid + <span class="number">1</span> - i;<span class="comment">//计算逆序数</span></span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">while</span> ( j &lt;= right)</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"><span class="keyword">for</span> (i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">MergeSort(left, mid, arr);</span><br><span class="line">MergeSort(mid + <span class="number">1</span>,right, arr);</span><br><span class="line">Merge(left, right, mid, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *res = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存放结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[j];</span><br><span class="line">MergeSort(<span class="number">0</span>, l - <span class="number">1</span>, arr);</span><br><span class="line">res[i] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-4.jpg" alt=""> </p><h4 id="第K大数"><a href="#第K大数" class="headerlink" title="第K大数"></a>第K大数</h4><p><strong>题目:</strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>输入∶</strong></p><p>第一行给出k的值和数组的长度n</p><p>第二行给出数组的元素</p><p><strong>输出:</strong></p><p>输出数组中第k个最大的元素</p><p><strong>样例输入∶</strong></p><p>2 6</p><p>3 2 1 5 6 4</p><p><strong>样例输出∶</strong></p><p>5</p><p><strong>思想：</strong></p><p>本题我们可以用到快速排序的思想，因为快排的每一轮结束都能确定一个数的最终位置，若该位置小于n-k，则说明第 k 个最大的元素在该位置的右边，若大于k值，则说明在该位置的左边。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left, j = right, num = arr[left];</span><br><span class="line"><span class="keyword">while</span> (i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((arr[j] &gt;= num) &amp;&amp; (i &lt; j))</span><br><span class="line">j--;</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line"><span class="keyword">while</span> ((arr[i] &lt;= num) &amp;&amp; (i &lt; j))</span><br><span class="line">i++;</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = num;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> *arr, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> privot = Partition(left, right, arr);</span><br><span class="line"><span class="keyword">if</span> (privot == n - k)</span><br><span class="line"><span class="keyword">return</span> arr[privot];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(privot&gt;n-k)</span><br><span class="line"><span class="keyword">return</span> QuickSort(left, privot - <span class="number">1</span>, arr, k, n);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> QuickSort(privot + <span class="number">1</span>,right, arr, k, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k &gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">int</span> num = QuickSort(<span class="number">0</span>, n<span class="number">-1</span>, arr, k, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-5.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客将讲述在数据结构中学过的一些排序与查找的具体应用，以及STL中sort的用法讲解，具体内容往下看吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;sort的用法&quot;&gt;&lt;a href=&quot;#sort的用法&quot; class=&quot;headerlink&quot; title=&quot;sort的用法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法I:暴力算法</title>
    <link href="http://yoursite.com/2022/01/09/%E7%AE%97%E6%B3%95I-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/01/09/%E7%AE%97%E6%B3%95I-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/</id>
    <published>2022-01-09T12:55:15.000Z</published>
    <updated>2022-01-17T14:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>考研结束了，专业也结课了，好像一切时间都回到了自己手上，却也知道我的大学生涯只剩下最后六个月了。</p><p>给自己放了两周假，又要投入忙碌的学习中去了。接下来的学习主要有两个主要目的，一个是春招，一个就是毕业设计了。</p><p>考研错过了秋招的各种机遇，需要更加认真的准备一下春招的事，而毕业设计终于开始了我游戏设计的第一步。</p><p>任务还是挺繁重的</p><p>一步一步来吧</p><p><strong>路漫漫其修远兮，吾将上下而求索</strong></p><hr><p>计算机面试或笔试的时候，算法必是躲不掉的一关，这个系列的博客我将汇总一些比较常见的计算机算法思想，然后并配上几道例题加以说明。</p><p>暴力算法是我们在面对题目最容易想到的算法，虽然简单粗暴，但往往行之有效，暴力算法最常用的就是用<strong>枚举</strong>解决问题。</p><p>Eg.</p><h3 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a><strong>ABC</strong></h3><p><strong>题目：</strong></p><p>设a,b,c均是0到9之间的数字，abc,bcc是两个三位数，且有abc+ bcc=532。</p><p>求满足条件的所有 a,b,c的值。</p><p><strong>输入：</strong><br>题目没有任何输入。</p><p><strong>输出：</strong></p><p>请输出所有满足题目条件的a,b,c的值。</p><p>a,b,c之间用空格隔开。</p><p>每个输出占一行。</p><p><strong>思想：</strong></p><p>0-9三重遍历，找到<script type="math/tex">a*100+b*10+c+b*100+c*10+c==532</script>进行输出即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">9</span>; ++a)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">9</span>; ++b) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">9</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (a * <span class="number">100</span> + b * <span class="number">10</span> + c + b * <span class="number">100</span> + c * <span class="number">10</span> + c == <span class="number">532</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-1.jpg" alt=""> </p><h3 id="今年的第几天？"><a href="#今年的第几天？" class="headerlink" title="今年的第几天？"></a>今年的第几天？</h3><p><strong>题目：</strong></p><p>输入年、月、日，计算该天是本年的第几天。</p><p><strong>输入：</strong></p><p>包括3个整数：年（1≤Y≤3000）、月（1≤M≤12）、日（1≤D≤31）。</p><p><strong>输出：</strong></p><p>输入可能有多组测试数据，对于每组测试数据，</p><p>输出一个整数，代表 Input中的年、月、日对应本年的第几天。</p><p><strong>样例输入：</strong></p><p>1990 9 20</p><p>2000 5 1</p><p><strong>样例输出：</strong></p><p>263</p><p>122</p><p><strong>思想：</strong></p><p>首先判断是平年还是闰年，再根据平年和闰年各自对应的月份进行累加</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">2</span>][<span class="number">13</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;,</span><br><span class="line"> &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y, m, d, year, days = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; y &gt;&gt; m &gt;&gt; d;</span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>)||(y % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">year = <span class="number">1</span>;<span class="comment">//闰年</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">year = <span class="number">0</span>;<span class="comment">//平年</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">days += month[year][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; days + d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-2.jpg" alt=""> </p><h3 id="Hello-World-for-U"><a href="#Hello-World-for-U" class="headerlink" title="Hello World for U"></a><strong>Hello World for U</strong></h3><p><strong>题目：</strong></p><p>给定任意N（&gt;=5）个字符的字符串，要求您将字符组成U形。例如，“helloworld”可以打印为：h d e l l r lowo，也就是说，字符必须按原始顺序打印，从带有n1个字符的左垂直线开始自上而下打印，然后，从左到右沿底线使用n2个字符，最后沿垂直线从下到上使用n3个字符。更重要的是，我们希望U是尽可能的平方——也就是说，必须满足n1=n3=max{k | k&lt;=n2，对于所有3&lt;=n2&lt;=N}，n1+n2+n3-2=N。</p><p><strong>输入：</strong></p><p>有多个测试用例。每个大小写包含一个字符串，一行中不少于5个字符，不超过80个字符。字符串不包含空格。</p><p><strong>输出：</strong></p><p>对于每个测试用例，按照描述中指定的U形打印输入字符串。</p><p><strong>样例输入：</strong></p><p>helloworld!</p><p><strong>样例输出：</strong></p><p>h   !<br>e   d<br>l   l<br>lowor</p><p><strong>思想：</strong></p><p>本题最主要的是要理解n1=n3=max{k|k&lt;=n2，对于所有3&lt;=n2&lt;=N}，n1+n2+n3-2=N的含义，该条件要求n1和n3不大于n2，且要满足在n1+n2+n3-2=N条件下取得最大值。故n1=n3=(N+2)/3，而中间空格与最后一行（除去头尾两个字符）的数是N-n1-n2，得出这个条件，本题就不难了。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">int</span> N = s.length();</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">n1 = n2 = (N + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> mid = N - n1 - n2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mid; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == n1 - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i + <span class="number">1</span> + j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j != mid)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[N - <span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-3.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，感谢观看~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考研结束了，专业也结课了，好像一切时间都回到了自己手上，却也知道我的大学生涯只剩下最后六个月了。&lt;/p&gt;
&lt;p&gt;给自己放了两周假，又要投入忙碌的学习中去了。接下来的学习主要有两个主要目的，一个是春招，一个就是毕业设计了。&lt;/p&gt;
&lt;p&gt;考研错过了秋招的各种机遇，需要更加认真
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js入门 II:创建Vue项目</title>
    <link href="http://yoursite.com/2021/10/08/Vue-js%E5%85%A5%E9%97%A8-II-%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/10/08/Vue-js%E5%85%A5%E9%97%A8-II-%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-10-08T07:02:25.000Z</published>
    <updated>2021-11-02T06:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客我们来讲如何初始化一个Vue项目，需要特别说明一下的是，Vue.js入门系列博客讲的都是Vue2的语法内容，其实此时Vue3.0已经正式发布有一年多的时间了，但鉴于目前大多数项目都还是由Vue2进行编写，我还是决定从Vue2学起，但其实掌握了Vue2，上手Vue3也不会是很长的事。话不多说，请看正文</p><hr><h3 id="初始化Vue项目"><a href="#初始化Vue项目" class="headerlink" title="初始化Vue项目"></a>初始化Vue项目</h3><p>我们在开发一个Vue项目时，往往不会是向我们上一篇博客那样引入一个JS文件，而是会搭建一个项目模板，在模板上面进行修改，那么如何初始化这个模板呢，首先我们需要按Win+R输入cmd（打开命令行），输入如下语句：</p><p><code>npm install -g @vue/cli</code></p><p>这时我们系统就会开始下载vue/cli，当然前提是你已经在电影上装好了npm</p><p>耐心等待一段时间，看到如下画面即代表成功</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-1.jpg" alt=""></p><p>之后进入你想要创建项目的文件夹，可以进入你想要创建项目的文件夹下面，运行如下语句</p><p><code>vue create demo2</code></p><p>这时会让你选择要安装的版本，我们选择Vue2的默认版本即可</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-2.jpg" alt=""></p><p>之后耐心等待，看到如下画面就算成功啦（我这里用了yarn，会跟用npm的有一点小差别）</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-3.jpg" alt=""></p><p>最后我们进入到项目里，输入如下语句</p><p><code>npm run serve</code></p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-4.jpg" alt=""></p><p>当出现上述画面时，我们就成功的初始化了一个Vue项目，在浏览器中进行cmd所提供网址的输入，就能看我Vue项目的初始化网页啦！</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-5.jpg" alt=""></p><h3 id="Vue项目的文件结构"><a href="#Vue项目的文件结构" class="headerlink" title="Vue项目的文件结构"></a>Vue项目的文件结构</h3><p><img src= "/img/loading.gif" data-src="/photo/VUE2-6.jpg" alt=""></p><p><strong>node_modules</strong>    项目依赖模块</p><p><strong>src</strong>    这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</p><ul><li>assets    放置一些图片，如logo等。</li><li>components    用于存放Vue组件</li><li>App.vue    项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</li></ul><p><strong>main.js</strong>    项目的核心文件。</p><p><strong>.gitignore</strong>    用于上传到git时配置的忽视项目</p><p><strong>package.json</strong>    项目配置文件。</p><p><strong>README.md</strong>    项目的说明文档，markdown 格式</p><p>上面我们提到了一个概念：Vue组件，那么什么是Vue组件呢。Vue采用了组件化开发的形式，我们可以自定义多种多样的Vue组件，每个Vue组件代表了不同的功能，我们可以将这些Vue组件进行复用和组合。</p><h3 id="Vue项目的更改"><a href="#Vue项目的更改" class="headerlink" title="Vue项目的更改"></a>Vue项目的更改</h3><p>那么我们应该如何将这一个Vue项目变成我们自己的呢？我们只需要在App.vue上进行修改即可（至于Vue是如何把App.vue挂钩到index文件上这点大家可以去查阅文档或视频了解，但初学者一般不需要了解的这么深入，如何应用框架解决问题才是我们学习的重点）</p><p>App.vue文件分为了三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 网页模板，编写HTML文件,只能存在一个标签 --&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js App&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;JavaScript代码</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;*CSS代码*&#x2F;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>所以我们只需要在里面进行修改，就可以转成我们自己的项目</p><p>Eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;tit&quot;&gt;&#123;&#123;messgae&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div class&#x3D;&#39;num&#39;&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;reduce&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;&#x2F;&#x2F;要注意的是，在Vue组件中我们写data的方法和引入Vue.js文件写法是不一样的噢</span><br><span class="line">    return&#123;</span><br><span class="line">      messgae:&quot;Hello Vue!&quot;,</span><br><span class="line">      num:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    reduce()&#123;</span><br><span class="line">      this.num--;</span><br><span class="line">    &#125;,</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.tit&#123;</span><br><span class="line">  color: red;</span><br><span class="line">  margin: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.num&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.num button&#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  margin:0 20px; </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-7.jpg" alt=""></p><hr><p>以上就是本篇博客的全部内容啦，感谢您的阅读！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客我们来讲如何初始化一个Vue项目，需要特别说明一下的是，Vue.js入门系列博客讲的都是Vue2的语法内容，其实此时Vue3.0已经正式发布有一年多的时间了，但鉴于目前大多数项目都还是由Vue2进行编写，我还是决定从Vue2学起，但其实掌握了Vue2，上手Vue3也
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js入门 I:Hello Vue!</title>
    <link href="http://yoursite.com/2021/10/06/Vue-js%E5%85%A5%E9%97%A8-I-Hello-Vue/"/>
    <id>http://yoursite.com/2021/10/06/Vue-js%E5%85%A5%E9%97%A8-I-Hello-Vue/</id>
    <published>2021-10-06T07:05:57.000Z</published>
    <updated>2021-11-02T06:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>那么终于，历经了一路HTML、CSS与JS的复习之后，终于要进入Vue.js的学习了，这一路磕磕碰碰的完全就是从考研当中硬挤时间来学技术…想想之前的学习路线规划完全错误，真的应该早点学习技术的。算辽，种一棵树最好的时间是十年前，其次是现在，话不多说，我们开始Vue.js的学习！</p><hr><h3 id="Vue-js是什么？"><a href="#Vue-js是什么？" class="headerlink" title="Vue.js是什么？"></a>Vue.js是什么？</h3><p>学一个东西，我们最首先要了解这个东西是什么。就像我们知道HTML是用来创建网页，CSS是用来美化网页，JavaScript是用来修改网页的数据一样，那么Vue.js是什么？老实说，这一开始困扰了我。</p><p>Vue的官方文档给这个问题下了如下定义：</p><blockquote><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><p>我一看，黑人问号脸？？？</p><p>怎么每个字都认识，组合在一起我就不认识了。</p><p>于是我翻遍了网上一系列课程，终于是看到的比较通俗易懂的解释：</p><p>Vue的渐进式指的是其可以自底向上逐层应用，意思就是对于小的应用，我们只需要引入一个轻量小巧的核心库，而对于复杂大型的应用，我们可以引入各种各样的Vue插件，来达到所谓“渐进式”的效果。</p><p>JavaScript框架，指以Javascript语言为基础搭建的编程框架，意思就是我们可以通过Vue来实现JS中的各种操作。</p><p>那么了解完了Vue.js是什么，就让我们开始试着写Vue的第一个程序吧！</p><h3 id="Hello-Vue！"><a href="#Hello-Vue！" class="headerlink" title="Hello Vue！"></a>Hello Vue！</h3><p>话不多说，上代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:&#39;.app&#39;,&#x2F;&#x2F;挂载实例，可以是DOM元素、CSS选择器、HTML标签</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#39;Hello Vue!&#39;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-1.jpg" alt=""></p><p>可以看到，通过Vue.js框架最大的特点就是我们简化了DOM的操作，以前我们要修改文本的数据，可能就要先通过DOM获取h1标签，再通过InnerHTML进行修改，而通过Vue.js我们就省略了这些繁琐的步骤，每当我们想修改message的值时只需要修改data里的值即可</p><h3 id="绑定属性与事件"><a href="#绑定属性与事件" class="headerlink" title="绑定属性与事件"></a>绑定属性与事件</h3><p>那么我们有没有办法通过Vue.js来绑定HTML标签的属性以及为元素绑定事件呢？当然是可以的</p><p>我们<strong>通过v-bind和v-on分别来绑定属性和事件</strong></p><p>v-bind:直接跟在所需要绑定的属性前面，可简写为:</p><p>v-on:后需添加事件的名称，可简写为@</p><p>下面是通过点击按钮切换图片的一个小栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .app img&#123;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;img v-bind:src&#x3D;&quot;url&quot;&gt;      &lt;!-- 可简写为&lt;img :src&#x3D;&quot;url&quot;&gt;  --&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;change&quot;&gt;更换图片&lt;&#x2F;button&gt;        &lt;!-- 可简写为&lt;button @click&#x3D;&quot;change&quot;&gt;  --&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:&#39;.app&#39;,</span><br><span class="line">            data:&#123;          &#x2F;&#x2F;用于存数据</span><br><span class="line">                message:&#39;Hello Vue!&#39;,</span><br><span class="line">                url:&#39;img&#x2F;1.jpg&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;       &#x2F;&#x2F;用户写方法</span><br><span class="line">                change()&#123;</span><br><span class="line">                    if(this.url&#x3D;&#x3D;&quot;img&#x2F;1.jpg&quot;)</span><br><span class="line">                        this.url&#x3D;&quot;img&#x2F;2.jpg&quot;;</span><br><span class="line">                    else</span><br><span class="line">                        this.url&#x3D;&quot;img&#x2F;1.jpg&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-2.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-3.jpg" alt=""></p><hr><p>以上就是Vue.js的第一篇入门博客，当然讲的很浅，里面很多东西都会在后续的更新中进行扩展，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;那么终于，历经了一路HTML、CSS与JS的复习之后，终于要进入Vue.js的学习了，这一路磕磕碰碰的完全就是从考研当中硬挤时间来学技术…想想之前的学习路线规划完全错误，真的应该早点学习技术的。算辽，种一棵树最好的时间是十年前，其次是现在，话不多说，我们开始Vue.js的学
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法:查找II-哈希表</title>
    <link href="http://yoursite.com/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BEII-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BEII-%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-09-28T14:09:15.000Z</published>
    <updated>2021-09-29T14:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇博客，我们将迎来数据结构与算法系列博客的最后一个内容——哈希表</p><hr><h3 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h3><p>哈希表（Hash table，也叫散列表），是根据关键字（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个<strong>映射函数称做哈希（散列）函数</strong>，<strong>存放记录的数组称做哈希（散列）表</strong>。哈希冲突指的是两个或两个以上的不同关键字映射到同一地址，这种情况我们称为<strong>冲突</strong>，而发生冲突的不同关键字叫做<strong>同义词</strong>。</p><p>其实哈希表本质上就是一个数组，只不过我们通过各种映射手段，让这个数组不一般了起来。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>那么我们如何构造关键字与地址的映射呢？通常有以下几种方法（以下摘自百科）</p><p><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p><p><strong>数字分析法</strong>：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><p><strong>平方取中法</strong>：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p><p><strong>除留余数法</strong>：最常用的一种方法，取关键字除以某个不大于散列表表长的数p后所得的余数为散列地址。即 H(key) = key MOD p，一般P取不大于表长的最大素数，这样可以减少冲突。</p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>在Hash表中遇到冲突是在正常不过了，那么我们该如何处理这些冲突呢？通常有以下几种方法</p><p><strong>开放寻址法</strong>：$H_i=(H(key) + d_i) MOD P,i=1,2，…，k(k&lt;=m-1）$，其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：</p><ul><li>$di=1,2,3，…，m-1$，称线性探测法</li><li>$di=1^2,-1^2,2^2,-2^2，3^2，-3^2…，±k^2,(k&lt;=m/2）$称平方探测法</li><li>$di=伪随机数序列$，称伪随机探测法</li></ul><p><strong>再散列法</strong>：即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p><p><strong>链地址法（拉链法）</strong>：即在映射地址下构建链表，若有新的同义词则接到该链表后面</p><p><img src= "/img/loading.gif" data-src="/photo/SH2-1.jpg" alt=""> </p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>哈希表的实现有多种方式，这里提供一个用除留余数法并用线性探测法解决冲突的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 11<span class="comment">//一般P取不大于表长的最大素数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> elem[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> count;<span class="comment">//当前元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHash</span><span class="params">(HashTable &amp;ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">ht.elem[i] = <span class="number">-1</span>;</span><br><span class="line">ht.count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertHash</span><span class="params">(HashTable &amp;ht,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr = key % P;</span><br><span class="line"><span class="keyword">if</span> (ht.elem[addr] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mark = addr;</span><br><span class="line"><span class="keyword">int</span> temp = key + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">addr = temp % P;<span class="comment">//开放定址法中的线性探测法上</span></span><br><span class="line">temp++;</span><br><span class="line">&#125; <span class="keyword">while</span> (ht.elem[addr] &gt; <span class="number">0</span> &amp;&amp; mark != addr);</span><br><span class="line"><span class="keyword">if</span> (mark == addr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ht.elem[addr] = key;</span><br><span class="line">ht.count++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTable</span><span class="params">(HashTable ht, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr = key % P;</span><br><span class="line"><span class="keyword">if</span> (ht.elem[addr] != key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mark = addr;</span><br><span class="line"><span class="keyword">int</span> temp = key + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">addr = temp % P;<span class="comment">//开放定址法</span></span><br><span class="line">temp++;</span><br><span class="line">&#125; <span class="keyword">while</span> (ht.elem[addr] !=key &amp;&amp; mark != addr &amp;&amp; ht.elem[addr] != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (mark == addr|| ht.elem[addr]==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteElem</span><span class="params">(HashTable &amp;ht, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=SearchTable(ht, key);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ht.elem[res] = <span class="number">-1</span>;</span><br><span class="line">ht.count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> &#125;;</span><br><span class="line">HashTable ht;</span><br><span class="line">InitHash(ht);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">InsertHash(ht, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> res = SearchTable(ht, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1的位置是："</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DeleteElem(ht, <span class="number">7</span>);</span><br><span class="line">InsertHash(ht, <span class="number">12</span>);</span><br><span class="line">res=SearchTable(ht, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"12的位置是："</span> &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/SH2-2.jpg" alt=""> </p><hr><p>以上，就是数据结构与算法系列博客的全部内容啦！</p><p>当然不排除后面还会进行一些补充，那就有缘再会咯~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本篇博客，我们将迎来数据结构与算法系列博客的最后一个内容——哈希表&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;哈希表的定义&quot;&gt;&lt;a href=&quot;#哈希表的定义&quot; class=&quot;headerlink&quot; title=&quot;哈希表的定义&quot;&gt;&lt;/a&gt;哈希表的定义&lt;/h3&gt;&lt;p&gt;哈希表（Has
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
