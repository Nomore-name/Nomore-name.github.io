<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K`onnor</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-28T08:18:14.714Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KangKang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的移动语义</title>
    <link href="http://yoursite.com/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    <id>http://yoursite.com/2022/03/26/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</id>
    <published>2022-03-26T03:09:02.000Z</published>
    <updated>2022-03-28T08:18:14.714Z</updated>
    
    <content type="html"><![CDATA[<p>右值引用和移动语义作为C++11新引入的特性，也是很多面试必问的一个问题，那就跟随这篇博客一起来看一下吧</p><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>左值（lvalue）、右值（rvalue）这样的概念想必大家都有听过。一个最为典型的判别方法就是，在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。但是这种分辨方法其实是很笼统的，因为左值也可以出现在等号的右边。所以C++中还有一个被广泛认同的说法，那就是<strong>可以取地址的就是左值</strong>，反之，不能取地址的就是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a = a + b;</span><br></pre></td></tr></table></figure><p>比如在这个加法赋值表达式中，a就是一个左值，而b + c则是一个右值，&amp;a是允许的操作，但&amp;(b + c)这样的操作则不会通过编译。因此a是一个左值，(b + c)是一个右值。</p><p>相对于左值，<strong>右值表示字面常量、表达式、函数的非引用返回值等</strong>。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>在C++11之前，我们只能对左值建立引用，或者通过常量引用来绑定右值，C++11引入了右值引用，使我们可以绑定右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 左值引用绑定到右值，编译失败, err</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// 非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// 常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = d; <span class="comment">// 常量左值引用绑定到常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">2</span>; <span class="comment">// 常量左值引用绑定到右值，编程通过, ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*右值引用*/</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</span><br></pre></td></tr></table></figure><p><code>const typename &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>那么C++11引入右值引用是要做什么呢，其目的是为了实现移动语义。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。</p><p>在没有移动语义之前，C++中的类有<strong>拷贝构造函数</strong>和<strong>赋值构造函数</strong>，程序会经常生成临时对象，大量的临时对象的创建于析构会严重影响程序性能，有了移动语义，我们可以定义<strong>移动构造函数</strong>和<strong>移动赋值构造函数</strong>，将原有的对象移动原对象到新对象上，达到节约资源的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyString(<span class="keyword">const</span> <span class="keyword">char</span> *tmp = <span class="string">"abc"</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"普通构造函数 str = "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString(<span class="keyword">const</span> MyString &amp;tmp)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">len = tmp.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数 tmp.str = "</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> MyString &amp;tmp)<span class="comment">//赋值构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[]str;<span class="comment">//先释放原来的内存</span></span><br><span class="line"></span><br><span class="line">len = tmp.len;<span class="comment">//重新申请内容</span></span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"赋值构造函数 tmp.str = "</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~MyString()<span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数: "</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"已操作delete, str =  "</span> &lt;&lt; str;</span><br><span class="line"><span class="keyword">delete</span>[]str;</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未进行真正析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">"mike"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms = func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如在上面的程序里，C++要原本做各做三次的构造与析构函数（在vs2017里编译器会优化到各两次），十分影响性能</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-1.jpg" alt=""> </p><p>有了移动语义后，我们可以这么定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyString(MyString &amp;&amp; t)<span class="comment">//移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">    len = t.len;</span><br><span class="line"></span><br><span class="line">    t.str = <span class="literal">NULL</span>;<span class="comment">//原来指针置空，防止真析构</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/photo/CMV1-2.jpg" alt=""> </p><p>定义移动构造函数后，编译器就会自动帮我们调用移动构造函数，要注意移动构造函数中一定要<strong>把原对象的地址设为空</strong>。因为我们将新对象指向了原对象的地址，如果不置为空的话，就会导致析构函数将原对象地址析构掉，导致程序出错。</p><p>移动赋值构造函数也是同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyString &amp;<span class="keyword">operator</span>= (MyString &amp;&amp;tmp)<span class="comment">//移动赋值构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">delete</span>[]str;<span class="comment">//先释放原来的内存</span></span><br><span class="line"></span><br><span class="line">    len = tmp.len;</span><br><span class="line">    str = tmp.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line"></span><br><span class="line">    tmp.str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移动赋值构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms1("Kang"),ms2;</span><br><span class="line">ms2 = ms1;</span><br><span class="line">ms2 = func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/photo/CMV1-3.jpg" alt=""> </p><h3 id="move的使用"><a href="#move的使用" class="headerlink" title="move的使用"></a>move的使用</h3><p>move是C++标准库中的一个函数，它的作用就是将一个左值转换为右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyString ms1("Kang"),ms2;</span><br><span class="line">ms2 = <span class="built_in">move</span>(ms1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-4.jpg" alt=""> </p><h3 id="forward的使用"><a href="#forward的使用" class="headerlink" title="forward的使用"></a>forward的使用</h3><p>forward被称为完美转发，它的作用是保持原来的参数属性不变。啥意思呢？如果我们调用一个函数传入一个右值，并在该函数里调用其它函数并同样传入该值，此时该值可能就会变成左值。通俗的讲就是，如果原来的值是左值，经forward处理后该值还是左值；如果原来的值是右值，经forward处理后它还是右值。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"左值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printType</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"右值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printType(t);</span><br><span class="line">printType(forward&lt;T&gt;(t));</span><br><span class="line">printType(<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">1</span>;</span><br><span class="line">useForward(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">useForward(lv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CMV1-5.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，感谢您的观看~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;右值引用和移动语义作为C++11新引入的特性，也是很多面试必问的一个问题，那就跟随这篇博客一起来看一下吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;左值与右值&quot;&gt;&lt;a href=&quot;#左值与右值&quot; class=&quot;headerlink&quot; title=&quot;左值与右值&quot;&gt;&lt;/a&gt;左值与右值&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="移动语义" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
    
      <category term="左值右值" scheme="http://yoursite.com/tags/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"/>
    
      <category term="完美转发" scheme="http://yoursite.com/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++中的智能指针</title>
    <link href="http://yoursite.com/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/03/25/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-03-25T07:48:31.000Z</published>
    <updated>2022-03-28T12:25:13.761Z</updated>
    
    <content type="html"><![CDATA[<p>智能指针可以说是面试中逃不掉的一个必问问题，但一直对这一块了解的不够彻底，就做个笔记记录一下吧</p><hr><h3 id="C-为什么要有智能指针"><a href="#C-为什么要有智能指针" class="headerlink" title="C++为什么要有智能指针"></a>C++为什么要有智能指针</h3><p> C++支持动态内存分配，也就是我们平常用的new和malloc，但是在使用过程中，我们往往会忘记在结束时调用delete和free进行内存释放，这就导致了内存泄漏这样的事情发生。因此C++引入了智能指针，它可以负责自动释放所指向的对象，可以很好地避免忘记释放内存而导致内存泄漏问题出现。</p><p>C++ 智能指针底层是采用<strong>引用计数</strong>的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值-1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><p>当然，智能指针是C++中的一个难点，这里推荐一篇博客，讲述了C++智能指针的演化历史，有兴趣可以前去看看：<a href="http://avdancedu.com/9683d88/" target="_blank" rel="noopener">http://avdancedu.com/9683d88/</a></p><p>下面简单介绍C++11中引入的三种智能指针的使用</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr持有对对象的独有权，同一时刻只能有一个unique_ptr指向给定对像，unique_ptr中没有赋值构造函数和拷贝构造函数，只有移动构造函数，目的就是为了有一个对象拥有unique_ptr</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p1 = <span class="number">666</span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u1</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; u2 = u1;//无法直接赋值</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; u2(u1);//无法直接拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u2</span><span class="params">(<span class="built_in">move</span>(u1))</span></span>;<span class="comment">//可进行移动构造，原u1指向的地址会被置空</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *u1 &lt;&lt; endl;//无法读取</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *u2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-1.jpg" alt=""> </p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr允许多个该智能指针共享“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~Entity()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"析构！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* p1 = <span class="keyword">new</span> Entity;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u1</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Entity&gt; u2 = u1;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u3</span><span class="params">(u1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Entity&gt; <span class="title">u4</span><span class="params">(<span class="built_in">move</span>(u1))</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u3.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u4.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-2.jpg" alt=""> </p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作（因为shared_ptr在实现互指的时候会出现内存泄漏的情况），它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。weak_ptr没有重载 * 和 -&gt; ，但可以使用lock获得一个可用的shared_ptr对象</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(weak_ptr&lt;<span class="keyword">int</span>&gt; &amp;wp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = wp.lock(); <span class="comment">// 转换为shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Num is "</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">666</span>))</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp1; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">check(wp);  </span><br><span class="line"></span><br><span class="line">sp1.reset();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">check(wp); </span><br><span class="line"></span><br><span class="line">sp2.reset();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">check(wp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CS1-3.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，智能指针其实是一个蛮不好理解的知识点，我这里也只是非常简单的讲了一些，具体大家还是去网上查阅大牛的资料才能有更深刻的理解~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;智能指针可以说是面试中逃不掉的一个必问问题，但一直对这一块了解的不够彻底，就做个笔记记录一下吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;C-为什么要有智能指针&quot;&gt;&lt;a href=&quot;#C-为什么要有智能指针&quot; class=&quot;headerlink&quot; title=&quot;C++为什么要有智能
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="智能指针" scheme="http://yoursite.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换运算符</title>
    <link href="http://yoursite.com/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-03-21T04:28:56.000Z</published>
    <updated>2022-03-21T08:04:22.428Z</updated>
    
    <content type="html"><![CDATA[<p>本章记录一下C++中四种类型转换</p><hr><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>使用C风格的类型转换可以把想要的任何东西转换成我们需要的类型，但是这种类型转换太过松散，对于这种松散的情况，C++提供了更严格的类型转换，可以提供更好的控制转换过程，并添加4个类型转换运算符，使转换过程更规范:</p><ul><li>static_cast</li><li>dynamic_cast</li><li>const_cast</li><li>reinterpret_cast</li></ul><p>以下进行具体的介绍</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>可用于类层次结构中<strong>基类和派生类之间指针或引用的转换</strong>和<strong>基本数据类型之间的转换</strong></p><p>其中进行上行转换 （把派生类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类指针或引用转换成派生类表示)时，由于没有动态类型检查，所以是不安全的</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span><span class="keyword">public</span> Person&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pi);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Person *p1=<span class="literal">nullptr</span>,*p2 = <span class="literal">nullptr</span>;</span><br><span class="line">Man *m1 = <span class="literal">nullptr</span>,*m2 = <span class="literal">nullptr</span>;</span><br><span class="line">p1 = <span class="keyword">static_cast</span>&lt;Person*&gt;(m1);<span class="comment">//子转父，安全，引用同理</span></span><br><span class="line">m2 = <span class="keyword">static_cast</span>&lt;Man*&gt;(p2);<span class="comment">//父转子，不安全 ，引用同理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CCT1-1.jpg" alt=""> </p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>dynamic_cast主要用于类层次间的上行转换和下行转换，其不支持数据类型转换，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span><span class="keyword">public</span> Person&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Wow~"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//int a = dynamic_cast&lt;int&gt;(pi);//报错，动态多态不支持类型转换</span></span><br><span class="line">    </span><br><span class="line">    Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">Man *m = <span class="keyword">new</span> Man;</span><br><span class="line">Animal *a = <span class="keyword">new</span> Animal;</span><br><span class="line">Tiger *t = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">p = <span class="keyword">dynamic_cast</span>&lt;Person*&gt;(m);<span class="comment">//子转父，编译正常</span></span><br><span class="line"><span class="comment">//m = dynamic_cast&lt;Man*&gt;(p);//报错，动态转换不支持没有多态的父转子</span></span><br><span class="line">t = <span class="keyword">dynamic_cast</span>&lt;Tiger*&gt;(a);<span class="comment">//包含多态的父转子，编译正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast主要是用来去掉<strong>引用和指针</strong>的const属性，当然也可以加上const属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *np = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(p);<span class="comment">//常量指针转非常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pp = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(np);<span class="comment">//非常量指针转常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cnum = num;</span><br><span class="line"><span class="keyword">int</span> &amp;inum = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(cnum);<span class="comment">//引用同理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast是四种强制转换中功能最为强大的，它可以暴力完成<strong>两个完全无关类型的指针之间或指针和数</strong>之间的互转，比如用char类型指针指向double值。它对原始对象的位模式提供较低层次上的重新解释（即reinterpret），完全复制二进制比特位到目标对象，转换后的值与原始对象无关但比特位一致，前后无精度损失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> *b = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(a);<span class="comment">//double*转int*，不会报错</span></span><br><span class="line"></span><br><span class="line">Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">Man *m = <span class="keyword">new</span> Man;</span><br><span class="line">Tiger *t = <span class="literal">nullptr</span>;</span><br><span class="line">m = <span class="keyword">reinterpret_cast</span>&lt;Man*&gt;(p);</span><br><span class="line">t = <span class="keyword">reinterpret_cast</span>&lt;Tiger*&gt;(m);<span class="comment">//两种不同类指针的转换，也不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是C++的四种类型转换简单介绍，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章记录一下C++中四种类型转换&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;类型转换运算符&quot;&gt;&lt;a href=&quot;#类型转换运算符&quot; class=&quot;headerlink&quot; title=&quot;类型转换运算符&quot;&gt;&lt;/a&gt;类型转换运算符&lt;/h3&gt;&lt;p&gt;使用C风格的类型转换可以把想要的任何东西转
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="类型转换" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL:set、map、stack、queue的基本使用</title>
    <link href="http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-10T08:07:30.000Z</published>
    <updated>2022-03-22T08:32:37.532Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器</p><hr><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>关联式容器在存储元素值时会<strong>为各元素额外再配备一个值，又称为“键”</strong>，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><p>关联式容器<strong>可以快速查找、读取或者删除所存储的元素</strong>，同时该类型容器<strong>插入元素的效率也比序列式容器高</strong>。</p><p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，<strong>而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</strong>。</p><ul><li><strong>map</strong>    定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根<strong>据各元素键的大小，默认进行升序排序</strong>（调用 std::less<T>）</li><li><strong>multimap</strong>    定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复</li><li><strong>set</strong>    定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个<strong>元素的键的大小进行升序排序</strong>（调用 std::less<T>）</li><li><strong>multiset</strong>    定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）</li></ul><h3 id="pair对组"><a href="#pair对组" class="headerlink" title="pair对组"></a>pair对组</h3><p>在正式介绍关联式容器之前，先介绍一下对组pair，对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问</p><p>类模板：template <class T1, class T2> struct pair. </p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; pair1(string("year"), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.first&lt;&lt; <span class="built_in">endl</span>;                 <span class="comment">//访问pair第一个值 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//访问pair第二个值 </span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = make_pair(<span class="string">"name"</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3 = pair2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-5.jpg" alt=""> </p><h3 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a><strong>set/multiset容器</strong></h3><p>set的特性是：所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值，所以我们无法通过set的迭代器改变set元素的值吗，set不允许两个元素有相同的键值。</p><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。<strong>set和multiset的底层实现是红黑树</strong>，红黑树为平衡二叉树的一种。  </p><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><ul><li>set<T> st;                <strong>//set默认构造函数</strong></li><li>mulitset<T> mst;                 <strong>//multiset默认构造函数</strong></li><li>set(const set &amp;st);                <strong>//拷贝构造函数</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line">s.insert(<span class="number">1</span>);</span><br><span class="line">ms.insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-1.jpg" alt=""> </p><h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><ul><li>set&amp; operator=(const set &amp;st);                <strong>//重载等号操作符</strong> </li><li>swap(st);                <strong>//交换两个集合容器</strong></li></ul><h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><ul><li>size();                <strong>//返回容器中元素的数目</strong> </li><li>empty();                <strong>//判断容器是否为空</strong></li></ul><h4 id="set数据操作"><a href="#set数据操作" class="headerlink" title="set数据操作"></a>set数据操作</h4><ul><li>insert(elem);                <strong>//在容器中插入元素</strong></li><li>clear();                <strong>//清除所有元素</strong>  </li><li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong></li><li>erase(beg, end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li><li>erase(elem);                <strong>//删除容器中值为elem的元素</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line">s.insert(<span class="number">1</span>);</span><br><span class="line">ms.insert(<span class="number">1</span>);</span><br><span class="line">s.erase(++s.<span class="built_in">begin</span>(), --s.<span class="built_in">end</span>());</span><br><span class="line">ms.erase(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-2.jpg" alt=""> </p><h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><ul><li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()</strong></li><li>count(key);                <strong>//查找键key的元素个数</strong>  </li><li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li><li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li><li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">ms.insert(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> st1 = s.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">auto</span> st2 = s.lower_bound(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span> st3 = s.upper_bound(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">auto</span> st4 = s.equal_range(<span class="number">6</span>);<span class="comment">//pair类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st3 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st4.first &lt;&lt; *st4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-3.jpg" alt=""> </p><h4 id="set排序方式的修改"><a href="#set排序方式的修改" class="headerlink" title="set排序方式的修改"></a>set排序方式的修改</h4><p>我们可以通过结构体重载（）来修改set原有的排序方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mycmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;<span class="comment">//从大到小进行排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, Mycmp&gt; s2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">s.insert(i);</span><br><span class="line">s2.insert(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> st = s2.<span class="built_in">begin</span>(); st != s2.<span class="built_in">end</span>(); ++st)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-4.jpg" alt=""> </p><h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。  </p><p>Multimap和map的操作类似，唯一区别multimap键值可重复。 </p><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><ul><li>map<T1, T2> mapTT;                <strong>//map默认构造函数</strong></li><li>map(const map &amp;mp);                <strong>//拷贝构造函数</strong></li></ul><h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><ul><li>map&amp; operator=(const map &amp;mp);                <strong>//重载等号操作符</strong> </li><li>swap(mp);                <strong>//交换两个集合容器</strong></li></ul><h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><ul><li>size();        <strong>//返回容器中元素的数目</strong> </li><li>empty();        <strong>//判断容器是否为空</strong></li></ul><h4 id="map数据操作"><a href="#map数据操作" class="headerlink" title="map数据操作"></a>map数据操作</h4><ul><li>insert();                 <strong>//往容器插入元素，返回pair<iterator,bool></strong> </li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str[<span class="number">4</span>] = &#123; <span class="string">"kk"</span>,<span class="string">"pp"</span>,<span class="string">"zz"</span>,<span class="string">"oo"</span> &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; pr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pr[i] = make_pair(i, str[i]);</span><br><span class="line">mp.insert(pr[i]);</span><br><span class="line">&#125;</span><br><span class="line">mp.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"dd"</span>));</span><br><span class="line">mp.insert(make_pair(<span class="number">5</span>, <span class="string">"vv"</span>));</span><br><span class="line">mp[<span class="number">6</span>] = <span class="string">"nn"</span>;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="string">"mm"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> mt = mp.<span class="built_in">begin</span>(); mt != mp.<span class="built_in">end</span>(); ++mt)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mt-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mt-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL2-6.jpg" alt=""> </p><h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><ul><li>clear();                <strong>//删除所有元素</strong>  </li><li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong> </li><li>erase(beg,end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li><li>erase(keyElem);                <strong>//删除容器中key为keyElem的对组</strong></li></ul><h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><ul><li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end()</strong></li><li>count(keyElem);                <strong>//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1</strong></li><li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li><li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li><li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li></ul><p>由于这些操作和set大同小异，故在此不提供例子</p><h4 id="常见的map问题"><a href="#常见的map问题" class="headerlink" title="常见的map问题"></a>常见的map问题</h4><p><strong>1.set map的区别与联系</strong></p><p> 联系：1.Map,Set属于标准关联容器，底层数据结构使用红黑树</p><p>2.时间复杂度均为红黑树的时间复杂度，插入删除查找近似为O(logN)</p><p>区别：</p><p><strong>1.适用对象</strong><br>map适合存储一个数据字典，并要求方便地根据key找value<br>set适合查找一个元素是否在某集合内存中</p><p><strong>2.存储方式</strong><br>Set节点只含有Key，Key不重复.<br>Map节点有一个Key和Value两个元素,Key不重复,Value可以不重复。</p><p> <strong>3.元素改变</strong><br>set不能直接改变元素值。因为这样会打乱原有的顺序。改变元素值的方法是：先删除旧元素，再插入新元素。存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。<br>map可以通过key改变value的值</p><p><strong>2.map list 的使用场景与优势对比</strong></p><p>Map适用：是为了更快的从关键字查找到相关的对象。 </p><p>与使用list这样的线性表容器相比：一可以简化查找的算法，二可以使任意的关键字做索引，并与目标对象配对，优化查找算法。</p><p>在C++的STL中map是使用树来做查找算法，这种算法差不多相当与list线性容器的折半查找的效率一样，都是O (log2N)，而list就没有map这样易定制和操作了。</p><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。</p><ul><li>stack<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入后出</strong>（Last-In-First-Out，LIFO）的压入栈</li><li>queue<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入先出</strong>（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器</li><li>priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而<strong>保证最大元素总在队列最前面</strong>的队列</li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack就是数据结构中的栈，关于栈的详细介绍可看我《数据结构与算法:栈I/II/III/IV》四篇博客，这里不多加赘述，以下是常见操作</p><ul><li>stack<T> stkT;                <strong>//stack采用模板类实现， stack对象的默认构造形式</strong> </li><li>stack(const stack &amp;stk);                <strong>//拷贝构造函数</strong></li><li>stack&amp; operator=(const stack &amp;stk);                <strong>//重载等号操作符</strong></li><li>push(elem);                <strong>//向栈顶添加元素</strong> </li><li>pop();                <strong>//从栈顶移除第一个元素</strong> </li><li>top();                <strong>//返回栈顶元素</strong></li><li>empty();                <strong>//判断堆栈是否为空</strong> </li><li>size();                <strong>//返回堆栈的大小</strong></li></ul><p>都很简单，也不提供例子了，注意的是，stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素才有<br>机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue就是数据结构中的队列，关于队列的详细介绍可看我《数据结构与算法:队列I/II》两篇博客，这里不多加赘述，以下是常见操作</p><ul><li>queue<T> queT;                <strong>//queue采用模板类实现，queue对象的默认构造形式</strong></li><li>queue(const queue &amp;que);                <strong>//拷贝构造函数</strong></li><li>push(elem);                <strong>//往队尾添加元素</strong> </li><li>pop();                <strong>//从队头移除第一个元素</strong> </li><li>back();                <strong>//返回最后一个元素</strong> </li><li>front();                <strong>//返回第一个元素</strong></li><li>queue&amp; operator=(const queue &amp;que);                <strong>//重载等号操作符</strong></li><li>empty();                <strong>//判断队列是否为空</strong> </li><li>size();                <strong>//返回队列的大小</strong></li></ul><p>都很简单，也不提供例子了，同样的，队列也是不提供迭代器的</p><p>而priority_queue的基础用法和queue一样，在《记录备战CSP中刷到一些有意思的题目I》中的第一题就用到了priority_queue，并对其排序方法进行了重写，想了解的可以去看看</p><hr><p>以上就是我们的C++中STL的基本常用容器介绍啦，在C++11后还引入了无序容器（哈希容器），后续有机会再更新关于这系列的博客~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;关联式容器&quot;&gt;&lt;a href=&quot;#关联式容器&quot; class=&quot;headerlink&quot; title=&quot;关联式容器&quot;&gt;&lt;/a&gt;关联式容器&lt;/h2&gt;&lt;p&gt;关联式容器在存储
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="queue" scheme="http://yoursite.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL:vector、list、deque的基本使用</title>
    <link href="http://yoursite.com/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-09T08:26:30.000Z</published>
    <updated>2022-03-22T07:57:12.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近在准备春招的，正好复习到STL的使用，才想起还有这么一个博客的坑没填，就趁这次把它补充完吧~</p><hr><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>所谓序列容器，即以线性排列(类似普通数组的存储方式）来存储某一指定类型(例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p><p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p><ul><li><strong>array<T,N>(数组容器）：</strong>表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li><strong>vector<T>(向量容器）：</strong>用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高(时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差(时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li><strong>deque<T>(双端队列容器）：</strong>和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li><strong>list<T>(链表容器）：</strong>是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素(时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li><strong>forward_list<T>(正向链表容器）：</strong>和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><p><em>其实除此之外，stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到下一篇博客中。</em></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector其实在《From C to C++ III:动态内存分配及向量》一篇博客中就有提及，这次就进行一个完整的整理</p><h4 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h4><p>vector有四种构造函数，分别是</p><ul><li>vector<T> v;         <strong>//采用模板实现类实现，默认构造函数</strong>  </li><li>vector(v.begin(), v.end());        <strong>//将v[begin(), end()]区间中的元素拷贝给本身。</strong> </li><li>vector(n, elem);        <strong>//构造函数将n个elem拷贝给本身。</strong> </li><li>vector(const vector &amp;vec);        <strong>//拷贝构造函数。</strong> </li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v2.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v4.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-1.jpg" alt=""> </p><h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><ul><li>assign(beg, end];        <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong></li><li>assign(n, elem);        <strong>//将n个elem拷贝赋值给本身。 </strong></li><li>vector&amp;operator<strong>=(</strong>const vector &amp;vec);        <strong>//重载等号操作符</strong> </li><li>swap(vec);        <strong>// 将vec与本身的元素互换。</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ib = v2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ie = v2.<span class="built_in">end</span>();</span><br><span class="line">v2.assign(ib, ie);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v2.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.assign(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v4.swap(v3);<span class="comment">//可用于vector收缩内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v4.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-2.jpg" alt=""> </p><h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><ul><li>size();    <strong>//返回容器中元素的个数</strong> </li><li>empty();    <strong>//判断容器是否为空</strong> </li><li>resize(int num);    <strong>//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</strong></li><li>resize(int num, elem);    <strong>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除</strong></li><li>capacity();    <strong>//容器的容量</strong></li><li>reserve(int len);    <strong>//容器预留len个元素长度，预留位置不初始化，元素不可访问</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.resize(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v3.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">v3.resize(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v3.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v3.reserve(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 size:"</span> &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"V3 capacity:"</span> &lt;&lt; v3.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-3.jpg" alt=""> </p><h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><ul><li>at(idx);         <strong>//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常</strong></li><li>operator[];        <strong>//返回索引idx所指的数据，越界时，运行直接报错</strong> </li><li>front();        <strong>//返回容器中第一个数据元素</strong> </li><li>back();        <strong>//返回容器中最后一个数据元素</strong></li></ul><p>这个比较简单和常用，就不给例子了</p><h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><ul><li>insert(const_iterator pos, int count,ele);        <strong>//迭代器指向位置pos插入count个元素ele</strong></li><li>push_back(ele);         <strong>//尾部插入元素ele</strong> </li><li>pop_back();        <strong>//删除最后一个元素</strong>  </li><li>erase(const_iterator start, const_iterator end];        <strong>//删除迭代器从start到end之间的元素</strong> </li><li>erase(const_iterator pos);        <strong>//删除迭代器指向的元素</strong> </li><li>clear();        <strong>//删除容器中所有元素</strong></li></ul><p>这个也比较简单和常用，就不给例子了</p><h4 id="vector的常见问题"><a href="#vector的常见问题" class="headerlink" title="vector的常见问题"></a>vector的常见问题</h4><p><strong>1.vector的resize和reserve操作的区别</strong></p><p>resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。  </p><p>reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。</p><p><strong>2.当vector的内存用完了，它是如何动态扩展内存的？它是怎么释放内存的？用clear可以释放掉内存吗？</strong></p><p>vector内存用完了，会以当前size大小重新申请1.5倍或2倍的内存，然后把原来的元素复制过去，把新元素插上，然后释放原来的内存。<br>一般我们释放vector里的元素使用clear，其实它不能释放内存，要想释放内存要使用swap。</p><p><strong>3.vector中的size和capacity的区别</strong></p><p>size表示当前vector中有多少个元素，而capacity函数则表示它已经分配的内存中可以容纳多少元素。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间</p><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p>list<T> list;        <strong>//list采用采用模板类实现,对象的默认构造形式</strong></p><p>list(beg,end];        <strong>//构造函数将[beg, end]区间中的元素拷贝给本身</strong></p><p>list(n,elem);        <strong>//构造函数将n个elem拷贝给本身</strong></p><p>list(const list &amp;lst);        <strong>//拷贝构造函数</strong></p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l2.<span class="built_in">begin</span>(); it != l2.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-4.jpg" alt=""> </p><h4 id="list插入删除"><a href="#list插入删除" class="headerlink" title="list插入删除"></a>list插入删除</h4><ul><li>push_back(elem);                <strong>//在容器尾部加入一个元素</strong></li><li>pop_back();                <strong>//删除容器中最后一个元素</strong> </li><li>push_front(elem);                <strong>//在容器开头插入一个元素</strong> </li><li>pop_front();                <strong>//从容器开头移除第一个元素</strong> </li><li>insert(pos,elem);                <strong>//在pos位置插elem元素的拷贝，返回新数据的位置</strong></li><li>insert(pos,n,elem);                <strong>//在pos位置插入n个elem数据，无返回值</strong></li><li>insert(pos,beg,end];                <strong>//在pos位置插入[beg,end]区间的数据，无返回值</strong></li><li>clear();                <strong>//移除容器的所有数据</strong> </li><li>erase(beg,end];                <strong>//删除[beg,end]区间的数据，返回下一个数据的位置</strong></li><li>erase(pos);                <strong>//删除pos位置的数据，返回下一个数据的位置</strong></li><li>remove(elem);                <strong>//删除容器中所有与elem值匹配的元素</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line">l2.push_back(<span class="number">5</span>);</span><br><span class="line">l2.push_back(<span class="number">6</span>);</span><br><span class="line">l2.pop_back();</span><br><span class="line">l2.push_front(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l2.<span class="built_in">begin</span>(); it != l2.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator ie=l3.insert(l3.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ie &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l3.insert(++ie, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">l4.<span class="built_in">remove</span>(<span class="number">4</span>);</span><br><span class="line">l4.erase(l4.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-5.jpg" alt=""> </p><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><ul><li><p>size();                <strong>//返回容器中元素的个数</strong> </p></li><li><p>empty();                <strong>//判断容器是否为空</strong> </p></li><li><p>resize(num);                <strong>//重新指定容器的长度为num， 若容器变长，则以默认值填充新位置。  如果容器变短，则末尾超出容器长度的元素被删除</strong></p></li><li><p>resize(num, elem);                <strong>//重新指定容器的长度为num， 若容器变长，则以elem值填充新位置。  如果容器变短，则末尾超出容器长度的元素被删除</strong></p></li></ul><p>这个比较简单和常用，就不给例子了</p><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><ul><li><p>assign(beg, end];                <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong></p></li><li><p>assign(n, elem);                <strong>//将n个elem拷贝赋值给本身</strong> </p></li><li><p>list&amp; operator=(const list &amp;lst);                <strong>//重载等号操作符</strong> </p></li><li><p>swap(lst);                <strong>//将lst与本身的元素互换</strong></p></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l2(arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l3(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; l4(l2);</span><br><span class="line"></span><br><span class="line">l3.assign(arr, arr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l4.assign(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l4.<span class="built_in">begin</span>(); it != l4.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l1.swap(l2);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l1.<span class="built_in">begin</span>(); it != l1.<span class="built_in">end</span>(); ++it)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-6.jpg" alt=""> </p><h4 id="list数据操作"><a href="#list数据操作" class="headerlink" title="list数据操作"></a>list数据操作</h4><ul><li><p>front();                <strong>//返回第一个元素</strong></p></li><li><p>back();                <strong>//返回最后一个元素</strong></p></li><li><p>reverse();                <strong>//反转链表</strong></p></li><li><p>sort();                 <strong>//list排序</strong>  </p></li></ul><p>这个也比较简单和常用，就不给例子了</p><h4 id="vector-list的区别与联系"><a href="#vector-list的区别与联系" class="headerlink" title="vector list的区别与联系"></a>vector list的区别与联系</h4><p>答：联系：均为<strong>序列式容器</strong>，其中的元素不一定有序，但都可以被排序。</p><p>区别：</p><p>1.适用对象</p><ul><li>vector适用：对象数量变化少，简单对象，随机访问元素频繁</li><li>list适用：对象数量变化大，对象复杂，插入和删除频繁</li></ul><p>2.存储方式</p><ul><li>vector：连续的内存空间进行存储</li><li>list：非连续的内存空间进行存储</li></ul><p>3.时间复杂度</p><ul><li>vector： 随机读取O(1);中间位置插入和删除操作时间复杂度为O(N);尾部push_back, pop_back操作时间复杂度为O(1)</li><li>list： 随机读取O(n) ;插入O(1); 删除O(1)</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，时间复杂度为O(1)，而不擅长在序列中间添加或删除元素。</p><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><ul><li>deque<T> deq;                <strong>//默认构造形式</strong> </li><li>deque(beg, end];                <strong>//构造函数将[beg, end]区间中的元素拷贝给本身</strong></li><li>deque(n, elem);                <strong>//构造函数将n个elem拷贝给本身</strong></li><li>deque(const deque &amp;deq);                <strong>//拷贝构造函数</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d4[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-7.jpg" alt=""> </p><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><ul><li>assign(beg, end];                <strong>//将[beg, end]区间中的数据拷贝赋值给本身</strong> </li><li>assign(n, elem);                <strong>//将n个elem拷贝赋值给本身</strong>  </li><li>deque&amp; operator=(const deque &amp;deq);                 <strong>//重载等号操作符</strong>  </li><li>swap(deq);                <strong>// 将deq与本身的元素互换</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line">d2.assign(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d3.assign(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d3[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d4.swap(d3);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d4[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-8.jpg" alt=""> </p><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><ul><li>deque.size();                <strong>//返回容器中元素的个数</strong> </li><li>deque.empty();                <strong>//判断容器是否为空</strong>  </li><li>deque.resize(num);                <strong>//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</strong> </li><li>deque.resize(num, elem);                 <strong>//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除</strong></li></ul><p>例子略</p><h4 id="deque数据操作"><a href="#deque数据操作" class="headerlink" title="deque数据操作"></a>deque数据操作</h4><ul><li>push_back(elem);        <strong>//在容器尾部添加一个数据</strong> </li><li>push_front(elem);        <strong>//在容器头部插入一个数据</strong> </li><li>pop_back();        <strong>//删除容器最后一个数据</strong> </li><li>pop_front();        <strong>//删除容器第一个数据</strong></li><li>at(idx);                <strong>//返回索引idx所指的数据，如果idx越界，抛出out_of_range</strong></li><li>operator[];                <strong>//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错</strong></li><li>front();                <strong>//返回第一个数据</strong></li><li>back();                <strong>//返回最后一个数据</strong></li></ul><p>例子略</p><h4 id="deque插入删除"><a href="#deque插入删除" class="headerlink" title="deque插入删除"></a>deque插入删除</h4><ul><li>insert(pos,elem);                <strong>//在pos位置插入一个elem元素的拷贝，返回新数据的位置</strong></li><li>insert(pos,n,elem);                <strong>//在pos位置插入n个elem数据，无返回值</strong> </li><li>insert(pos,beg,end];                <strong>//在pos位置插入[beg,end]区间的数据，无返回值</strong></li><li>clear();                <strong>//移除容器的所有数据</strong>  </li><li>erase(beg,end];                <strong>//删除[beg,end]区间的数据，返回下一个数据的位置</strong></li><li>erase(pos);                <strong>//删除pos位置的数据，返回下一个数据的位置</strong></li></ul><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dt= d2.insert(d2.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *dt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">d2.insert(dt, arr, arr + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d2.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d3.swap(d4);</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator ds = d3.erase(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ds &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ds=d3.erase(ds);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ds &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-9.jpg" alt=""> </p><h4 id="deque容器的存储结构"><a href="#deque容器的存储结构" class="headerlink" title="deque容器的存储结构"></a>deque容器的存储结构</h4><p>和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由<strong>一段一段等长的连续空间构成</strong>，各段<strong>空间之间并不一定是连续的，可以位于在内存的不同区域</strong>。</p><p>为了管理这些连续空间，<strong>deque 容器用数组(数组名假设为 map）存储着各个连续空间的首地址</strong>。也就是说，map 数组中存储的都是指针，指向那些真正用来存储数据的各个连续空间</p><p><img src= "/img/loading.gif" data-src="/photo/STL1-10.jpg" alt=""> </p><p>通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。</p><p>如果 map 数组满了就再申请一块更大的连续空间供 map 数组使用，将原有数据拷贝到新的 map 数组中，然后释放旧的空间。</p><h3 id="vector、list、deque的优缺点"><a href="#vector、list、deque的优缺点" class="headerlink" title="vector、list、deque的优缺点"></a>vector、list、deque的优缺点</h3><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li>如果你需要<strong>高效的随即存取</strong>，而不在乎插入和删除的效率，使用vector</li><li>如果你需要<strong>大量的插入和删除</strong>，而不关心随即存取，则应使用list</li><li>如果你需要<strong>随即存取，而且关心两端数据的插入和删除</strong>，则应使用deque</li></ul><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h4><p>优点：</p><ul><li>不用指定内存大小，即可以像数组一样的连续存储，对此数组进行动态操作。通常体现在push_back() pop_back()</li><li>随机访问方便，即支持[ ]操作符和vector.at()</li><li>节省空间</li></ul><p>缺点：</p><ul><li>在内部进行插入删除操作效率低。</li><li>只能在vector的最后进行push和pop，不能在vector的头进行push和pop。</li><li>当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放</li></ul><h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><p>优点：</p><ul><li>不使用连续内存完成动态操作</li><li>在内部方便的进行插入和删除操作</li><li>可在两端进行push、pop</li></ul><p>缺点：</p><ul><li>不能进行内部的随机访问，即不支持[ ]操作符和vector.at()</li><li>相对于verctor占用内存多</li></ul><h4 id="deque："><a href="#deque：" class="headerlink" title="deque："></a>deque：</h4><p>优点：</p><ul><li>随机访问方便，即支持[ ]操作符和vector.at()</li><li>在内部方便的进行插入和删除操作</li><li>可在两端进行push、pop</li></ul><p>缺点：占用内存多</p><hr><p>以上就是本篇STL容器的全部内容，下一篇我们将讲述关联式容器set、map和容器适配器stack、queue的基本使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在准备春招的，正好复习到STL的使用，才想起还有这么一个博客的坑没填，就趁这次把它补充完吧~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;序列式容器&quot;&gt;&lt;a href=&quot;#序列式容器&quot; class=&quot;headerlink&quot; title=&quot;序列式容器&quot;&gt;&lt;/a&gt;序列式容器&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
      <category term="list" scheme="http://yoursite.com/tags/list/"/>
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结VI</title>
    <link href="http://yoursite.com/2022/02/15/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93VI/"/>
    <id>http://yoursite.com/2022/02/15/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93VI/</id>
    <published>2022-02-15T01:47:43.000Z</published>
    <updated>2022-02-16T08:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第六篇，本篇将总结<strong>行为树</strong>的实现</p><hr><h3 id="什么是行为树"><a href="#什么是行为树" class="headerlink" title="什么是行为树"></a>什么是行为树</h3><p>在虚幻引擎4（UE4）中，可以用多种不同的方式为角色创建AI。可以使用蓝图脚本来指示角色”执行某种操作”，例如播放动画、移动到特定位置、被物体击中时做出的反应等等。希望AI角色自行思考并自行做出决定时，<strong>行为树</strong> 便能派上用场。</p><p>行为树与蓝图相似，皆是以一种可视化方式创建，将一系列具备功能的节点添加并连接至行为树图表。执行逻辑时，行为树会使用一种名为 <strong>黑板</strong> 的独立资源来存储它需要知道的信息（名为 <strong>黑板键</strong>），从而做出有根据的决策。</p><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><p>行为树由一个个结点组成一个完整的逻辑，分为<strong>合成结点和任务结点</strong>两种，其中合成结点又有三种基本的结点类型：</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-1.jpg" alt=""> </p><ul><li>选择器合成节点（<strong>Selector</strong>）：选择器节点<strong>从左到右执行其子项</strong>，其中一个<strong>子项成功时将停止执行该子项的子项</strong>。如果子项成功，则选择器成功。如果选择器的所有子项失败，选择器也将失败。</li><li>序列合成节点（<strong>Sequence</strong>）：序列节点从左到右执行其子项，其中一个<strong>子项失败时将停止执行该子项的子项</strong>。如果子项失败，则序列失败。如果所有序列的子项成功，则序列成功。</li><li>简单平行结点（<strong>Simple Parallel</strong>）：此节点是装饰器的局部作用域。当执行流程离开该分支时，所有观察中的装饰器（低优先级或两者）将被移除。</li></ul><p>而任务结点就多种多样了，其一般用于实现你期望AI做出的动作，除了系统自带的任务结点外我们还可以选择编写自己的任务结点</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-2.jpg" alt=""> </p><h4 id="装饰器与服务"><a href="#装饰器与服务" class="headerlink" title="装饰器与服务"></a>装饰器与服务</h4><p>我们可以在结点上扩展装饰器与服务，选中结点，单机右键就能看到如下两个选择</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-3.jpg" alt=""> </p><p><strong>装饰器</strong> 节点（也被称为条件语句）会连接至 <strong>行为树</strong> 内部的节点，可以用它来决定树中的一个分支（甚至单个节点）是否可以被执行。</p><p><strong>服务</strong> 节点通常连接至<strong>合成节点</strong>，只要它们的分支正在执行，它们就会以所定义的频率执行。它们通常被用于检查和更新<strong>黑板</strong>，代替其它行为树系统中的传统平行节点。</p><h3 id="判断是否被攻击"><a href="#判断是否被攻击" class="headerlink" title="判断是否被攻击"></a>判断是否被攻击</h3><p>铺垫完了背景知识，那么我们开始动手实现第一个AI逻辑——判断敌人是否被攻击</p><p>首先我们要创建一个行为树和一个黑板，并将两者绑定。</p><p>除此外我们还要新建一个基于<strong>AIControl</strong>的蓝图类，用来作为敌人的AI逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-4.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE6-5.jpg" alt=""> </p><p>然后我们在选中放在世界场景中的敌人，为其绑定我们新建的AI蓝图类</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-6.jpg" alt=""></p><p>我们在黑板中添加如下三个变量，用于后续操作</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-7.jpg" alt=""></p><p>做完这些基础工作后，我们开始设置第一个结点，添加服务<strong>用来读取敌人是否被攻击</strong></p><p>新建一个Sequence结点，添加一个服务</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-8.jpg" alt=""></p><p>返回<strong>AIControl</strong>蓝图类里，添加一个<strong>IsLaunching</strong>的自定义事件，用来读取敌人类中是否被攻击的布尔值，并赋值给黑板上</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-9.jpg" alt=""></p><p>这样一来，我们就能在服务结点里调用该事件</p><p><img src= "/img/loading.gif" data-src="/photo/UE6-10.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第六篇，本篇将总结&lt;strong&gt;行为树&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是行为树&quot;&gt;&lt;a href=&quot;#什么是行为树&quot; class=&quot;headerlink&quot; title=&quot;什么是行为树&quot;&gt;&lt;/a&gt;什么是行为树&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结V</title>
    <link href="http://yoursite.com/2022/02/14/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93V/"/>
    <id>http://yoursite.com/2022/02/14/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93V/</id>
    <published>2022-02-14T01:47:23.000Z</published>
    <updated>2022-02-14T14:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第五篇，本篇将总结<strong>敌人攻击、敌人血条计算、敌人受伤、位移及死亡动画</strong>的实现</p><hr><h3 id="敌人攻击"><a href="#敌人攻击" class="headerlink" title="敌人攻击"></a>敌人攻击</h3><p>我们为敌人分别设置了近战攻击和远程攻击两种方式，首先我们需要定义两个事件来播放动画蒙太奇，用于我们后面在AI行为树中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-1.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-2.jpg" alt=""> </p><h4 id="近战攻击"><a href="#近战攻击" class="headerlink" title="近战攻击"></a>近战攻击</h4><p>首先我们到相应的动画蒙太奇中添加两个相应的通知事件，并在敌人的动画蓝图类中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-3.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-4.jpg" alt=""> </p><p>然后我们在敌人类的相应攻击位置添加碰撞盒（<strong>Hand</strong>）并设置碰撞逻辑和伤害，这里逻辑和角色类基本相似，故不加以赘述</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-5.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-6.jpg" alt=""> </p><h4 id="远程攻击"><a href="#远程攻击" class="headerlink" title="远程攻击"></a>远程攻击</h4><p>远程攻击的实现相较于近战攻击会稍微复杂一点，不过首先还是要在动画蒙太奇中添加动画通知并进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-7.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE5-8.jpg" alt=""> </p><p>然后我们还需要新建一个Actor蓝图类，命名为<strong>Spell</strong>，作为从敌人手中发射出的抛射物，并在该蓝图类中添加如下组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-9.jpg" alt=""> </p><p>然后我们选择ProjectileMovement，在此为抛射物设置初速度和最大速度</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-10.jpg" alt=""></p><p>然后我们返回敌人类中编写蓝图脚本，首先在相应攻击位置添加碰撞盒（<strong>Dagger</strong>）然后在事件<strong>SpawnSpell</strong> 中调用在位置处生成发射器（<strong>Spawn Emitter at Location</strong>）用于生成粒子特效</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-11.jpg" alt=""></p><p>然后在事件<strong>DraggerSpell</strong>中计算敌人与角色的旋转角度差，生成我们刚才所创建的<strong>Spell</strong></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-12.jpg" alt=""></p><p>随即我们返回<strong>Spell</strong>中，在碰撞盒中调用组件开始重叠时事件（<strong>On Component Begin Overlap</strong>）编写伤害应用逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-13.jpg" alt=""></p><h3 id="敌人血条计算、敌人受伤、位移及死亡动画"><a href="#敌人血条计算、敌人受伤、位移及死亡动画" class="headerlink" title="敌人血条计算、敌人受伤、位移及死亡动画"></a>敌人血条计算、敌人受伤、位移及死亡动画</h3><p>从敌人血条计算我们可以延伸出敌人受伤动画、受伤位移及死亡动画三种逻辑，让我们逐一分解</p><h4 id="敌人血条计算"><a href="#敌人血条计算" class="headerlink" title="敌人血条计算"></a>敌人血条计算</h4><p>敌人血条计算与角色类中的逻辑基本相同，不过在此处我们还需要先保存一下角色类和更新敌人血条UI（蓝图小结第三篇）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-14.jpg" alt=""></p><h4 id="敌人位移"><a href="#敌人位移" class="headerlink" title="敌人位移"></a>敌人位移</h4><p>敌人在收到攻击的时候，会产生一定的位移，要实现这样位移的效果，我们需要设置四个变量来计算敌人受到的力</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-16.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-15.jpg" alt=""></p><p>由于数值为负时则指向另外一轴，所以我们只需设置四个变量而非十六个变量</p><p>我们在蓝图脚本中自定义一个<strong>Launch</strong>事件，用来计算角色受到的力并弹射角色（<strong>Launch Character</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-17.jpg" alt=""></p><p>我们需要在受伤和死亡的动画蒙太奇中添加相应的动画通知，并在敌人的动画蓝图类触发</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-18.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-19.jpg" alt=""></p><h4 id="敌人受伤"><a href="#敌人受伤" class="headerlink" title="敌人受伤"></a>敌人受伤</h4><p>敌人血条计算结果若大于0，则首先调用立即停止移动（<strong>Stop Movement lmmediately</strong>）和停止播放动画蒙太奇（<strong>Stop Anim Montage</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-20.jpg" alt=""></p><p>然后我们要根据角色是否从角色正面进攻及角色武器攻击方向设置不同的力（正反面两组数值相反）和不同的蒙太奇动画</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-21.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-22.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-23.jpg" alt=""></p><p>最后将蒙太奇动画进行播放</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-24.jpg" alt=""></p><h4 id="敌人死亡"><a href="#敌人死亡" class="headerlink" title="敌人死亡"></a>敌人死亡</h4><p>敌人血条小于等于0时，就进入敌人死亡逻辑的处理，同样也是要判断角色的方向并设置不同的力和动画蒙太奇</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-25.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-26.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE5-27.jpg" alt=""></p><p>动画蒙太奇播放完后，要对角色设置模拟物理（<strong>Set Simulate Physics</strong>）、修改碰撞并销毁胶囊体和UI组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE5-28.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第五篇，自此我们已经将敌人类的基本蓝图逻辑梳理完成，下一篇我们将梳理敌人的AI行为</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第五篇，本篇将总结&lt;strong&gt;敌人攻击、敌人血条计算、敌人受伤、位移及死亡动画&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;敌人攻击&quot;&gt;&lt;a href=&quot;#敌人攻击&quot; class=&quot;headerlink&quot; title=&quot;敌人攻击&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结IV</title>
    <link href="http://yoursite.com/2022/02/13/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93IV/"/>
    <id>http://yoursite.com/2022/02/13/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93IV/</id>
    <published>2022-02-13T11:47:23.000Z</published>
    <updated>2022-02-14T14:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第四篇，本篇将总结<strong>角色方向、角色血条UI及计算</strong>的实现</p><hr><h3 id="角色血条UI"><a href="#角色血条UI" class="headerlink" title="角色血条UI"></a>角色血条UI</h3><p>由于游戏可操控主角只有一个，所以我们可以直接将UI展示在游戏界面中，而不用像设计敌人UI那样麻烦</p><p>首先我们还是需要先创建一个控件蓝图，用来设计UI的样式（<strong>Player UI</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-1.jpg" alt=""> </p><p>选择进度条，在百分比一栏旁选择创建绑定，就会跳到一个蓝图脚本界面</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-2.jpg" alt=""> </p><p>我们就可以在这蓝图脚本里编写相应的逻辑，<strong>Blood</strong>变量代表当前角色血量，<strong>Max Blood</strong>代表角色总血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-3.jpg" alt=""> </p><p>我们需要将该UI放在角色类里<strong>初始化</strong>中进行，同时还有一些其它逻辑需要进行初始化</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-4.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE4-5.jpg" alt=""> </p><h3 id="角色血条计算"><a href="#角色血条计算" class="headerlink" title="角色血条计算"></a>角色血条计算</h3><p>在处理角色血条计算时，我们需要先准备两个动画蒙太奇，一个是受攻击动画，另一个是死亡动画</p><p>然后我们调用事件任意伤害（<strong>Event AnyDamage</strong>），首先计算收到攻击后剩余的血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-6.jpg" alt=""> </p><p>然后我们根据当前血量进行角色当前状态的判断，并进行不同的逻辑处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-7.jpg" alt=""> </p><p>在设置角色死亡时，要调用销毁组件（<strong>DestroyComponent</strong>）传入角色胶囊体进行销毁</p><h3 id="角色攻击方向"><a href="#角色攻击方向" class="headerlink" title="角色攻击方向"></a>角色攻击方向</h3><p>由于我们的角色可能对敌人进行正反两个方向的攻击，所以我们需要判断敌人是面对角色还是背靠角色的，以方便我们后期对角色受攻击动画进行处理</p><p>我们需要在敌人类中定义一个新事件，调用寻找查看旋转函数（<strong>Find Look at Rotation</strong>），该函数用于计算起始位置转向目标位置的旋转角度，将此角度与角色选择角度作差，并保存</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-9.jpg" alt=""> </p><p>随即判断该值是否小于-60°到60°之间，若是的话，则代表角色在敌人面前，设置<strong>Front</strong>变量为True，用于后续敌人动画处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE4-8.jpg" alt=""> </p><hr><p>以上就是UE4蓝图小结第四篇，至此我们已经将角色类的蓝图脚本全部梳理完毕，并梳理了部分敌人类的蓝图脚本，下一篇将把敌人类的蓝图脚本梳理完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第四篇，本篇将总结&lt;strong&gt;角色方向、角色血条UI及计算&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;角色血条UI&quot;&gt;&lt;a href=&quot;#角色血条UI&quot; class=&quot;headerlink&quot; title=&quot;角色血条UI&quot;&gt;&lt;/a&gt;角
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结III</title>
    <link href="http://yoursite.com/2022/02/11/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93III/"/>
    <id>http://yoursite.com/2022/02/11/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93III/</id>
    <published>2022-02-11T06:33:22.000Z</published>
    <updated>2022-02-14T14:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第三篇，本次我们将总结<strong>武器碰撞、应用伤害及敌人血条UI</strong>的实现</p><hr><h3 id="武器碰撞"><a href="#武器碰撞" class="headerlink" title="武器碰撞"></a>武器碰撞</h3><p>碰撞，是UE4中检测两个物体是否发生接触的判断途径。也是我们检测角色武器是否与敌人发生接触的方法。</p><p>首先我们需要在角色类中网格体下为武器所在的位置添加碰撞盒（<strong>weapon</strong>），让其基本程度上覆盖武器</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-1.jpg" alt=""> </p><p>同时，我们要在攻击的动画蒙太奇中分别添加<strong>Eco Weapon</strong>和<strong>Deco Weapon</strong>两个通知，用于修改我们的碰撞状态</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-2.jpg" alt=""> </p><p>然后在动画蓝图类中添加通知</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-3.jpg" alt=""> </p><p>最后我们回到角色类中的蓝图脚本编写相应的逻辑</p><p>当触发Eco Weapon时，将weapon的碰撞类型（<strong>Set Collision Enabled</strong>）改成已启用碰撞（查询和物理），触发DecoWeapon时将碰撞类型设为无碰撞</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-4.jpg" alt=""> </p><p>这里我们就要简述一下<strong>UE4中的碰撞逻辑</strong>：</p><p>在UE4中两个物体发生接触会有三种情况：忽略、重叠、和阻挡</p><p>其中忽略和重叠在表现上是相同的，但是，我们若启用了生成重叠事件（<strong>Generate Overlap Events</strong>），就会可以调用重叠事件，我们的攻击碰撞到敌人的检测就是通过重叠来判断的</p><p>所以我们需要在碰撞盒weapon中进行预设</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-5.jpg" alt=""> </p><p>那么怎么样才能判断两个物体是发生了忽略重叠还是阻挡呢，下面一张图进行了简单的概况：</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-6.jpg" alt=""> </p><p>值得注意的是，若想要在两个物体产生碰撞后用蓝图脚本调用事件，我们需要勾选模拟生成命中事件（<strong>Simulation Generates Hit Events</strong>）</p><h3 id="应用伤害"><a href="#应用伤害" class="headerlink" title="应用伤害"></a>应用伤害</h3><p>要应用伤害，我们首先要有一个对象，所以我们要创建另一个角色类<strong>Enemy</strong>，用来编写敌人的逻辑（以下简称敌人类）</p><p>我们调用weapon的组件开始重叠函数，并将重叠对象作为进行一个类型转换为敌人类存储起来，方便后面伤害的应用</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-7.jpg" alt=""> </p><p>然后我们调用UE4中自带的应用伤害（<strong>Apply Damage</strong>）函数，传入相应参数</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-8.jpg" alt=""> </p><p>这样，攻击伤害就实现了</p><h3 id="敌人血条UI"><a href="#敌人血条UI" class="headerlink" title="敌人血条UI"></a>敌人血条UI</h3><p>由于我们一个场景中可能存在多个敌人，所以我们需要将敌人血条的UI挂在角色类上，首先我们要在网格体下添加一个控件组件</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-9.jpg" alt=""> </p><p>除此之外，我们还需要创建一个控件蓝图，用来设计UI的样式（<strong>Enemy UI</strong>），选择进度条组件，命名为<strong>EnemyBlood</strong>，并勾选Is Variable</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-10.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE3-11.jpg" alt=""> </p><p>然后我们返回敌人类中的控件组件做相应的配置，在控件类选择Enemy UI，并将其在游戏中隐藏一选项勾选</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-12.jpg" alt=""> </p><p>之后我们在敌人类的蓝图脚本中新建一个更新UI的函数，进行一系列逻辑处理，其中<strong>Blood</strong>变量代表当前敌人血量，<strong>Max Blood</strong>代表敌人总血量</p><p><img src= "/img/loading.gif" data-src="/photo/UE3-13.jpg" alt=""> </p><p>由于血条的计算还和敌人类后面一系列逻辑有关，故不在本篇进行介绍，等后面章节再做补充</p><hr><p>以上就是UE4蓝图小结第三篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第三篇，本次我们将总结&lt;strong&gt;武器碰撞、应用伤害及敌人血条UI&lt;/strong&gt;的实现&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;武器碰撞&quot;&gt;&lt;a href=&quot;#武器碰撞&quot; class=&quot;headerlink&quot; title=&quot;武器碰撞&quot;&gt;&lt;/a&gt;武器碰
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结II</title>
    <link href="http://yoursite.com/2022/02/09/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93II/"/>
    <id>http://yoursite.com/2022/02/09/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93II/</id>
    <published>2022-02-09T04:04:37.000Z</published>
    <updated>2022-02-14T14:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到UE4蓝图小结第二篇，这一次我们来讲<strong>人物攻击的实现</strong></p><hr><h3 id="设置动画插槽"><a href="#设置动画插槽" class="headerlink" title="设置动画插槽"></a>设置动画插槽</h3><p>在UE4中实现攻击动画，我们需要用到播放动画蒙太奇这一功能，而为了使角色能够正常的播放蒙太奇动画，我们需要在动画蓝图中为角色添加动画插槽</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-1.jpg" alt=""> </p><p><img src= "/img/loading.gif" data-src="/photo/UE2-2.jpg" alt=""> </p><h3 id="设置结构体与表格"><a href="#设置结构体与表格" class="headerlink" title="设置结构体与表格"></a>设置结构体与表格</h3><p>由于我们要实现动画的连招效果，而为了不使蓝图脚本看起来过于繁琐，我们要用到蓝图中的表格来存储数据（可以理解为数组）</p><p>首先我们要定义一个结构体，包含动画蒙太奇、最高伤害、最低伤害攻击方向四个变量</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-3.jpg" alt=""></p><p>然后我们创建数据表格，采用我们定义的结构体作为行结构，然后就可以在表中进行赋值</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-4.jpg" alt=""></p><p>由于我们要在游戏中实现两种攻击形式，所以我们还需要创建一个枚举值分别存放两个不同攻击的的名称，对应表格中的行名，方便我们在蓝图脚本中进行调用</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-5.jpg" alt=""></p><h3 id="攻击实现"><a href="#攻击实现" class="headerlink" title="攻击实现"></a>攻击实现</h3><p>首先要讲一下我设计的攻击逻辑，角色分有普通攻击和特殊攻击两种，每种攻击各有四种连击动画，按鼠标左键触发普通攻击，按下左键后再按下右键触发特殊攻击。</p><p>要实现这样的攻击效果，我们需要完成以下几件事：</p><ul><li>读取表格攻击数据</li><li>对准角色攻击方向</li><li>连招的逻辑实现</li></ul><p>让我们来一一分解：</p><h4 id="读取表格攻击数据"><a href="#读取表格攻击数据" class="headerlink" title="读取表格攻击数据"></a>读取表格攻击数据</h4><p>我们在角色类蓝图脚本中添加一个自定义事件，用于读取表格数据并播放动画蒙太奇，下图是完成了逻辑流程</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-6.jpg" alt=""></p><p>首先先将判断上一轮攻击是否完成的变量（<strong>Done</strong>）设为false，然后根据枚举数据设置要读取的表头名（<strong>Change Skill</strong>）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-7.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-8.jpg" alt=""></p><p>然后通过调用<strong>Get Data Table Row</strong>来获得表格中的对应表行的数据，并进行相应的赋值处理</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-9.jpg" alt=""></p><p>最后进行延时处理（等待动画播放完），并将Done变量设为true</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-10.jpg" alt=""></p><h4 id="对准角色攻击方向"><a href="#对准角色攻击方向" class="headerlink" title="对准角色攻击方向"></a>对准角色攻击方向</h4><p>对准角色攻击方向要先判断角色是否正在进行攻击，若是的话，通过<strong>Set bUseControllerRotationYaw</strong>来使角色面向自己镜头所在的方向</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-20.jpg" alt=""></p><h4 id="连招逻辑的实现与动画通知"><a href="#连招逻辑的实现与动画通知" class="headerlink" title="连招逻辑的实现与动画通知"></a>连招逻辑的实现与动画通知</h4><p>点击鼠标左键调用攻击，关键的是处理Index的自增逻辑</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-11.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-12.jpg" alt=""></p><p>而实现特殊攻击的逻辑就比较复杂一点了，因为特殊攻击要求我们在按下普通攻击后再按下右键才能进行调用，所以我们要先判断是否处于普通攻击中</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-13.jpg" alt=""></p><p>并且我们要保证该攻击只执行一次，需要用到<strong>Do Once</strong>这一功能</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-14.jpg" alt=""></p><p>而只有在自定义事件<strong>Reset Skill</strong>触发时，才能再发生该特殊攻击的执行</p><p>那么要在哪里触发该事件呢，这里我们就需要用到UE4中的<strong>动画通知</strong>：</p><p><strong>动画通知</strong>（<strong>AnimNotifies</strong> 或 <strong>通知</strong>）为动画程序员提供了一种方式，以便设置事件在 <strong>动画序列</strong> 中的特定点上发生。通知常用于在行走或跑步动画中添加脚步声之类的效果，或在动画中生成粒子系统。它们用途广泛，系统可随自定义通知类型进行延展，以满足各种游戏的需求。（源自UE4官方文档）</p><p>要实现动画通知我们首先要在相应的动画蒙太奇上添加通知（其中<strong>Reset Combo</strong>用来将各种变量重置）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-15.jpg" alt=""></p><p>除此外，我们还需要再动画蓝图类中添加事件触发通知</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-16.jpg" alt=""></p><p>这样一来就能保证角色类中的事件正常触发啦</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-17.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/UE2-18.jpg" alt=""></p><p>之后就是处理Index的逻辑，要特别注意的是最后一次特殊攻击要将Index的值重新赋值为3（因为普通攻击这时已经将Index重置为0）</p><p><img src= "/img/loading.gif" data-src="/photo/UE2-19.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第二篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到UE4蓝图小结第二篇，这一次我们来讲&lt;strong&gt;人物攻击的实现&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;设置动画插槽&quot;&gt;&lt;a href=&quot;#设置动画插槽&quot; class=&quot;headerlink&quot; title=&quot;设置动画插槽&quot;&gt;&lt;/a&gt;设置动画插槽&lt;/h
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>通往游戏之路：UE4蓝图小结I</title>
    <link href="http://yoursite.com/2022/01/25/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93I/"/>
    <id>http://yoursite.com/2022/01/25/%E9%80%9A%E5%BE%80%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B7%AF%EF%BC%9AUE4%E8%93%9D%E5%9B%BE%E5%B0%8F%E7%BB%93I/</id>
    <published>2022-01-25T02:35:00.000Z</published>
    <updated>2022-02-14T14:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>于是乎终于开始了我的游戏设计之路</p><p>之前是一直在前端和游戏两个方向飘忽不定，但在做了一些前端项目后，决心还是重点专研游戏这一方向，也把我的毕业设计题目定成了基于UE4的动作游戏开发，那么就要好好专研了。</p><p>首先第一步就是制作一个动作游戏的Demo，我决定采用纯蓝图完成，以帮助我快速入门虚幻4</p><hr><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>蓝图是虚幻4所提供给开发者的一套强大工具，它具体可分为<strong>蓝图类和蓝图脚本</strong></p><p><strong>蓝图类</strong>, 一般缩写为 <strong>Blueprint(蓝图)</strong>,是一种允许内容创建者轻松地基于现有游戏性类添加功能的资源。 蓝图*是在虚幻编辑器中可视化地创建的，不需要书写代码，会被作为类保存在内容包中。</p><p>而<strong>蓝图脚本</strong>则可以理解为是一种脚本语言，它是虚幻4将底层C++封装好后提供给开发者的一种可视化编程工具，这样即便是非程序员也能通过简单的连线来处理游戏的逻辑关系，以达到实现简单的游戏效果。</p><h3 id="人物移动、转向与跳跃"><a href="#人物移动、转向与跳跃" class="headerlink" title="人物移动、转向与跳跃"></a>人物移动、转向与跳跃</h3><h4 id="创建角色类"><a href="#创建角色类" class="headerlink" title="创建角色类"></a>创建角色类</h4><p>首先我们要创建一个蓝图类来存放我们的主角，我们在UE4中的内容浏览器里右键选择新建蓝图类，在父类一项我们选择角色</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-18.jpg" alt=""> </p><p>之后我们命名并保存，进入该角色类里点击网格体为角色选择一个骨骼并调整相应大小，我这里用的是虚幻商城免费提供的</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-19.jpg" alt=""> </p><p>然后保存即可，这样我们就有了一个简单的角色类</p><h4 id="操作映射与轴映射"><a href="#操作映射与轴映射" class="headerlink" title="操作映射与轴映射"></a>操作映射与轴映射</h4><p>虚幻4的项目设置里包含操作映射与轴映射两项属性，用于将我们的输入映射到游戏中，可供我们在蓝图中进行调用，也可以由我们自己进行改写。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-1.jpg" alt=""> </p><p>一般这些配置符合正常的游戏逻辑属性，通常不进行改写，我们的人物移动就需要用到其中的MoveForward和MoveRight映射。</p><h4 id="人物移动"><a href="#人物移动" class="headerlink" title="人物移动"></a>人物移动</h4><p>我们需要在<strong>角色类</strong>里编写蓝图脚本来控制角色的移动，在第三人称游戏中我们通过WASD来进行人物的移动，而这些在MoveForward和MoveRight中便有相应的映射</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-2.jpg" alt=""> </p><p>而添加移动输入（<strong>Add Movement Inpu</strong>t）则是虚幻4封装好的函数，它会根据轴映射的返回值让对象进行相应的移动。</p><p>同时我们还要获得人物的旋转方向（<strong>Get Control Rotation</strong>）并且将其分解为z轴上的值，这样能防止从其它视角上移动人物受到影响。然后将值一并赋予移动输入里，这样就能实现简单的人物移动效果</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-3.jpg" alt=""> </p><h4 id="人物转向"><a href="#人物转向" class="headerlink" title="人物转向"></a>人物转向</h4><p>人物转向也是同理，通过Turn和LookUp两个映射，并调用虚幻4中封装好的<strong>Add Controller Yaw Input</strong>和<strong>Add Controller Pitch Input</strong>两个函数，实现通过鼠标进行人物转向的功能</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-4.jpg" alt=""> </p><h4 id="跑步与跳跃"><a href="#跑步与跳跃" class="headerlink" title="跑步与跳跃"></a>跑步与跳跃</h4><p>两个步骤实现的人物移动，只是静止的，要实现人物的真正移动，我们还需要<strong>动画蓝图类</strong>的配合</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-5.jpg" alt=""> </p><p>我们需要通过一个状态机来实现人物不同动画之间状态的切换，而在那之前我们还需要建立一个混合空间1D来存放人物从移动到跑步的动画，并在资产详情里将水平轴的最大坐标设置为600。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-6.jpg" alt=""> </p><p>然后在状态机里，我们就可以将如上动画序列拖入，并通过连线实现其之间的逻辑转换</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-7.jpg" alt=""> </p><p>而为了实现行走、跑步、跳跃，我们需要在动画蓝图里分别设置两个变量：Speed和Is AIr</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-8.jpg" alt=""> </p><p>而人物的状态是要通过角色类获得的，为了获得相应的参数，我们需要在动画蓝图类的事件图表里通过调用<strong>Try Get Pawun Owner</strong>以获得角色类，然后调用相应函数便可对Speed和Is AIr两个变量的赋值。</p><p>其中事件蓝图更新动画（<strong>Event Blueprint Update Animation</strong>）每帧执行一次，允许动画蓝图执行计算并更新到它需要的任何值。</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-9.jpg" alt=""> </p><p>然后就可以会到状态机里设置四个状态变换的条件</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-10.jpg" alt=""> </p><p>然后我们要回到角色类中的蓝图脚本添加相应的奔跑与跳跃映射</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-11.jpg" alt=""> </p><p>同时，要在角色移动组件里设置相应行走的速度</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-12.jpg" alt=""> </p><p>这样，我们就实现了最基本的人物移动、转向与跳跃</p><h3 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h3><p>动画重定向就是让不同的两个人物骨骼模型共用同一套动画，由于我们开发游戏过程中的很多资源都是EPIC商城提供的，所以动画重定向还是很经常使用。</p><p>要实现最基本的人型动画的重定向，我们需要到相应的角色骨骼里，按图下步骤进行重定向绑定</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-13.jpg" alt=""> </p><p>同时在需要重定向动画中的骨骼也进行同样的操作，然后再需要重定向的动画序列上右键选择重定向动画资产就可以完成重定向操作</p><p>（要注意两个重定向的骨骼姿势要基本保持一致）</p><p><img src= "/img/loading.gif" data-src="/photo/UE1-14.jpg" alt=""></p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-15.jpg" alt=""></p><p>重定向后的动画有时会出现一些奇怪的姿势，这是我们就要在骨骼树里的选项里选择显示重定向选择，然后在root点击右键选择递归平移设置重定向骨骼，就能让姿势回归正常</p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-16.jpg" alt=""></p><p> <img src= "/img/loading.gif" data-src="/photo/UE1-17.jpg" alt=""></p><hr><p>以上就是UE4蓝图小结第一篇，感谢您的观看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;于是乎终于开始了我的游戏设计之路&lt;/p&gt;
&lt;p&gt;之前是一直在前端和游戏两个方向飘忽不定，但在做了一些前端项目后，决心还是重点专研游戏这一方向，也把我的毕业设计题目定成了基于UE4的动作游戏开发，那么就要好好专研了。&lt;/p&gt;
&lt;p&gt;首先第一步就是制作一个动作游戏的Demo，我
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="UE4" scheme="http://yoursite.com/tags/UE4/"/>
    
      <category term="蓝图" scheme="http://yoursite.com/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer 第五版》阅读笔记I:引用、指针与const</title>
    <link href="http://yoursite.com/2022/01/25/%E3%80%8AC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/01/25/%E3%80%8AC-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-25T02:34:02.000Z</published>
    <updated>2022-02-08T13:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>大学里除了在课堂上接触专业的书外，就很少在课堂下阅读与专业有关的书了。有很多经典计算机书籍都没有去看，其实想来是蛮错误的一件事，所以就趁这这个寒假读了读《C++ Primer 第五版》，正好也为我C++的开发巩固些基础。</p><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>引用为对象齐了另外一个名字，通常将声明符写成&amp;n的形式来定义引用类型，n是声明的变量名。<strong>定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。</strong></p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r=i;<span class="comment">//r是一个应用，与i绑定在一起</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r;<span class="comment">//结果为1024</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>引用类型的初始值必须是一个对象</li><li>引用必须要初始化</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>指针是指向另外一种类型的符合类型，与引用相似，指针也实现了对其他对象的间接访问。定义指针类型的方法将声明符写成<em>d的形式，其中d为变量名。<strong>指针用于存放某个对象的地址</strong>，获取该地址时，我们要用<strong>取地址符&amp;</strong>（注意不要和引用声明混淆）如果指针指向了一个对象，则允许使用<strong>解引用符 </strong></em>（注意不要和指针声明混淆） 来访问对象。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;i;<span class="comment">//r存放变量i的地址，r为指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *r &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指向的对象</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;i &lt;&lt; <span class="string">"  "</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针所指向对象的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;r &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指针本身的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/CP1-1.jpg" alt=""></p><h4 id="与引用的区别"><a href="#与引用的区别" class="headerlink" title="与引用的区别"></a>与引用的区别</h4><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝</li><li>引用本身非对象，一旦定义了引用，就无法绑定到另外的对象</li><li>指针无需在定义时赋初值，没有初始化时系统将自动分配一个不确定的值</li></ul><h4 id="指针的指针与指针的引用"><a href="#指针的指针与指针的引用" class="headerlink" title="指针的指针与指针的引用"></a>指针的指针与指针的引用</h4><p>一般来说，用到这两个的会比较少，也属于比较绕的两个概念，这里直接附上原文，供大家理解</p><p><img src= "/img/loading.gif" data-src="/photo/CP1-2.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/CP1-3.jpg" alt=""></p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>const对变量的类型进行限定，使其值不能改变，成为常量，故其必须进行初始化</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line">i=<span class="number">2048</span>;<span class="comment">//编译错误，const不能进行写值</span></span><br></pre></td></tr></table></figure><h4 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h4><p>我们同样可以<strong>令指针指向常量</strong>，称其为<strong>指向常量的指针</strong>，但不能用于改变其所指对象的值。</p><p>另一种写法是<strong>把指针本身定为常量，称为常量指针</strong>，其必须初始化，且无法进行改变。</p><p>Eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//指向常量的指针，可以改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptnum = &amp;num;<span class="comment">//常量指针，将一直指向num，无法改变</span></span><br></pre></td></tr></table></figure><h4 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h4><p>顶层const表示<strong>指针本身是个常量</strong></p><p>底层const表示<strong>指针所指向的对象是一个常量</strong>。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名就是定义某种类型的同义词，好让我们方便编程时理解和使用。</p><p>通常我们用<strong>关键字typedef</strong>进行类型别名的定义，除此之外，我们还能用<strong>别名声明</strong>来定义类型的别名，这种方法<strong>用using作为别名声明的开始</strong>，后紧跟别名和等号，如下所示：</p><p><code>using fl = float;</code></p><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>C+11新标准引入了auto类型说明符，它能让编译器替我们分析表达式所属的类型，如下所示</p><p><code>auto i=0,j=3.14;            //编译器会自动根据数据判断类型</code></p><h4 id="constexpr与常量表达式"><a href="#constexpr与常量表达式" class="headerlink" title="constexpr与常量表达式"></a>constexpr与常量表达式</h4><p><strong>常量表达式</strong>是指值不会改变并且能在编译过程就能得到计算结果的表达式，在C++中我们可以通过用constexpr来声明一个变量或者式子为常量表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[N];</span><br><span class="line">    <span class="keyword">int</span> arrs[M];<span class="comment">//在某些编译器中会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>decltype能返回操作数的数据类型，操作数可以是变量，也可以是函数，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(fun()) sum = <span class="number">0</span>;<span class="comment">//sum的类型就是int</span></span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">6</span>;<span class="comment">//j的类型是const int</span></span><br><span class="line">    <span class="keyword">decltype</span>(pi) k = <span class="number">6.66</span>;<span class="comment">//pi的类型是double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是本人《C++ Primer 第五版》的第一篇阅读笔记，感谢您的观看~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学里除了在课堂上接触专业的书外，就很少在课堂下阅读与专业有关的书了。有很多经典计算机书籍都没有去看，其实想来是蛮错误的一件事，所以就趁这这个寒假读了读《C++ Primer 第五版》，正好也为我C++的开发巩固些基础。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="指针" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>算法II:排序与查找的应用</title>
    <link href="http://yoursite.com/2022/01/17/%E7%AE%97%E6%B3%95II-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2022/01/17/%E7%AE%97%E6%B3%95II-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-01-17T03:39:54.000Z</published>
    <updated>2022-02-07T13:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客将讲述在数据结构中学过的一些排序与查找的具体应用，以及STL中sort的用法讲解，具体内容往下看吧</p><hr><h3 id="sort的用法"><a href="#sort的用法" class="headerlink" title="sort的用法"></a>sort的用法</h3><p>一般在解决实际问题的时候，我们很少再去自己写一个排序算法进行调用，因为像很多语言都已经封装好了排序函数让我们直接进行调用，就比如C++中<algorithm>里的sort函数</p><p>sort(first,last,comp)函数有三个参数: first和 last为待排序序列的起始地址和结束地址;cmp为排序方式，可以不填写,<strong>不填写时默认为升序方式</strong>。</p><p>sort函数的基本应用我们自不多讲，这里主要讲一下如何应用sort函数里的cmp来进行自定义的排序</p><h4 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h4><p><strong>题目:</strong></p><p>用一维数组存储学号和成绩,然后按成绩排序输出。</p><p><strong>输入:</strong></p><p>输入的第一行中包括一个整数N（1≤N≤100)，它代表学生的个数。</p><p>接下来的N行中,每行包括两个整数p和q，分别代表每个学生的学号和成绩。</p><p><strong>输出:</strong></p><p>按照学生的成绩从小到大进行排序,并将排序后的学生信息打印出来。如果学生的成绩相同，那么按照学号的大小从小到大排序。</p><p><strong>样例输入:</strong><br>3</p><p>1 90</p><p>2 87</p><p>3 92</p><p><strong>样例输出:</strong></p><p>2 87</p><p>1 90</p><p>3 92</p><p><strong>思想：</strong></p><p>本题需要定义一个结构体，可通过cmp来改写sort使之能用于结构体的排序，除此之外，我们还可以定义结构体的小于号重载来达到该目的</p><p><strong>代码（cmp方法）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(struct student &amp;s1, struct student &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.score != s2.score)</span><br><span class="line"><span class="keyword">return</span> s1.score &lt; s2.score;<span class="comment">//若成绩不相等，按成绩从小到大排序</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> s1.num &lt; s2.num;<span class="comment">//若成绩相等，按学号从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">student</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i].num &gt;&gt; s[i].score;</span><br><span class="line">&#125;</span><br><span class="line">sort(s, s + n, cmp1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i].num &lt;&lt;<span class="string">" "</span>&lt;&lt; s[i].score &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码（重载小于号方法）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(student stu) <span class="keyword">const</span> &#123;<span class="comment">//采用该方法，运行速度将会更快</span></span><br><span class="line"><span class="keyword">if</span> (score == stu.score)</span><br><span class="line"><span class="keyword">return</span> num &lt; stu.num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> score &lt; stu.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> = <span class="title">new</span> <span class="title">struct</span> <span class="title">student</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i].num &gt;&gt; s[i].score;</span><br><span class="line">&#125;</span><br><span class="line">sort(s, s + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i].num &lt;&lt; <span class="string">" "</span> &lt;&lt; s[i].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-1.jpg" alt=""> </p><h4 id="整数奇偶排序"><a href="#整数奇偶排序" class="headerlink" title="整数奇偶排序"></a>整数奇偶排序</h4><p><strong>题目：</strong><br>输入10个整数，彼此以空格分隔。重新排序以后输出(也按空格分隔)，要求:1.先输出其中的奇数,并按从大到小排列;2.然后输出其中的偶数,并按从小到大排列。</p><p><strong>输入:</strong></p><p>任意排序的10个整数(0～100)，彼此以空格分隔。</p><p><strong>输出</strong>:</p><p>可能有多组测试数据，对于每组数据，按照要求排序后输出，由空格分隔。</p><p>1.测试数据可能有很多组，请使用while(cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;…&gt;&gt;a[9])类似的做法来实现;</p><p>2.输入数据随机，有可能相等。</p><p><strong>样例输入:</strong></p><p>4 7 3 13 11 12 0 47 34 98</p><p><strong>样例输出:</strong></p><p>4 7 13 11 7 3 0 4 12 34 98</p><p><strong>思想：</strong></p><p>本题最直观的方法就是先将数据分为奇偶两组，然后再进行排序。但这样明显速度上是比较慢的，此时我们就可以从sort方法下的cmp入手进行改造</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> x &lt; y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; y % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;arr[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">sort(arr, arr + MAX, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-2.jpg" alt=""> </p><h3 id="排序算法的应用"><a href="#排序算法的应用" class="headerlink" title="排序算法的应用"></a>排序算法的应用</h3><h4 id="O-n-的排序"><a href="#O-n-的排序" class="headerlink" title="O(n)的排序"></a>O(n)的排序</h4><p><strong>题目:</strong></p><p>给你n个整数，请按从大到小的顺序输出其中前m大的数，时间复杂度要求为O(n)。</p><p><strong>输入:</strong></p><p>输入有多组数据。每组测试数据有两行，第一行有两个数n,m(O&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</p><p><strong>输出:</strong><br>对每组测试数据按从大到小的顺序输出前m大的数。</p><p><strong>样例输入∶</strong></p><p>5 3</p><p>3 -35 92 213 -644</p><p><strong>样例输出∶</strong></p><p>213 92 3</p><p><strong>思想：</strong></p><p>由于题目要求要在O(n)的时间复杂度内完成排序，哪怕应用效率最高的快排堆排的时间复杂度也难以达到O(n)，但由于数据量并不是很大，故这时我们可以考虑用计数排序，通过空间换时间，达到O(n)的时间量级</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RANGE = <span class="number">5e5</span>;  <span class="comment">//由于数据区间是从-500000到+500000，故需要进行范围调整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[MAX];<span class="comment">//用于计数排序</span></span><br><span class="line"><span class="keyword">int</span> arr[MAX];<span class="comment">//用于存放排序好的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">num[arr[i] + RANGE]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (num[i]--)</span><br><span class="line">&#123;</span><br><span class="line">arr[index++] = i - RANGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= n - m; i--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-3.jpg" alt=""> </p><h4 id="逆序数求解"><a href="#逆序数求解" class="headerlink" title="逆序数求解"></a><strong>逆序数求解</strong></h4><p><strong>题目:</strong></p><p>给你n个整数组成的序列，请求出序列的逆序数。</p><p><strong>输入∶</strong></p><p>输入有多组数据。第一行先给出数据的组数，每组测试数据有第一行，每组数据先给出序列的长度N(O&lt;N&lt;100)，之后输入n个处于区间</p><p>[-1000000,1000000]的整数。</p><p><strong>输出:</strong></p><p>对每组测试数据先输出”Scenario #:”，在输出该组数据的逆序数，每组输出之间用空行分割开来。</p><p><strong>样例输入∶</strong></p><p>4<br>4 2 8 0 3<br>10 0 1 2 3 4 5 6 7 8 9<br>6 -42 23 6 28 -100 65537<br>5 0 0 0 0 0</p><p><strong>样例输出∶</strong></p><p>Scenario #1:<br>3</p><p>Scenario #2:<br>0</p><p>Scenario #3:<br>5</p><p>Scenario #4:<br>0</p><p><strong>思想：</strong></p><p>解决本题，我们要用到的是归并排序的思想，因为对于归并排序来说，当右边归并的数小于左边归并的数时，说明右边该数小于左边归并数之后的任一数字，我们只需要在这一个时候进行累加，就可计算出数据中所有的逆序数</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp[MAX];</span><br><span class="line"><span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = left;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">num += mid + <span class="number">1</span> - i;<span class="comment">//计算逆序数</span></span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line"><span class="keyword">while</span> ( j &lt;= right)</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line"><span class="keyword">for</span> (i = left; i &lt;= right; i++)</span><br><span class="line">arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">MergeSort(left, mid, arr);</span><br><span class="line">MergeSort(mid + <span class="number">1</span>,right, arr);</span><br><span class="line">Merge(left, right, mid, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *res = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//存放结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[j];</span><br><span class="line">MergeSort(<span class="number">0</span>, l - <span class="number">1</span>, arr);</span><br><span class="line">res[i] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-4.jpg" alt=""> </p><h4 id="第K大数"><a href="#第K大数" class="headerlink" title="第K大数"></a>第K大数</h4><p><strong>题目:</strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p><strong>输入∶</strong></p><p>第一行给出k的值和数组的长度n</p><p>第二行给出数组的元素</p><p><strong>输出:</strong></p><p>输出数组中第k个最大的元素</p><p><strong>样例输入∶</strong></p><p>2 6</p><p>3 2 1 5 6 4</p><p><strong>样例输出∶</strong></p><p>5</p><p><strong>思想：</strong></p><p>本题我们可以用到快速排序的思想，因为快排的每一轮结束都能确定一个数的最终位置，若该位置小于n-k，则说明第 k 个最大的元素在该位置的右边，若大于k值，则说明在该位置的左边。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left, j = right, num = arr[left];</span><br><span class="line"><span class="keyword">while</span> (i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((arr[j] &gt;= num) &amp;&amp; (i &lt; j))</span><br><span class="line">j--;</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line"><span class="keyword">while</span> ((arr[i] &lt;= num) &amp;&amp; (i &lt; j))</span><br><span class="line">i++;</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = num;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> *arr, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> privot = Partition(left, right, arr);</span><br><span class="line"><span class="keyword">if</span> (privot == n - k)</span><br><span class="line"><span class="keyword">return</span> arr[privot];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(privot&gt;n-k)</span><br><span class="line"><span class="keyword">return</span> QuickSort(left, privot - <span class="number">1</span>, arr, k, n);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> QuickSort(privot + <span class="number">1</span>,right, arr, k, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k,n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k &gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">int</span> num = QuickSort(<span class="number">0</span>, n<span class="number">-1</span>, arr, k, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF2-5.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客将讲述在数据结构中学过的一些排序与查找的具体应用，以及STL中sort的用法讲解，具体内容往下看吧&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;sort的用法&quot;&gt;&lt;a href=&quot;#sort的用法&quot; class=&quot;headerlink&quot; title=&quot;sort的用法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法I:暴力算法</title>
    <link href="http://yoursite.com/2022/01/09/%E7%AE%97%E6%B3%95I-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/01/09/%E7%AE%97%E6%B3%95I-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3/</id>
    <published>2022-01-09T12:55:15.000Z</published>
    <updated>2022-01-17T14:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>考研结束了，专业也结课了，好像一切时间都回到了自己手上，却也知道我的大学生涯只剩下最后六个月了。</p><p>给自己放了两周假，又要投入忙碌的学习中去了。接下来的学习主要有两个主要目的，一个是春招，一个就是毕业设计了。</p><p>考研错过了秋招的各种机遇，需要更加认真的准备一下春招的事，而毕业设计终于开始了我游戏设计的第一步。</p><p>任务还是挺繁重的</p><p>一步一步来吧</p><p><strong>路漫漫其修远兮，吾将上下而求索</strong></p><hr><p>计算机面试或笔试的时候，算法必是躲不掉的一关，这个系列的博客我将汇总一些比较常见的计算机算法思想，然后并配上几道例题加以说明。</p><p>暴力算法是我们在面对题目最容易想到的算法，虽然简单粗暴，但往往行之有效，暴力算法最常用的就是用<strong>枚举</strong>解决问题。</p><p>Eg.</p><h3 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a><strong>ABC</strong></h3><p><strong>题目：</strong></p><p>设a,b,c均是0到9之间的数字，abc,bcc是两个三位数，且有abc+ bcc=532。</p><p>求满足条件的所有 a,b,c的值。</p><p><strong>输入：</strong><br>题目没有任何输入。</p><p><strong>输出：</strong></p><p>请输出所有满足题目条件的a,b,c的值。</p><p>a,b,c之间用空格隔开。</p><p>每个输出占一行。</p><p><strong>思想：</strong></p><p>0-9三重遍历，找到<script type="math/tex">a*100+b*10+c+b*100+c*10+c==532</script>进行输出即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">9</span>; ++a)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">9</span>; ++b) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">9</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (a * <span class="number">100</span> + b * <span class="number">10</span> + c + b * <span class="number">100</span> + c * <span class="number">10</span> + c == <span class="number">532</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-1.jpg" alt=""> </p><h3 id="今年的第几天？"><a href="#今年的第几天？" class="headerlink" title="今年的第几天？"></a>今年的第几天？</h3><p><strong>题目：</strong></p><p>输入年、月、日，计算该天是本年的第几天。</p><p><strong>输入：</strong></p><p>包括3个整数：年（1≤Y≤3000）、月（1≤M≤12）、日（1≤D≤31）。</p><p><strong>输出：</strong></p><p>输入可能有多组测试数据，对于每组测试数据，</p><p>输出一个整数，代表 Input中的年、月、日对应本年的第几天。</p><p><strong>样例输入：</strong></p><p>1990 9 20</p><p>2000 5 1</p><p><strong>样例输出：</strong></p><p>263</p><p>122</p><p><strong>思想：</strong></p><p>首先判断是平年还是闰年，再根据平年和闰年各自对应的月份进行累加</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">2</span>][<span class="number">13</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;,</span><br><span class="line"> &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y, m, d, year, days = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; y &gt;&gt; m &gt;&gt; d;</span><br><span class="line"><span class="keyword">if</span> ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>)||(y % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">year = <span class="number">1</span>;<span class="comment">//闰年</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">year = <span class="number">0</span>;<span class="comment">//平年</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">days += month[year][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; days + d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-2.jpg" alt=""> </p><h3 id="Hello-World-for-U"><a href="#Hello-World-for-U" class="headerlink" title="Hello World for U"></a><strong>Hello World for U</strong></h3><p><strong>题目：</strong></p><p>给定任意N（&gt;=5）个字符的字符串，要求您将字符组成U形。例如，“helloworld”可以打印为：h d e l l r lowo，也就是说，字符必须按原始顺序打印，从带有n1个字符的左垂直线开始自上而下打印，然后，从左到右沿底线使用n2个字符，最后沿垂直线从下到上使用n3个字符。更重要的是，我们希望U是尽可能的平方——也就是说，必须满足n1=n3=max{k | k&lt;=n2，对于所有3&lt;=n2&lt;=N}，n1+n2+n3-2=N。</p><p><strong>输入：</strong></p><p>有多个测试用例。每个大小写包含一个字符串，一行中不少于5个字符，不超过80个字符。字符串不包含空格。</p><p><strong>输出：</strong></p><p>对于每个测试用例，按照描述中指定的U形打印输入字符串。</p><p><strong>样例输入：</strong></p><p>helloworld!</p><p><strong>样例输出：</strong></p><p>h   !<br>e   d<br>l   l<br>lowor</p><p><strong>思想：</strong></p><p>本题最主要的是要理解n1=n3=max{k|k&lt;=n2，对于所有3&lt;=n2&lt;=N}，n1+n2+n3-2=N的含义，该条件要求n1和n3不大于n2，且要满足在n1+n2+n3-2=N条件下取得最大值。故n1=n3=(N+2)/3，而中间空格与最后一行（除去头尾两个字符）的数是N-n1-n2，得出这个条件，本题就不难了。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">int</span> N = s.length();</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line">n1 = n2 = (N + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> mid = N - n1 - n2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mid; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == n1 - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[i + <span class="number">1</span> + j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j != mid)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[N - <span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-src="/photo/SF1-3.jpg" alt=""> </p><hr><p>以上就是本篇博客的全部内容，感谢观看~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考研结束了，专业也结课了，好像一切时间都回到了自己手上，却也知道我的大学生涯只剩下最后六个月了。&lt;/p&gt;
&lt;p&gt;给自己放了两周假，又要投入忙碌的学习中去了。接下来的学习主要有两个主要目的，一个是春招，一个就是毕业设计了。&lt;/p&gt;
&lt;p&gt;考研错过了秋招的各种机遇，需要更加认真
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js入门 II:创建Vue项目</title>
    <link href="http://yoursite.com/2021/10/08/Vue-js%E5%85%A5%E9%97%A8-II-%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/10/08/Vue-js%E5%85%A5%E9%97%A8-II-%E5%88%9B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-10-08T07:02:25.000Z</published>
    <updated>2021-11-02T06:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客我们来讲如何初始化一个Vue项目，需要特别说明一下的是，Vue.js入门系列博客讲的都是Vue2的语法内容，其实此时Vue3.0已经正式发布有一年多的时间了，但鉴于目前大多数项目都还是由Vue2进行编写，我还是决定从Vue2学起，但其实掌握了Vue2，上手Vue3也不会是很长的事。话不多说，请看正文</p><hr><h3 id="初始化Vue项目"><a href="#初始化Vue项目" class="headerlink" title="初始化Vue项目"></a>初始化Vue项目</h3><p>我们在开发一个Vue项目时，往往不会是向我们上一篇博客那样引入一个JS文件，而是会搭建一个项目模板，在模板上面进行修改，那么如何初始化这个模板呢，首先我们需要按Win+R输入cmd（打开命令行），输入如下语句：</p><p><code>npm install -g @vue/cli</code></p><p>这时我们系统就会开始下载vue/cli，当然前提是你已经在电影上装好了npm</p><p>耐心等待一段时间，看到如下画面即代表成功</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-1.jpg" alt=""></p><p>之后进入你想要创建项目的文件夹，可以进入你想要创建项目的文件夹下面，运行如下语句</p><p><code>vue create demo2</code></p><p>这时会让你选择要安装的版本，我们选择Vue2的默认版本即可</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-2.jpg" alt=""></p><p>之后耐心等待，看到如下画面就算成功啦（我这里用了yarn，会跟用npm的有一点小差别）</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-3.jpg" alt=""></p><p>最后我们进入到项目里，输入如下语句</p><p><code>npm run serve</code></p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-4.jpg" alt=""></p><p>当出现上述画面时，我们就成功的初始化了一个Vue项目，在浏览器中进行cmd所提供网址的输入，就能看我Vue项目的初始化网页啦！</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-5.jpg" alt=""></p><h3 id="Vue项目的文件结构"><a href="#Vue项目的文件结构" class="headerlink" title="Vue项目的文件结构"></a>Vue项目的文件结构</h3><p><img src= "/img/loading.gif" data-src="/photo/VUE2-6.jpg" alt=""></p><p><strong>node_modules</strong>    项目依赖模块</p><p><strong>src</strong>    这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</p><ul><li>assets    放置一些图片，如logo等。</li><li>components    用于存放Vue组件</li><li>App.vue    项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</li></ul><p><strong>main.js</strong>    项目的核心文件。</p><p><strong>.gitignore</strong>    用于上传到git时配置的忽视项目</p><p><strong>package.json</strong>    项目配置文件。</p><p><strong>README.md</strong>    项目的说明文档，markdown 格式</p><p>上面我们提到了一个概念：Vue组件，那么什么是Vue组件呢。Vue采用了组件化开发的形式，我们可以自定义多种多样的Vue组件，每个Vue组件代表了不同的功能，我们可以将这些Vue组件进行复用和组合。</p><h3 id="Vue项目的更改"><a href="#Vue项目的更改" class="headerlink" title="Vue项目的更改"></a>Vue项目的更改</h3><p>那么我们应该如何将这一个Vue项目变成我们自己的呢？我们只需要在App.vue上进行修改即可（至于Vue是如何把App.vue挂钩到index文件上这点大家可以去查阅文档或视频了解，但初学者一般不需要了解的这么深入，如何应用框架解决问题才是我们学习的重点）</p><p>App.vue文件分为了三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 网页模板，编写HTML文件,只能存在一个标签 --&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js App&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;JavaScript代码</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;*CSS代码*&#x2F;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>所以我们只需要在里面进行修改，就可以转成我们自己的项目</p><p>Eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1 class&#x3D;&quot;tit&quot;&gt;&#123;&#123;messgae&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;div class&#x3D;&#39;num&#39;&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;reduce&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;&#x2F;&#x2F;要注意的是，在Vue组件中我们写data的方法和引入Vue.js文件写法是不一样的噢</span><br><span class="line">    return&#123;</span><br><span class="line">      messgae:&quot;Hello Vue!&quot;,</span><br><span class="line">      num:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    reduce()&#123;</span><br><span class="line">      this.num--;</span><br><span class="line">    &#125;,</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.tit&#123;</span><br><span class="line">  color: red;</span><br><span class="line">  margin: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.num&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.num button&#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  margin:0 20px; </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE2-7.jpg" alt=""></p><hr><p>以上就是本篇博客的全部内容啦，感谢您的阅读！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客我们来讲如何初始化一个Vue项目，需要特别说明一下的是，Vue.js入门系列博客讲的都是Vue2的语法内容，其实此时Vue3.0已经正式发布有一年多的时间了，但鉴于目前大多数项目都还是由Vue2进行编写，我还是决定从Vue2学起，但其实掌握了Vue2，上手Vue3也
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js入门 I:Hello Vue!</title>
    <link href="http://yoursite.com/2021/10/06/Vue-js%E5%85%A5%E9%97%A8-I-Hello-Vue/"/>
    <id>http://yoursite.com/2021/10/06/Vue-js%E5%85%A5%E9%97%A8-I-Hello-Vue/</id>
    <published>2021-10-06T07:05:57.000Z</published>
    <updated>2021-11-02T06:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>那么终于，历经了一路HTML、CSS与JS的复习之后，终于要进入Vue.js的学习了，这一路磕磕碰碰的完全就是从考研当中硬挤时间来学技术…想想之前的学习路线规划完全错误，真的应该早点学习技术的。算辽，种一棵树最好的时间是十年前，其次是现在，话不多说，我们开始Vue.js的学习！</p><hr><h3 id="Vue-js是什么？"><a href="#Vue-js是什么？" class="headerlink" title="Vue.js是什么？"></a>Vue.js是什么？</h3><p>学一个东西，我们最首先要了解这个东西是什么。就像我们知道HTML是用来创建网页，CSS是用来美化网页，JavaScript是用来修改网页的数据一样，那么Vue.js是什么？老实说，这一开始困扰了我。</p><p>Vue的官方文档给这个问题下了如下定义：</p><blockquote><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><p>我一看，黑人问号脸？？？</p><p>怎么每个字都认识，组合在一起我就不认识了。</p><p>于是我翻遍了网上一系列课程，终于是看到的比较通俗易懂的解释：</p><p>Vue的渐进式指的是其可以自底向上逐层应用，意思就是对于小的应用，我们只需要引入一个轻量小巧的核心库，而对于复杂大型的应用，我们可以引入各种各样的Vue插件，来达到所谓“渐进式”的效果。</p><p>JavaScript框架，指以Javascript语言为基础搭建的编程框架，意思就是我们可以通过Vue来实现JS中的各种操作。</p><p>那么了解完了Vue.js是什么，就让我们开始试着写Vue的第一个程序吧！</p><h3 id="Hello-Vue！"><a href="#Hello-Vue！" class="headerlink" title="Hello Vue！"></a>Hello Vue！</h3><p>话不多说，上代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:&#39;.app&#39;,&#x2F;&#x2F;挂载实例，可以是DOM元素、CSS选择器、HTML标签</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#39;Hello Vue!&#39;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-1.jpg" alt=""></p><p>可以看到，通过Vue.js框架最大的特点就是我们简化了DOM的操作，以前我们要修改文本的数据，可能就要先通过DOM获取h1标签，再通过InnerHTML进行修改，而通过Vue.js我们就省略了这些繁琐的步骤，每当我们想修改message的值时只需要修改data里的值即可</p><h3 id="绑定属性与事件"><a href="#绑定属性与事件" class="headerlink" title="绑定属性与事件"></a>绑定属性与事件</h3><p>那么我们有没有办法通过Vue.js来绑定HTML标签的属性以及为元素绑定事件呢？当然是可以的</p><p>我们<strong>通过v-bind和v-on分别来绑定属性和事件</strong></p><p>v-bind:直接跟在所需要绑定的属性前面，可简写为:</p><p>v-on:后需添加事件的名称，可简写为@</p><p>下面是通过点击按钮切换图片的一个小栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .app img&#123;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;img v-bind:src&#x3D;&quot;url&quot;&gt;      &lt;!-- 可简写为&lt;img :src&#x3D;&quot;url&quot;&gt;  --&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;change&quot;&gt;更换图片&lt;&#x2F;button&gt;        &lt;!-- 可简写为&lt;button @click&#x3D;&quot;change&quot;&gt;  --&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:&#39;.app&#39;,</span><br><span class="line">            data:&#123;          &#x2F;&#x2F;用于存数据</span><br><span class="line">                message:&#39;Hello Vue!&#39;,</span><br><span class="line">                url:&#39;img&#x2F;1.jpg&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;       &#x2F;&#x2F;用户写方法</span><br><span class="line">                change()&#123;</span><br><span class="line">                    if(this.url&#x3D;&#x3D;&quot;img&#x2F;1.jpg&quot;)</span><br><span class="line">                        this.url&#x3D;&quot;img&#x2F;2.jpg&quot;;</span><br><span class="line">                    else</span><br><span class="line">                        this.url&#x3D;&quot;img&#x2F;1.jpg&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-2.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="/photo/VUE1-3.jpg" alt=""></p><hr><p>以上就是Vue.js的第一篇入门博客，当然讲的很浅，里面很多东西都会在后续的更新中进行扩展，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;那么终于，历经了一路HTML、CSS与JS的复习之后，终于要进入Vue.js的学习了，这一路磕磕碰碰的完全就是从考研当中硬挤时间来学技术…想想之前的学习路线规划完全错误，真的应该早点学习技术的。算辽，种一棵树最好的时间是十年前，其次是现在，话不多说，我们开始Vue.js的学
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法:查找II-哈希表</title>
    <link href="http://yoursite.com/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BEII-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BEII-%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-09-28T14:09:15.000Z</published>
    <updated>2021-09-29T14:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇博客，我们将迎来数据结构与算法系列博客的最后一个内容——哈希表</p><hr><h3 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h3><p>哈希表（Hash table，也叫散列表），是根据关键字（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个<strong>映射函数称做哈希（散列）函数</strong>，<strong>存放记录的数组称做哈希（散列）表</strong>。哈希冲突指的是两个或两个以上的不同关键字映射到同一地址，这种情况我们称为<strong>冲突</strong>，而发生冲突的不同关键字叫做<strong>同义词</strong>。</p><p>其实哈希表本质上就是一个数组，只不过我们通过各种映射手段，让这个数组不一般了起来。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>那么我们如何构造关键字与地址的映射呢？通常有以下几种方法（以下摘自百科）</p><p><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p><p><strong>数字分析法</strong>：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><p><strong>平方取中法</strong>：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p><p><strong>除留余数法</strong>：最常用的一种方法，取关键字除以某个不大于散列表表长的数p后所得的余数为散列地址。即 H(key) = key MOD p，一般P取不大于表长的最大素数，这样可以减少冲突。</p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>在Hash表中遇到冲突是在正常不过了，那么我们该如何处理这些冲突呢？通常有以下几种方法</p><p><strong>开放寻址法</strong>：$H_i=(H(key) + d_i) MOD P,i=1,2，…，k(k&lt;=m-1）$，其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：</p><ul><li>$di=1,2,3，…，m-1$，称线性探测法</li><li>$di=1^2,-1^2,2^2,-2^2，3^2，-3^2…，±k^2,(k&lt;=m/2）$称平方探测法</li><li>$di=伪随机数序列$，称伪随机探测法</li></ul><p><strong>再散列法</strong>：即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p><p><strong>链地址法（拉链法）</strong>：即在映射地址下构建链表，若有新的同义词则接到该链表后面</p><p><img src= "/img/loading.gif" data-src="/photo/SH2-1.jpg" alt=""> </p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>哈希表的实现有多种方式，这里提供一个用除留余数法并用线性探测法解决冲突的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 11<span class="comment">//一般P取不大于表长的最大素数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> elem[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> count;<span class="comment">//当前元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHash</span><span class="params">(HashTable &amp;ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">ht.elem[i] = <span class="number">-1</span>;</span><br><span class="line">ht.count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertHash</span><span class="params">(HashTable &amp;ht,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr = key % P;</span><br><span class="line"><span class="keyword">if</span> (ht.elem[addr] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mark = addr;</span><br><span class="line"><span class="keyword">int</span> temp = key + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">addr = temp % P;<span class="comment">//开放定址法中的线性探测法上</span></span><br><span class="line">temp++;</span><br><span class="line">&#125; <span class="keyword">while</span> (ht.elem[addr] &gt; <span class="number">0</span> &amp;&amp; mark != addr);</span><br><span class="line"><span class="keyword">if</span> (mark == addr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ht.elem[addr] = key;</span><br><span class="line">ht.count++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTable</span><span class="params">(HashTable ht, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr = key % P;</span><br><span class="line"><span class="keyword">if</span> (ht.elem[addr] != key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mark = addr;</span><br><span class="line"><span class="keyword">int</span> temp = key + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">addr = temp % P;<span class="comment">//开放定址法</span></span><br><span class="line">temp++;</span><br><span class="line">&#125; <span class="keyword">while</span> (ht.elem[addr] !=key &amp;&amp; mark != addr &amp;&amp; ht.elem[addr] != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (mark == addr|| ht.elem[addr]==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteElem</span><span class="params">(HashTable &amp;ht, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=SearchTable(ht, key);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ht.elem[res] = <span class="number">-1</span>;</span><br><span class="line">ht.count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> &#125;;</span><br><span class="line">HashTable ht;</span><br><span class="line">InitHash(ht);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">InsertHash(ht, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> res = SearchTable(ht, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1的位置是："</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DeleteElem(ht, <span class="number">7</span>);</span><br><span class="line">InsertHash(ht, <span class="number">12</span>);</span><br><span class="line">res=SearchTable(ht, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"12的位置是："</span> &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/SH2-2.jpg" alt=""> </p><hr><p>以上，就是数据结构与算法系列博客的全部内容啦！</p><p>当然不排除后面还会进行一些补充，那就有缘再会咯~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本篇博客，我们将迎来数据结构与算法系列博客的最后一个内容——哈希表&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;哈希表的定义&quot;&gt;&lt;a href=&quot;#哈希表的定义&quot; class=&quot;headerlink&quot; title=&quot;哈希表的定义&quot;&gt;&lt;/a&gt;哈希表的定义&lt;/h3&gt;&lt;p&gt;哈希表（Has
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript入门VII:BOM</title>
    <link href="http://yoursite.com/2021/09/26/JavaScript%E5%85%A5%E9%97%A8VII-BOM/"/>
    <id>http://yoursite.com/2021/09/26/JavaScript%E5%85%A5%E9%97%A8VII-BOM/</id>
    <published>2021-09-26T11:40:50.000Z</published>
    <updated>2021-09-27T12:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客我们简单聊一下JS中的BOM</p><hr><h3 id="BOM的定义"><a href="#BOM的定义" class="headerlink" title="BOM的定义"></a>BOM的定义</h3><p>BOM是浏览器对象模型（Browser Object Model ）其允许 JavaScript 与浏览器对话，像我们之前用到document、setInterval等等其实都是BOM的内容，只不过我们省略了<em>window</em>对象，其代表就是浏览器的窗口，像这些方法的全称其实是window.document、window.setInterval</p><h3 id="常见的BOM方法"><a href="#常见的BOM方法" class="headerlink" title="常见的BOM方法"></a>常见的BOM方法</h3><p>其实BOM的内容很简单，不需要刻意去学习，只需要翻看一下文档就能明白个百分之八九十，这里我把常见的几种BOM方法列举一下（均省略了window对象）</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><ul><li>location.href       返回当前页面的 href (URL)</li><li>location.hostname       返回 web 主机的域名</li><li>location.pathname       返回当前页面的路径或文件名</li><li>location.protocol       返回使用的 web 协议（http: 或 https:）</li></ul><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><ul><li>screen.width        返回屏幕宽度</li><li>screen.height        返回屏幕高度</li><li>screen.availWidth        返回屏幕可用宽度</li><li>screen.availHeight        返回屏幕可用高度</li></ul><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><ul><li>history.back()        等同于在浏览器点击后退按钮</li><li>history.forward()        等同于在浏览器中点击前进按钮</li></ul><h4 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h4><p>弹出框可能是我们在JS中最常用到的BOM功能，在JS中有以下三种弹出框形式</p><ul><li>alert(“文本”)        警示框</li><li>confirm(“文本”)        确认框</li><li>prompt(“文本”,”输入框内容”)      输入框</li></ul><p>Eg.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alt()"</span>&gt;</span>警告框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"con()"</span>&gt;</span>确认框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"inp()"</span>&gt;</span>输入框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">alt</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"警告！"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">con</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> res = confirm(<span class="string">"您确定要继续吗？"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">inp</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> name = prompt(<span class="string">"请输入你的姓名"</span>,<span class="string">""</span>)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(name);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/JSX4-1.jpg" alt=""><img src= "/img/loading.gif" data-src="/photo/JSX4-2.jpg" alt=""><img src= "/img/loading.gif" data-src="/photo/JSX4-3.jpg" alt=""></p><hr><p>以上就是本篇博客的全部内容啦，要看更多BOM的使用方法可用上WC3官网(<a href="https://www.w3school.com.cn/js/js_window.asp)翻阅文档噢~" target="_blank" rel="noopener">https://www.w3school.com.cn/js/js_window.asp)翻阅文档噢~</a></p><p>同时JavaScript入门篇也在这里正式完结啦，当然JS还有很多内容等待深挖，后续看看会不会接着更新进阶篇吧（如果后面工作真走了前端的方向话…）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客我们简单聊一下JS中的BOM&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;BOM的定义&quot;&gt;&lt;a href=&quot;#BOM的定义&quot; class=&quot;headerlink&quot; title=&quot;BOM的定义&quot;&gt;&lt;/a&gt;BOM的定义&lt;/h3&gt;&lt;p&gt;BOM是浏览器对象模型（Browser Obj
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="BOM" scheme="http://yoursite.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript入门VI:计时器</title>
    <link href="http://yoursite.com/2021/09/21/JavaScript%E5%85%A5%E9%97%A8VI-%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2021/09/21/JavaScript%E5%85%A5%E9%97%A8VI-%E8%AE%A1%E6%97%B6%E5%99%A8/</id>
    <published>2021-09-21T11:00:06.000Z</published>
    <updated>2021-09-26T11:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中，我们有四种常用的方法来实现计时器的功能，本篇博客就将讲述这些方法~</p><hr><h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><h4 id="setInterval与clearInterval"><a href="#setInterval与clearInterval" class="headerlink" title="setInterval与clearInterval"></a>setInterval与clearInterval</h4><ul><li>setInterval(函数，时间)</li><li>clearInterval(setInterva返回参数)</li></ul><p>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式，该方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。下面是一个显示系统时间和秒表的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"start"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"pause"</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"clean"</span>&gt;</span>清零<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>0:0<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> h1 = <span class="built_in">document</span>.querySelector(<span class="string">"h1"</span>);</span></span><br><span class="line"><span class="javascript">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> h = date.getHours();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> m = date.getMinutes();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> s = date.getSeconds(); </span></span><br><span class="line"><span class="javascript">            h1.innerHTML=<span class="string">`<span class="subst">$&#123;h&#125;</span>:<span class="subst">$&#123;m&#125;</span>:<span class="subst">$&#123;h&#125;</span>`</span></span></span><br><span class="line">        &#125;,500);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/JSX3-1.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"start"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"pause"</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"clean"</span>&gt;</span>清零<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>0:0<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> h2 = <span class="built_in">document</span>.querySelector(<span class="string">"h2"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> start = <span class="built_in">document</span>.querySelector(<span class="string">".start"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> pause = <span class="built_in">document</span>.querySelector(<span class="string">".pause"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> clean = <span class="built_in">document</span>.querySelector(<span class="string">".clean"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// &#125;,500)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ms=<span class="number">0</span>,s=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> mb=<span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">        start.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            clearInterval(mb)       <span class="comment">//防止生成多个计时器</span></span></span><br><span class="line"><span class="javascript">            mb = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">                if(ms==9)</span><br><span class="line">                &#123;</span><br><span class="line">                    ms=0;</span><br><span class="line">                    s++;</span><br><span class="line">                &#125;</span><br><span class="line">                ms++</span><br><span class="line"><span class="javascript">                h2.innerHTML=<span class="string">`<span class="subst">$&#123;s&#125;</span>:<span class="subst">$&#123;ms&#125;</span>`</span></span></span><br><span class="line">            &#125;,100)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        pause.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">            clearInterval(mb)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        clean.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">           s=0;</span><br><span class="line">           ms=0;</span><br><span class="line"><span class="javascript">           h2.innerHTML=<span class="string">`<span class="subst">$&#123;s&#125;</span>:<span class="subst">$&#123;ms&#125;</span>`</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/JSX3-2.jpg" alt=""></p><h4 id="setTimeout与clearTimeout"><a href="#setTimeout与clearTimeout" class="headerlink" title="setTimeout与clearTimeout"></a>setTimeout与clearTimeout</h4><ul><li>setTimeout(函数，时间)</li><li>clearTimeout(setTimeout返回的参数)</li></ul><p>setTimeout与setInterval最主要的区别就是其只执行一次，即用于在指定的毫秒数后调用函数或计算表达式，因此我们常用这一方式来实现防抖和节流的功能。</p><p>什么是防抖与节流呢？</p><ul><li><strong>防抖:</strong>对于短时间内多次触发事件的情况,可以使用防抖停止事件持续触发。</li><li><strong>节流:</strong>防止短时间内多次触发事件的情况,但是间隔时间内,还是需要不断触发。</li></ul><p>就好比如网页常有的返回顶部功能一样，若我们不对该功能加上防抖或节流，那么在我们使用滚动条时该事件会变一直触发，这样就导致了资源的浪费，这时候我们就需要防抖和节流来进行控制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="keyword">let</span> timer=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(timer!=<span class="literal">null</span>)</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">timer=setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">timer=<span class="literal">null</span>;</span><br><span class="line">&#125;,<span class="number">500</span>) <span class="comment">//在500ms结束时里面的代码不会被执行,timer等于setTimeout的返回值，就会一直被clear</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="keyword">let</span> mark=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mark)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        mark=<span class="literal">true</span>;</span><br><span class="line">&#125;,<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">mark=<span class="literal">false</span>;     <span class="comment">//保证在上个事件的mark还未变成true时新的事件调用不被执行</span></span><br></pre></td></tr></table></figure><p>下面是实习返回顶部防抖的例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        button&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            bottom: 50px;</span><br><span class="line">            right: 50px;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            height: 5000px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖与节流<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//通过闭包封装防抖</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> timer=<span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">eventFun</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(timer!=<span class="literal">null</span>)</span></span><br><span class="line">                    clearTimeout(timer);</span><br><span class="line"><span class="javascript">                timer=setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">                    fn();</span><br><span class="line"><span class="actionscript">                    timer=<span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">                &#125;,<span class="number">500</span>)      <span class="comment">//在500ms结束时里面的代码不会被执行,timer等于setTimeout的返回值，就会一直被clear</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> eventFun</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">//通过闭包封装节流</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">throttle</span><span class="params">(fn)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> mark=<span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">eventFun</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                if(mark)&#123;</span><br><span class="line"><span class="javascript">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">                        fn();</span><br><span class="line"><span class="actionscript">                        mark=<span class="literal">true</span>;</span></span><br><span class="line">                    &#125;,500)</span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                mark=<span class="literal">false</span>;     <span class="comment">//保证在上个事件的mark还未变成true时新的事件调用不被执行</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> eventFun</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="actionscript">        btn.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 为滚动条添加功能，保证在非顶部才出现返回顶部功能</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onscroll=debounce(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"计数器"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(<span class="built_in">document</span>.documentElement.scrollTop&gt;<span class="number">0</span>)&#123;   <span class="comment">// 距离顶部大于0</span></span></span><br><span class="line"><span class="actionscript">                btn.style.display=<span class="string">"block"</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                btn.style.display=<span class="string">"none"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/JSX3-3.jpg" alt=""></p><h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><p>结合前面的代码知识和计时，我们就可以写一个网页中常见的轮播图效果啦</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        button&#123;</span><br><span class="line">            width: 20px;</span><br><span class="line">            height: 20px;</span><br><span class="line">            font-size: 5px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">            width: 800px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.imgcon</span>&#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 0<span class="selector-class">.4s</span> <span class="selector-tag">linear</span>;</span></span><br><span class="line">            width: 2400px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.imgcon</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line">            width: 800px;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.but</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            bottom: 10px;</span><br><span class="line">            left: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imgcon"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"but"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> btn=<span class="built_in">document</span>.querySelectorAll(<span class="string">"button"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> con=<span class="built_in">document</span>.querySelector(<span class="string">".imgcon"</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> flag=<span class="number">0</span></span></span><br><span class="line"><span class="javascript">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">            if(flag&gt;=3)</span><br><span class="line">                flag=0;</span><br><span class="line"><span class="javascript">            con.style.transform=<span class="string">`translate(<span class="subst">$&#123;<span class="number">-800</span>*flag&#125;</span>px)`</span></span></span><br><span class="line">            flag++;</span><br><span class="line">        &#125;,2000)</span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> btn)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="actionscript">            btn[i].onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=i;</span><br><span class="line"><span class="javascript">                con.style.transform=<span class="string">`translate(<span class="subst">$&#123;<span class="number">-800</span>*i&#125;</span>px)`</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/JSX3-4.jpg" alt=""></p><hr><p>以上就是本篇博客的全部内容，感谢您的阅读~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JavaScript中，我们有四种常用的方法来实现计时器的功能，本篇博客就将讲述这些方法~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;计时&quot;&gt;&lt;a href=&quot;#计时&quot; class=&quot;headerlink&quot; title=&quot;计时&quot;&gt;&lt;/a&gt;计时&lt;/h3&gt;&lt;h4 id=&quot;setInt
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法:图VII-关键路径</title>
    <link href="http://yoursite.com/2021/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BEVII-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2021/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BEVII-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2021-09-15T13:24:40.000Z</published>
    <updated>2022-02-08T01:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客讲解图的最后一个知识点——关键路径</p><hr><h3 id="AOV网与AOE网"><a href="#AOV网与AOE网" class="headerlink" title="AOV网与AOE网"></a>AOV网与AOE网</h3><p><strong>AOV网</strong>：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之AOV网。</p><p><img src= "/img/loading.gif" data-src="/photo/GP7-1.jpg" alt=""></p><p><strong>AOE网</strong>：在一个表示工程的带权有向图中，<strong>用顶点表示事件，用弧表示活动</strong>，用<strong>弧上的权值表示活动持续的时间</strong>，这种有向图的弧表示活动的网，我们称为AOE网。AOE网中没有入度的顶点称为始点或源点，没有出度的顶点叫做终点或汇点，<strong>AOE只有一个始点和一个终点</strong>。    </p><p><img src= "/img/loading.gif" data-src="/photo/GP7-2.jpg" alt=""></p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>关键路径，即完成整个在AOE网中从源点到汇点的最大路径长度（也是完成事件所要求的最短时间），关键路径上的活动我们称为<strong>关键活动</strong></p><p><img src= "/img/loading.gif" data-src="/photo/GP7-3.jpg" alt=""></p><p>找出关键路径，我们需要明白以下几个概念：</p><p><strong>事件Vn最早发生时间</strong>：指从源点V1到Vn的最大路径长度，Vn的最早发生时间决定了Vn后面事件的最早开始时间，其计算公式如下：</p><ul><li>V0=0（源点）</li><li>Vn=Max{Vn+Weight(Vm,Vn)}，其中Vm为Vn的后继事件</li></ul><p><strong>事件Vn的最迟发生时间</strong>：指不推迟整个工程的前提下，事件的最晚开始时间，其计算公式如下：</p><ul><li>Ve（终点）</li><li>Vn=Min{Ve-Weight(Ve,Vn)}，其中Vn为Ve的前驱事件</li></ul><p><strong>活动的最早开始时间</strong>：活动起点事件的最早发生时间</p><p><strong>活动的最迟开始时间</strong>：活动终点事件的最迟发生时间－该活动的时间</p><p><strong>活动时间余量</strong>：活动最迟开始时间－活动最早开始时间，若活动时间余量为0，则说明该活动是关键活动</p><p>这样一来，我们就得到了<strong>关键路径的算法步骤如下</strong>：</p><ol><li>从源点出发，按拓扑排序求得所有顶点（事件）的最早发生时间</li><li>从终点出发，按逆拓扑排序求得所有顶点（事件）的最迟发生时间</li><li>根据最早发生时间和最短发生时间求得活动的最早开始时间和最迟开始时间</li><li>计算所有活动时间的余量，为0的活动就构成了关键路径</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 9999 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VexNum 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EdgeNum 4</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> Vex[MAXSIZE];<span class="comment">//顶点数据，可修改为自己使用的类型</span></span><br><span class="line"><span class="keyword">int</span> Edge[MAXSIZE][MAXSIZE];<span class="comment">//边之间的关系</span></span><br><span class="line"><span class="keyword">int</span> v, e;<span class="comment">//当前矩阵的顶点数和弧数</span></span><br><span class="line">&#125;Mgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//该边所指向的结点位置</span></span><br><span class="line"><span class="keyword">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一条弧</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *frist;<span class="comment">//指向第一条边的指针1</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">VNode adjlist[MAXSIZE];<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> v, e;<span class="comment">//顶点数和弧数</span></span><br><span class="line">&#125;ALgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> s;<span class="comment">//指向活动开始事件</span></span><br><span class="line"><span class="keyword">int</span> e;<span class="comment">//指向活动结束事件</span></span><br><span class="line"><span class="keyword">int</span> time;<span class="comment">//活动时长</span></span><br><span class="line">&#125;Activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">VNode adjlist[MAXSIZE];<span class="comment">//逆邻接表</span></span><br><span class="line"><span class="keyword">int</span> v, e;<span class="comment">//顶点数和弧数</span></span><br><span class="line">&#125;RALgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> et[VexNum];<span class="comment">//活动最早发生时间</span></span><br><span class="line"><span class="keyword">int</span> lt[VexNum];<span class="comment">//活动最晚发生时间</span></span><br><span class="line">Activity eact[EdgeNum];<span class="comment">//事件最早发生时间</span></span><br><span class="line">Activity lact[EdgeNum];<span class="comment">//事件最晚发生时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGraph</span><span class="params">(ALgraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">G.adjlist[i].frist = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">G.e = <span class="number">0</span>;</span><br><span class="line">G.v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGraph</span><span class="params">(RALgraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">G.adjlist[i].frist = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">G.e = <span class="number">0</span>;</span><br><span class="line">G.v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMGraph</span><span class="params">(Mgraph &amp;M, <span class="keyword">char</span> v[], <span class="keyword">int</span> e[][VexNum])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">M.Vex[i] = v[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; VexNum; j++)</span><br><span class="line">&#123;</span><br><span class="line">M.Edge[i][j] = e[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">M.e = EdgeNum;</span><br><span class="line">M.v = VexNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(ALgraph &amp;G, Mgraph M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.v; i++)</span><br><span class="line">&#123;</span><br><span class="line">G.adjlist[i].data = M.Vex[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.v; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (M.Edge[i][j] != INF &amp;&amp; M.Edge[i][j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ArcNode *arc = <span class="keyword">new</span> ArcNode;</span><br><span class="line">arc-&gt;weight = M.Edge[i][j];</span><br><span class="line">arc-&gt;adjvex = j;</span><br><span class="line">arc-&gt;next = G.adjlist[i].frist;</span><br><span class="line">G.adjlist[i].frist = arc;<span class="comment">//采用头插法插入结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G.e = M.e;</span><br><span class="line">G.v = M.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateRGraph</span><span class="params">(RALgraph &amp;G, Mgraph M)</span><span class="comment">//创建逆邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.v; i++)</span><br><span class="line">&#123;</span><br><span class="line">G.adjlist[i].data = M.Vex[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.v; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (M.Edge[j][i] != INF &amp;&amp; M.Edge[j][i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ArcNode *arc = <span class="keyword">new</span> ArcNode;</span><br><span class="line">arc-&gt;weight = M.Edge[j][i];</span><br><span class="line">arc-&gt;adjvex = j;</span><br><span class="line">arc-&gt;next = G.adjlist[i].frist;</span><br><span class="line">G.adjlist[i].frist = arc;<span class="comment">//采用头插法插入结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G.e = M.e;</span><br><span class="line">G.v = M.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(ALgraph &amp;G, <span class="keyword">int</span> index)</span><span class="comment">//返回v的第一个邻接顶点的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjlist[index].frist == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> locate = G.adjlist[index].frist-&gt;adjvex;</span><br><span class="line"><span class="keyword">return</span> locate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(ALgraph G, <span class="keyword">int</span> vindex, <span class="keyword">int</span> windex)</span><span class="comment">//w为v的其中一个邻接点，返回w后面的一个邻接点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">VNode v = G.adjlist[vindex];</span><br><span class="line">VNode w = G.adjlist[windex];</span><br><span class="line">ArcNode *arc = v.frist;</span><br><span class="line"><span class="keyword">while</span> (arc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjlist[arc-&gt;adjvex].data == w.data&amp;&amp;G.adjlist[arc-&gt;adjvex].frist == w.frist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arc-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> locate = arc-&gt;next-&gt;adjvex;</span><br><span class="line"><span class="keyword">return</span> locate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arc = arc-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Eact</span><span class="params">(ALgraph G)</span><span class="comment">//获取活动最早开始时间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[i].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">eact[n].s = i;</span><br><span class="line">eact[n].e = p-&gt;adjvex;</span><br><span class="line">eact[n].time = et[i];<span class="comment">//起点事件的最早发生时间</span></span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Lact</span><span class="params">(ALgraph G)</span><span class="comment">//获取活动最迟开始时间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[i].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">lact[n].s = i;</span><br><span class="line">lact[n].e = p-&gt;adjvex;</span><br><span class="line">lact[n].time = lt[p-&gt;adjvex] - p-&gt;weight;<span class="comment">//终点事件的最迟发生时间－该活动的时间</span></span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Etime</span><span class="params">(ALgraph G, <span class="keyword">int</span> tp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">et[i] = <span class="number">-1</span>;</span><br><span class="line">et[tp[<span class="number">0</span>]] = <span class="number">0</span>;<span class="comment">//始点时间为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[tp[i]].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;weight + et[tp[i]] &gt; et[p-&gt;adjvex])<span class="comment">//Vn=Max&#123;Vn+Weight(Vm,Vn)&#125;，其中Vm为Vn的后继事件</span></span><br><span class="line">et[p-&gt;adjvex] = p-&gt;weight + et[tp[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; VexNum; i++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt; et[i] &lt;&lt; " ";*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TP_Etime</span><span class="params">(ALgraph G)</span><span class="comment">//用拓扑排序获取事件最早发生时间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> locate = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//用vector代替栈</span></span><br><span class="line"><span class="keyword">int</span> indegree[VexNum];<span class="comment">//存放各个结点的入度</span></span><br><span class="line"><span class="keyword">int</span> res[VexNum];<span class="comment">//记录拓扑排序的输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++) </span><br><span class="line">&#123;</span><br><span class="line">indegree[i] = <span class="number">0</span>;</span><br><span class="line">res[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)<span class="comment">//获取入度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[i].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">indegree[p-&gt;adjvex]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!v.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = v.back();</span><br><span class="line">v.pop_back();</span><br><span class="line">res[locate++] = l;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[l].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)<span class="comment">//更新入度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (indegree[n] - <span class="number">1</span> == <span class="number">0</span>)<span class="comment">//若更新后入度为0，则入栈</span></span><br><span class="line">&#123;</span><br><span class="line">indegree[n]--;</span><br><span class="line">v.push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">indegree[n]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; G.v; i++)//输出拓扑排序结果</span></span><br><span class="line"><span class="comment">cout &lt;&lt; res[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;*/</span></span><br><span class="line">Get_Etime(G, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Ltime</span><span class="params">(RALgraph G, <span class="keyword">int</span> tp[],<span class="keyword">int</span> lastime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">lt[i] = INF;</span><br><span class="line">lt[tp[<span class="number">0</span>]] = lastime;<span class="comment">//终点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VexNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[tp[i]].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lt[tp[i]] - p-&gt;weight &lt; lt[p-&gt;adjvex])<span class="comment">//Vn=Min&#123;Ve-Weight(Ve,Vn)&#125;，其中Vn为Ve的前驱事件</span></span><br><span class="line">lt[p-&gt;adjvex] = lt[tp[i]] - p-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; VexNum; i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; lt[i] &lt;&lt; " ";*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RTP_Ltime</span><span class="params">(RALgraph G,<span class="keyword">int</span> lastime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> locate = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//用vector代替栈</span></span><br><span class="line"><span class="keyword">int</span> oudegree[VexNum];<span class="comment">//存放各个结点的入度</span></span><br><span class="line"><span class="keyword">int</span> res[VexNum];<span class="comment">//记录拓扑排序的输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)</span><br><span class="line">&#123;</span><br><span class="line">oudegree[i] = <span class="number">0</span>;</span><br><span class="line">res[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)<span class="comment">//获取出度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[i].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">oudegree[p-&gt;adjvex]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (oudegree[i] == <span class="number">0</span>)</span><br><span class="line">v.push_back(i);<span class="comment">//出度为0的结点进行输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!v.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = v.back();</span><br><span class="line">v.pop_back();</span><br><span class="line">res[locate++] = l;</span><br><span class="line"><span class="keyword">for</span> (ArcNode* p = G.adjlist[l].frist; p != <span class="literal">NULL</span>; p = p-&gt;next)<span class="comment">//更新出度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (oudegree[n] - <span class="number">1</span> == <span class="number">0</span>)<span class="comment">//若更新后出度为0，则入栈</span></span><br><span class="line">&#123;</span><br><span class="line">oudegree[n]--;</span><br><span class="line">v.push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">oudegree[n]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; endl &lt;&lt; "逆拓扑排序:";</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; G.v; i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; res[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;*/</span></span><br><span class="line">Get_Ltime(G, res, lastime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Key_road</span><span class="params">(ALgraph G,RALgraph R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TP_Etime(G);</span><br><span class="line">RTP_Ltime(R, et[VexNum - <span class="number">1</span>]);</span><br><span class="line">Get_Eact(G);</span><br><span class="line">Get_Lact(G);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"关键路径为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; EdgeNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((eact[i].time - lact[i].time) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lact[i].s &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; lact[i].e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mgraph M;</span><br><span class="line">ALgraph G;</span><br><span class="line">RALgraph R;</span><br><span class="line"><span class="keyword">char</span> v[VexNum] = &#123; <span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> e[VexNum][VexNum] = &#123; &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,INF&#125;,&#123;INF,<span class="number">0</span>,<span class="number">3</span>,INF&#125;,&#123;INF,INF,<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;INF,INF,INF,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">CreateMGraph(M, v, e);</span><br><span class="line">InitGraph(G);</span><br><span class="line">InitGraph(R);</span><br><span class="line">CreateGraph(G, M);</span><br><span class="line">CreateRGraph(R, M);</span><br><span class="line">Key_road(G, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/photo/GP7-4.jpg" alt=""></p><p>运行结果：</p><p><img src= "/img/loading.gif" data-src="/photo/GP7-5.jpg" alt=""></p><hr><p>以上就是图的全部内容，感谢您的收看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客讲解图的最后一个知识点——关键路径&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;AOV网与AOE网&quot;&gt;&lt;a href=&quot;#AOV网与AOE网&quot; class=&quot;headerlink&quot; title=&quot;AOV网与AOE网&quot;&gt;&lt;/a&gt;AOV网与AOE网&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="关键路径" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
</feed>
