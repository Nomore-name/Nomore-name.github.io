<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++中的STL:set、map、stack、queue的基本使用 | K`onnor</title><meta name="description" content="本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器  关联式容器关联式容器在存储元素值时会为各元素额外再配备一个值，又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。 关联式容器可以快速查找、读取或者删除所存储的元素，同时该类"><meta name="keywords" content="STL,C++,set,map,stack,queue"><meta name="author" content="KangKang"><meta name="copyright" content="KangKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="C++中的STL:set、map、stack、queue的基本使用"><meta property="og:url" content="http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="K`onnor"><meta property="og:description" content="本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器  关联式容器关联式容器在存储元素值时会为各元素额外再配备一个值，又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。 关联式容器可以快速查找、读取或者删除所存储的元素，同时该类"><meta property="og:image" content="http://yoursite.com/photo/CSTL.png"><meta property="article:published_time" content="2022-03-10T08:07:30.000Z"><meta property="article:modified_time" content="2022-04-04T09:16:59.482Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="C++类型转换运算符" href="http://yoursite.com/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"><link rel="next" title="C++中的STL:vector、list、deque的基本使用" href="http://yoursite.com/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="K`onnor" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">89</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画册</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关联式容器"><span class="toc-number">1.</span> <span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pair对组"><span class="toc-number">1.1.</span> <span class="toc-text">pair对组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset容器"><span class="toc-number">1.2.</span> <span class="toc-text">set&#x2F;multiset容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set构造函数"><span class="toc-number">1.2.1.</span> <span class="toc-text">set构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set赋值操作"><span class="toc-number">1.2.2.</span> <span class="toc-text">set赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set大小操作"><span class="toc-number">1.2.3.</span> <span class="toc-text">set大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set数据操作"><span class="toc-number">1.2.4.</span> <span class="toc-text">set数据操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set查找操作"><span class="toc-number">1.2.5.</span> <span class="toc-text">set查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set排序方式的修改"><span class="toc-number">1.2.6.</span> <span class="toc-text">set排序方式的修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-multimap容器"><span class="toc-number">1.3.</span> <span class="toc-text">map&#x2F;multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map构造函数"><span class="toc-number">1.3.1.</span> <span class="toc-text">map构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map赋值操作"><span class="toc-number">1.3.2.</span> <span class="toc-text">map赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map大小操作"><span class="toc-number">1.3.3.</span> <span class="toc-text">map大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map数据操作"><span class="toc-number">1.3.4.</span> <span class="toc-text">map数据操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map删除操作"><span class="toc-number">1.3.5.</span> <span class="toc-text">map删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map查找操作"><span class="toc-number">1.3.6.</span> <span class="toc-text">map查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的map问题"><span class="toc-number">1.3.7.</span> <span class="toc-text">常见的map问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器适配器"><span class="toc-number">2.</span> <span class="toc-text">容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">2.1.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">2.2.</span> <span class="toc-text">queue</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/photo/CSTL.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">K`onnor</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画册</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++中的STL:set、map、stack、queue的基本使用</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-03-10 16:07:30"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-03-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-04-04 17:16:59"><i class="fas fa-history fa-fw"></i> 更新于 2022-04-04</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇我们接着讲述STL容器的使用，本篇博客将讲完STL中剩下四个常用的容器</p>
<hr>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>关联式容器在存储元素值时会<strong>为各元素额外再配备一个值，又称为“键”</strong>，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p>
<p>关联式容器<strong>可以快速查找、读取或者删除所存储的元素</strong>，同时该类型容器<strong>插入元素的效率也比序列式容器高</strong>。</p>
<p>也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，<strong>而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序</strong>。</p>
<ul>
<li><strong>map</strong>    定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根<strong>据各元素键的大小，默认进行升序排序</strong>（调用 std::less<T>）</li>
<li><strong>multimap</strong>    定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复</li>
<li><strong>set</strong>    定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个<strong>元素的键的大小进行升序排序</strong>（调用 std::less<T>）</li>
<li><strong>multiset</strong>    定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）</li>
</ul>
<h3 id="pair对组"><a href="#pair对组" class="headerlink" title="pair对组"></a>pair对组</h3><p>在正式介绍关联式容器之前，先介绍一下对组pair，对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问</p>
<p>类模板：template <class T1, class T2> struct pair. </p>
<p>Eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pair&lt;string, int&gt; pair1(string("year"), 20);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair1.first&lt;&lt; <span class="built_in">endl</span>;                 <span class="comment">//访问pair第一个值 </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//访问pair第二个值 </span></span><br><span class="line"></span><br><span class="line">	pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = make_pair(<span class="string">"name"</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3 = pair2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair3.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-5.jpg" alt=""> </p>
<h3 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a><strong>set/multiset容器</strong></h3><p>set的特性是：所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值，所以我们无法通过set的迭代器改变set元素的值吗，set不允许两个元素有相同的键值。</p>
<p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。<strong>set和multiset的底层实现是红黑树</strong>，红黑树为平衡二叉树的一种。  </p>
<h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><ul>
<li>set<T> st;                <strong>//set默认构造函数</strong></li>
<li>mulitset<T> mst;                 <strong>//multiset默认构造函数</strong></li>
<li>set(const set &amp;st);                <strong>//拷贝构造函数</strong></li>
</ul>
<p>Eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		s.insert(i);</span><br><span class="line">		ms.insert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	s.insert(<span class="number">1</span>);</span><br><span class="line">	ms.insert(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-1.jpg" alt=""> </p>
<h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><ul>
<li>set&amp; operator=(const set &amp;st);                <strong>//重载等号操作符</strong> </li>
<li>swap(st);                <strong>//交换两个集合容器</strong></li>
</ul>
<h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><ul>
<li>size();                <strong>//返回容器中元素的数目</strong> </li>
<li>empty();                <strong>//判断容器是否为空</strong></li>
</ul>
<h4 id="set数据操作"><a href="#set数据操作" class="headerlink" title="set数据操作"></a>set数据操作</h4><ul>
<li>insert(elem);                <strong>//在容器中插入元素</strong></li>
<li>clear();                <strong>//清除所有元素</strong>  </li>
<li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong></li>
<li>erase(beg, end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li>
<li>erase(elem);                <strong>//删除容器中值为elem的元素</strong></li>
</ul>
<p>Eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		s.insert(i);</span><br><span class="line">		ms.insert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	s.insert(<span class="number">1</span>);</span><br><span class="line">	ms.insert(<span class="number">1</span>);</span><br><span class="line">	s.erase(++s.<span class="built_in">begin</span>(), --s.<span class="built_in">end</span>());</span><br><span class="line">	ms.erase(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mst = ms.<span class="built_in">begin</span>(); mst != ms.<span class="built_in">end</span>(); ++mst)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *mst &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-2.jpg" alt=""> </p>
<h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><ul>
<li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()</strong></li>
<li>count(key);                <strong>//查找键key的元素个数</strong>  </li>
<li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li>
<li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li>
<li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		s.insert(i);</span><br><span class="line">		ms.insert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> st1 = s.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">auto</span> st2 = s.lower_bound(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">auto</span> st3 = s.upper_bound(<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">auto</span> st4 = s.equal_range(<span class="number">6</span>);		<span class="comment">//pair类型</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *st1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st3 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *st4.first &lt;&lt; *st4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-3.jpg" alt=""> </p>
<h4 id="set排序方式的修改"><a href="#set排序方式的修改" class="headerlink" title="set排序方式的修改"></a>set排序方式的修改</h4><p>我们可以通过结构体重载（）来修改set原有的排序方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mycmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;		<span class="comment">//从大到小进行排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>, Mycmp&gt; s2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		s.insert(i);</span><br><span class="line">		s2.insert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator st = s.<span class="built_in">begin</span>(); st != s.<span class="built_in">end</span>(); ++st)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> st = s2.<span class="built_in">begin</span>(); st != s2.<span class="built_in">end</span>(); ++st)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *st &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-4.jpg" alt=""> </p>
<h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair，同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。  </p>
<p>Multimap和map的操作类似，唯一区别multimap键值可重复。 </p>
<h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><ul>
<li>map<T1, T2> mapTT;                <strong>//map默认构造函数</strong></li>
<li>map(const map &amp;mp);                <strong>//拷贝构造函数</strong></li>
</ul>
<h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><ul>
<li>map&amp; operator=(const map &amp;mp);                <strong>//重载等号操作符</strong> </li>
<li>swap(mp);                <strong>//交换两个集合容器</strong></li>
</ul>
<h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><ul>
<li>size();        <strong>//返回容器中元素的数目</strong> </li>
<li>empty();        <strong>//判断容器是否为空</strong></li>
</ul>
<h4 id="map数据操作"><a href="#map数据操作" class="headerlink" title="map数据操作"></a>map数据操作</h4><ul>
<li>insert();                 <strong>//往容器插入元素，返回pair<iterator,bool></strong> </li>
</ul>
<p>Eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str[<span class="number">4</span>] = &#123; <span class="string">"kk"</span>,<span class="string">"pp"</span>,<span class="string">"zz"</span>,<span class="string">"oo"</span> &#125;;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp;</span><br><span class="line">	pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; pr[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		pr[i] = make_pair(i, str[i]);</span><br><span class="line">		mp.insert(pr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"dd"</span>));</span><br><span class="line">	mp.insert(make_pair(<span class="number">5</span>, <span class="string">"vv"</span>));</span><br><span class="line">	mp[<span class="number">6</span>] = <span class="string">"nn"</span>;</span><br><span class="line">	mp[<span class="number">1</span>] = <span class="string">"mm"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> mt = mp.<span class="built_in">begin</span>(); mt != mp.<span class="built_in">end</span>(); ++mt)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; mt-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mt-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "/img/loading.gif" data-src="/photo/STL2-6.jpg" alt=""> </p>
<h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><ul>
<li>clear();                <strong>//删除所有元素</strong>  </li>
<li>erase(pos);                <strong>//删除pos迭代器所指的元素，返回下一个元素的迭代器</strong> </li>
<li>erase(beg,end);                <strong>//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器</strong></li>
<li>erase(keyElem);                <strong>//删除容器中key为keyElem的对组</strong></li>
</ul>
<h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><ul>
<li>find(key);                <strong>//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end()</strong></li>
<li>count(keyElem);                <strong>//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1</strong></li>
<li>lower_bound(keyElem);                <strong>//返回第一个key&gt;=keyElem元素的迭代器</strong></li>
<li>upper_bound(keyElem);                <strong>//返回第一个key&gt;keyElem元素的迭代器</strong></li>
<li>equal_range(keyElem);                <strong>//返回容器中key与keyElem相等的上下限的两个迭代器</strong></li>
</ul>
<p>由于这些操作和set大同小异，故在此不提供例子</p>
<h4 id="常见的map问题"><a href="#常见的map问题" class="headerlink" title="常见的map问题"></a>常见的map问题</h4><p><strong>1.set map的区别与联系</strong></p>
<p> 联系：1.Map,Set属于标准关联容器，底层数据结构使用红黑树</p>
<p>2.时间复杂度均为红黑树的时间复杂度，插入删除查找近似为O(logN)</p>
<p>区别：</p>
<p><strong>1.适用对象</strong><br>map适合存储一个数据字典，并要求方便地根据key找value<br>set适合查找一个元素是否在某集合内存中</p>
<p><strong>2.存储方式</strong><br>Set节点只含有Key，Key不重复.<br>Map节点有一个Key和Value两个元素,Key不重复,Value可以不重复。</p>
<p> <strong>3.元素改变</strong><br>set不能直接改变元素值。因为这样会打乱原有的顺序。改变元素值的方法是：先删除旧元素，再插入新元素。存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。<br>map可以通过key改变value的值</p>
<p><strong>2.map list 的使用场景与优势对比</strong></p>
<p>Map适用：是为了更快的从关键字查找到相关的对象。 </p>
<p>与使用list这样的线性表容器相比：一可以简化查找的算法，二可以使任意的关键字做索引，并与目标对象配对，优化查找算法。</p>
<p>在C++的STL中map是使用树来做查找算法，这种算法差不多相当与list线性容器的折半查找的效率一样，都是O (log2N)，而list就没有map这样易定制和操作了。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。</p>
<ul>
<li>stack<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入后出</strong>（Last-In-First-Out，LIFO）的压入栈</li>
<li>queue<T>：是一个封装了 deque<T> 容器的适配器类模板，默认实现的是一个<strong>先入先出</strong>（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器</li>
<li>priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而<strong>保证最大元素总在队列最前面</strong>的队列</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack就是数据结构中的栈，关于栈的详细介绍可看我《数据结构与算法:栈I/II/III/IV》四篇博客，这里不多加赘述，以下是常见操作</p>
<ul>
<li>stack<T> stkT;                <strong>//stack采用模板类实现， stack对象的默认构造形式</strong> </li>
<li>stack(const stack &amp;stk);                <strong>//拷贝构造函数</strong></li>
<li>stack&amp; operator=(const stack &amp;stk);                <strong>//重载等号操作符</strong></li>
<li>push(elem);                <strong>//向栈顶添加元素</strong> </li>
<li>pop();                <strong>//从栈顶移除第一个元素</strong> </li>
<li>top();                <strong>//返回栈顶元素</strong></li>
<li>empty();                <strong>//判断堆栈是否为空</strong> </li>
<li>size();                <strong>//返回堆栈的大小</strong></li>
</ul>
<p>都很简单，也不提供例子了，注意的是，stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素才有<br>机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue就是数据结构中的队列，关于队列的详细介绍可看我《数据结构与算法:队列I/II》两篇博客，这里不多加赘述，以下是常见操作</p>
<ul>
<li>queue<T> queT;                <strong>//queue采用模板类实现，queue对象的默认构造形式</strong></li>
<li>queue(const queue &amp;que);                <strong>//拷贝构造函数</strong></li>
<li>push(elem);                <strong>//往队尾添加元素</strong> </li>
<li>pop();                <strong>//从队头移除第一个元素</strong> </li>
<li>back();                <strong>//返回最后一个元素</strong> </li>
<li>front();                <strong>//返回第一个元素</strong></li>
<li>queue&amp; operator=(const queue &amp;que);                <strong>//重载等号操作符</strong></li>
<li>empty();                <strong>//判断队列是否为空</strong> </li>
<li>size();                <strong>//返回队列的大小</strong></li>
</ul>
<p>都很简单，也不提供例子了，同样的，队列也是不提供迭代器的</p>
<p>而priority_queue的基础用法和queue一样，在《记录备战CSP中刷到一些有意思的题目I》中的第一题就用到了priority_queue，并对其排序方法进行了重写，想了解的可以去看看</p>
<hr>
<p>以上就是我们的C++中STL的基本常用容器介绍啦，在C++11后还引入了无序容器（哈希容器），后续有机会再更新关于这系列的博客~</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KangKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">http://yoursite.com/2022/03/10/C-%E4%B8%AD%E7%9A%84STL-map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">K`onnor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/set/">set</a><a class="post-meta__tags" href="/tags/map/">map</a><a class="post-meta__tags" href="/tags/stack/">stack</a><a class="post-meta__tags" href="/tags/queue/">queue</a></div><div class="post_share"><div class="social-share" data-image="/photo/MSBD.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/21/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"><img class="prev-cover" data-src="/photo/CPP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++类型转换运算符</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/09/C-%E4%B8%AD%E7%9A%84STL-vector%E3%80%81list%E3%80%81deque%E3%80%81set%E3%80%81map%E3%80%81stack%E3%80%81queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><img class="next-cover" data-src="/photo/CSTL.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++中的STL:vector、list、deque的基本使用</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/11/30/C-中的STL-string的用法/" title="C++中的STL:string的基本使用"><img class="relatedPosts_cover" data-src="/photo/CSTL.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-30</div><div class="relatedPosts_title">C++中的STL:string的基本使用</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/09/C-中的STL-vector、list、deque、set、map、stack、queue的基本使用/" title="C++中的STL:vector、list、deque的基本使用"><img class="relatedPosts_cover" data-src="/photo/CSTL.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="relatedPosts_title">C++中的STL:vector、list、deque的基本使用</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/17/算法II-排序与查找的应用/" title="算法II:排序与查找的应用"><img class="relatedPosts_cover" data-src="/photo/SF.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="relatedPosts_title">算法II:排序与查找的应用</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/16/记录备战CSP中刷到一些有意思的题目II/" title="记录备战CSP中刷到一些有意思的题目II"><img class="relatedPosts_cover" data-src="/photo/CSP.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-16</div><div class="relatedPosts_title">记录备战CSP中刷到一些有意思的题目II</div></div></a></div><div class="relatedPosts_item"><a href="/2020/10/25/记录备战CSP中刷到一些有意思的题目/" title="记录备战CSP中刷到一些有意思的题目I"><img class="relatedPosts_cover" data-src="/photo/CSP.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-25</div><div class="relatedPosts_title">记录备战CSP中刷到一些有意思的题目I</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/26/C-中的移动语义/" title="C++中的移动语义"><img class="relatedPosts_cover" data-src="/photo/CPP.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-26</div><div class="relatedPosts_title">C++中的移动语义</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By KangKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>