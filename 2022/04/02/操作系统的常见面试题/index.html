<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统的常见面试题 | K`onnor</title><meta name="description" content="这篇整理一下面试中经常出现的操作系统面试题  进程和线程的区别？ 根本区别：进程是操作系统分配资源的基本单位，线程是任务调度和执行的基本单位。 在开销方面：每个进程都有独立的代码和数据空间(上线文切换)，程序之间的切换会有较大的开销。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间的切换开销比较小。 所处环境：在操作系统中能同时运行多个进程"><meta name="keywords" content="面试,操作系统"><meta name="author" content="KangKang"><meta name="copyright" content="KangKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="操作系统的常见面试题"><meta property="og:url" content="http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="og:site_name" content="K`onnor"><meta property="og:description" content="这篇整理一下面试中经常出现的操作系统面试题  进程和线程的区别？ 根本区别：进程是操作系统分配资源的基本单位，线程是任务调度和执行的基本单位。 在开销方面：每个进程都有独立的代码和数据空间(上线文切换)，程序之间的切换会有较大的开销。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间的切换开销比较小。 所处环境：在操作系统中能同时运行多个进程"><meta property="og:image" content="http://yoursite.com/photo/MSBD.png"><meta property="article:published_time" content="2022-04-02T07:34:16.000Z"><meta property="article:modified_time" content="2022-04-06T13:41:23.099Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="数据结构与计算机网络的常见面试题" href="http://yoursite.com/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="K`onnor" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">89</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画册</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程和线程的区别？"><span class="toc-number">1.</span> <span class="toc-text">进程和线程的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程的状态及转换？"><span class="toc-number">2.</span> <span class="toc-text">进程的状态及转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程-作业的调度算法？"><span class="toc-number">3.</span> <span class="toc-text">进程&#x2F;作业的调度算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协程是什么？"><span class="toc-number">4.</span> <span class="toc-text">协程是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程有哪几种状态？"><span class="toc-number">5.</span> <span class="toc-text">线程有哪几种状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说一下进程间的通信方式？"><span class="toc-number">6.</span> <span class="toc-text">说一下进程间的通信方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是死锁？"><span class="toc-number">7.</span> <span class="toc-text">什么是死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁产生的四个必要条件？"><span class="toc-number">8.</span> <span class="toc-text">死锁产生的四个必要条件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决死锁的基本方法？"><span class="toc-number">9.</span> <span class="toc-text">解决死锁的基本方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免死锁的方法？"><span class="toc-number">10.</span> <span class="toc-text">避免死锁的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号和信号量区别"><span class="toc-number">11.</span> <span class="toc-text">信号和信号量区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步与异步？"><span class="toc-number">12.</span> <span class="toc-text">同步与异步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"><span class="toc-number">13.</span> <span class="toc-text">简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟地址到物理地址怎么映射的？"><span class="toc-number">14.</span> <span class="toc-text">虚拟地址到物理地址怎么映射的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简述操作系统中malloc的实现原理"><span class="toc-number">15.</span> <span class="toc-text">简述操作系统中malloc的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说说多路IO复用技术有哪些"><span class="toc-number">16.</span> <span class="toc-text">说说多路IO复用技术有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-poll-epoll的区别"><span class="toc-number">17.</span> <span class="toc-text">select&#x2F;poll&#x2F;epoll的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通信的机制有哪些？"><span class="toc-number">18.</span> <span class="toc-text">线程通信的机制有哪些？</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/photo/MSBD.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">K`onnor</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画册</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统的常见面试题</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-04-02 15:34:16"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-04-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-04-06 21:41:23"><i class="fas fa-history fa-fw"></i> 更新于 2022-04-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/">笔试面试</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>这篇整理一下面试中经常出现的操作系统面试题</p>
<hr>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><ul>
<li><strong>根本区别</strong>：<strong>进程是操作系统分配资源的基本单位，线程是任务调度和执行的基本单位。</strong></li>
<li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间(上线文切换)，程序之间的切换会有较大的开销。线程可以看做轻量级的进程，<strong>同一类线程共享代码和数据空间</strong>，每个线程都有自己独立的运行栈和程序计数器，线程之间的切换开销比较小。</li>
<li><strong>所处环境</strong>：在操<strong>作系统中能同时运行多个进程</strong>，而在<strong>同一个进程中有多个线程同时执行</strong>(通过CPU调度，在每个时间片中只有一个线程)</li>
<li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间。而对于线程而言，除CPU外，系统不会为线程分配内存(线程所使用的资源来自其所属进程的资源)，线程组之间只能共享资源.</li>
</ul>
<h4 id="进程的状态及转换？"><a href="#进程的状态及转换？" class="headerlink" title="进程的状态及转换？"></a>进程的状态及转换？</h4><ul>
<li><strong>创建</strong>状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li><strong>就绪</strong>状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</li>
<li><strong>执行</strong>状态：进程处于就绪状态<strong>被调度</strong>后，进程进入执行状态</li>
<li><strong>阻塞</strong>状态：正在执行的进程由于<strong>某些事件（I/O请求，申请缓存区失败）</strong>而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li>
<li><strong>终止</strong>状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/photo/MST3-1.jpg" alt=""> </p>
<h4 id="进程-作业的调度算法？"><a href="#进程-作业的调度算法？" class="headerlink" title="进程/作业的调度算法？"></a>进程/作业的调度算法？</h4><p><strong>1、先来先服务(FCFS)调度算法</strong></p>
<p><strong>概念</strong>：按照进程进入系统的<strong>先后次序进行调度</strong>，先进入系统者先调度；即启动等待时间最长的作业/进程。是一种最简单的调度算法，即可用于作业调度，也可用于进程调度</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>比较有利于长作业（进程），而不利于短作业（进程）</li>
<li>有利于CPU繁忙型作业（进程），而不利于I/O繁忙型作业（进程）</li>
<li>用于批处理系统，不适于分时系统</li>
</ul>
<p><strong>2、短作业优先调度算法（SJF）</strong></p>
<p><strong>概念</strong>：从队列中选出一个<strong>估计运行时间最短</strong>的进程优先调度，即可用于作业调度，也可用于进程调度</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>对长作业不利。严重的是，若一长作业(进程)进入系统的后备队列(就绪队列)，由于调度程序总是优先调度那些(即使是后进来的)短作业(进程)，将导致长作业(进程)长期不被调度，<strong>可能出现饥饿的情况</strong></li>
<li>完全未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li>
<li>比较有利于短作业（进程），而不利于长作业（进程）</li>
</ul>
<p><strong>3、高优先权调度算法</strong></p>
<p><strong>非抢占式优先权调度算法</strong>：系统一旦把处理机<strong>分配给就绪队列中优先权最高的进程</strong>后，该进程便一直执行下去，直至完成，或因发生某事件使该进程放弃处理机时，系统才将处理机重新分配给另一优先权最高的进程主要用于批处理系统中，也可用于某些对实时性要求不严的实时系统中</p>
<p><strong>抢占式优先权调度算法</strong>：把处理机分配给优先权最高的进程，但在执行期间，<strong>只要出现另一个优先权更高的进程，则进程调度程序就立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程</strong></p>
<p><strong>4、高响应比优先调度算法</strong></p>
<p><strong>概念</strong>：高响应比优先调度算法<strong>既考虑作业的执行时间也考虑作业的等待时间</strong>，综合了先来先服务和最短作业优先两种算法的特点。<br>该算法中的响应比是指作业等待时间与运行比值，响应比公式：响应比 =（等待时间+要求服务时间）/要求服务时间</p>
<p><strong>优缺点：</strong></p>
<ul>
<li>优点：等待时间相同的作业，则要求服务的时间愈短，其优先权愈高，——对短作业有利。对于长作业，优先权随等待时间的增加而提高，其等待时间足够长时，其优先权便可升到很高，从而也可获得处理机——对长作业有利。既照顾了短作业，又考虑了作业到达的先后次序，又不会使长作业长期得不到服务</li>
<li>缺点：要进行响应比计算，增加了系统开销</li>
</ul>
<p><strong>5、时间片轮转法</strong></p>
<p><strong>概念</strong>：将所有的就绪进程<strong>按先来先服务的原则排成一个队列</strong>，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便停止该进程的执行，并将其放就绪队列尾；然后，再把处理机分配给就绪队列中新的队首</p>
<h4 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h4><ul>
<li><strong>协程属于线程</strong>。协程程序是在线程里面跑的，因此协程又称微线程</li>
<li><strong>协程没有线程的上下文切换消耗</strong>。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li>
<li>原子操作性。由于<strong>协程是用户调度的</strong>，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li>
</ul>
<h4 id="线程有哪几种状态？"><a href="#线程有哪几种状态？" class="headerlink" title="线程有哪几种状态？"></a>线程有哪几种状态？</h4><ul>
<li><strong>新建</strong>状态(New)：新创建了一个线程对象。</li>
<li><strong>就绪</strong>状态(Runnable)：线程对象创建后，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</li>
<li><strong>运行</strong>状态(Running)：就绪状态的线程获取了CPU，执行程序代码。</li>
<li><strong>阻塞</strong>状态(Blocked)：阻塞状态是线程放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</li>
</ul>
<h4 id="说一下进程间的通信方式？"><a href="#说一下进程间的通信方式？" class="headerlink" title="说一下进程间的通信方式？"></a>说一下进程间的通信方式？</h4><ul>
<li><strong>管道</strong>：分为匿名管道和命名管道，A进程将数据写入管道，B进程需要等待A进程将信息写完之后才能读出来。种方案不适合频繁的通信，优点就是简单。</li>
<li><strong>消息队列</strong>：消息队列就是一个消息的链表，是一系列保存在<strong>内核</strong>中消息的列表，用户进程可以向消息队列中添加消息，也可以向消息队列中读取消息。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。缺点是如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，这需要花费很多时间。</li>
<li><strong>共享内存</strong>：该通信方式就可以很好的解决拷贝所消耗的时间，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</li>
<li><strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。信号量定义了两种操作，P操作和V操作，P操作为申请资源，V操作是归还资源。</li>
<li><strong>套接字Socket</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><ul>
<li><strong>概念</strong>：所谓死锁，是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</li>
<li><strong>原因</strong>：两个进程竞争不可剥夺资源或者进程推进的顺序非法都可能产生死锁</li>
</ul>
<h4 id="死锁产生的四个必要条件？"><a href="#死锁产生的四个必要条件？" class="headerlink" title="死锁产生的四个必要条件？"></a>死锁产生的四个必要条件？</h4><ul>
<li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即<strong>在一段时间内某资源仅为一进程所占用</strong>。</li>
<li><strong>请求保持条件</strong>：当进程因请求资源而阻塞时，<strong>对已获得的资源保持不放</strong>。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，<strong>不能剥夺</strong>，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程—资源的环形链。</li>
</ul>
<h4 id="解决死锁的基本方法？"><a href="#解决死锁的基本方法？" class="headerlink" title="解决死锁的基本方法？"></a>解决死锁的基本方法？</h4><ul>
<li><strong>资源一次性分配</strong>：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li><strong>可剥夺资源</strong>：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li><strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h4 id="避免死锁的方法？"><a href="#避免死锁的方法？" class="headerlink" title="避免死锁的方法？"></a>避免死锁的方法？</h4><p>死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。避免死锁的具体实现通常利用银行家算法。两种避免办法如下：</p>
<ul>
<li>如果一个进程的请求会导致死锁，则不启动该进程</li>
<li>如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。</li>
</ul>
<h4 id="信号和信号量区别"><a href="#信号和信号量区别" class="headerlink" title="信号和信号量区别"></a>信号和信号量区别</h4><p><strong>信号</strong>：（signal）是一种处理异步事件的方式。信号是比较复杂的通信方式，用于<strong>通知进程有某种事件发生</strong>，除了用于进程外，还可以发送信号给进程本身。是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。</p>
<p><strong>信号量</strong>：（Semaphore）<strong>进程间通信处理同步互斥的机制</strong>。信号量是一个特殊的变量，它的本质是计数器，信号量里面记录了临界资源的数目，有多少数目，信号量的值就为多少，进程对其访问都是原子操作。它的作用就是，调协进程对共享资源的访问，让一个临界区同一时间只有一个进程在访问它。</p>
<p>这样就可以看出信号和信号量的区别了：信号是通知进程产生了某个事件，信号量是用来同步进程的。</p>
<h4 id="同步与异步？"><a href="#同步与异步？" class="headerlink" title="同步与异步？"></a>同步与异步？</h4><ul>
<li><strong>I/O模型的同步和异步</strong>：select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</li>
<li><strong>线程进程的同步异步</strong>：多线程配合完成一件事时出现了强烈的依赖关系就是同步，没有依赖就是异步</li>
<li><strong>阻塞和非阻塞</strong>：阻塞就是调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。非阻塞等待就是每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</li>
</ul>
<h4 id="简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"><a href="#简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？" class="headerlink" title="简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？"></a>简述一下虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</h4><ol>
<li><p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p>
<p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器(memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p>
</li>
<li><p><strong>虚拟内存</strong>：每个进程拥有独立的地址空间，这个<strong>空间被分为大小相等的多个块，称为页</strong>，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上<strong>其中一部分对应物理内存上的一块(称为帧）</strong>，还有一些没加载在内存中的对应在硬盘上。</p>
</li>
<li><p><strong>为什么要用虚拟内存</strong>：因为早期的内存分配方法存在以下问题：</p>
<p>（1）进程地址空间不隔离。会导致数据被随意修改。</p>
<p>（2）内存使用效率低。</p>
<p>（3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。</p>
</li>
<li><p><strong>使用虚拟内存的好处</strong>：</p>
<p>（1）扩大地址空间。</p>
<p>（2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。</p>
<p>（3）可以实现内存共享，方便进程通信。</p>
<p>（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。</p>
</li>
<li><p><strong>使用虚拟内存的缺点</strong>：</p>
<p>（1）虚拟内存需要额外构建数据结构，占用空间。</p>
<p>（2）虚拟地址到物理地址的转换，增加了执行时间。</p>
<p>（3）页面换入换出耗时。</p>
</li>
</ol>
<h4 id="虚拟地址到物理地址怎么映射的？"><a href="#虚拟地址到物理地址怎么映射的？" class="headerlink" title="虚拟地址到物理地址怎么映射的？"></a>虚拟地址到物理地址怎么映射的？</h4><p>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表中的每一项都记录了这个页的基地址。</p>
<h4 id="简述操作系统中malloc的实现原理"><a href="#简述操作系统中malloc的实现原理" class="headerlink" title="简述操作系统中malloc的实现原理"></a>简述操作系统中malloc的实现原理</h4><p>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<h4 id="说说多路IO复用技术有哪些"><a href="#说说多路IO复用技术有哪些" class="headerlink" title="说说多路IO复用技术有哪些"></a>说说多路IO复用技术有哪些</h4><p><strong>select，poll，epoll</strong>都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作</p>
<h4 id="select-poll-epoll的区别"><a href="#select-poll-epoll的区别" class="headerlink" title="select/poll/epoll的区别"></a>select/poll/epoll的区别</h4><p><strong>select</strong>：它仅仅知道了有I/O事件发生了，却并不知道是哪那几个流，只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<p><strong>poll</strong>：时间复杂度O(n)，poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<p><strong>epoll</strong>：时间复杂度O(1)，epoll不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。</p>
<h4 id="线程通信的机制有哪些？"><a href="#线程通信的机制有哪些？" class="headerlink" title="线程通信的机制有哪些？"></a><strong>线程通信的机制有哪些？</strong></h4><p><strong>锁机制：包括互斥锁、条件变量、读写锁</strong></p>
<p>（1）互斥锁提供了以排他方式防止数据结构被并发修改的方法。</p>
<p>（2）读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</p>
<p>（3）条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<p><strong>信号量机制（Semaphore）：包括无名线程信号量和命名线程信号量</strong></p>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KangKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">http://yoursite.com/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">K`onnor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/photo/MSBD.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" data-src="/photo/MSBD.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构与计算机网络的常见面试题</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/03/29/C-常见的面试题与答案/" title="C++常见的面试题与答案"><img class="relatedPosts_cover" data-src="/photo/MSBD.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-29</div><div class="relatedPosts_title">C++常见的面试题与答案</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By KangKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>